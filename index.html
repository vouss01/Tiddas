<!DOCTYPE html>

<html data-theme="kabylie" lang="fr">
<head>
    <meta charset="utf-8" />
<meta content="width=device-width, initial-scale=1.0" name="viewport" />
<!-- Security hardening -->
<meta content="default-src 'self' data: blob:; base-uri 'self'; object-src 'none'; frame-ancestors 'none'; form-action 'self'; img-src 'self' data: blob:; media-src 'self' data: blob:; font-src 'self' data:; style-src 'self' 'nonce-tiddas'; script-src 'self' 'nonce-tiddas' https://unpkg.com; connect-src 'self' https://parseapi.back4app.com https://*.b4a.io wss://*.b4a.io; upgrade-insecure-requests; worker-src 'self' blob:; manifest-src 'self' blob:" http-equiv="Content-Security-Policy" />
<meta content="no-referrer" name="referrer" />
<meta content="camera=(), microphone=(), geolocation=(), payment=(), usb=()" http-equiv="Permissions-Policy" />
<meta content="dark light" name="color-scheme" />
<title data-i18n="appTitle">Tiddas - Jeu</title>
<link href="#" id="pwa-manifest" rel="manifest" />
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABJklEQVR42s2XvQ2DMBCFzyf37JAUiaWEliYzIDFBZmMClqChDUhAATswQVJZMpYNxn/kKkD2fc93z8gmIMTjdvlChOjGmfBnjA2XWRgbLosgZ8DFQNXHdpiYb5AuJ1UOzPO+HSa2NEXvA55kFVuaom+HiT3v11VOZQt8wkURMlxZAQAADn+9P7uJ6zKFvbF1mYJuQdREPYccHWOyAPQBd5lLbZPz1elaYCoc4eSgvsprYkYnAXLJjwoL5gFXs9KQDncWIEJ8AYO3QLU9t8TTPYhucpQW6Fa8BT+6C9C2/KIg+T2KB3y1g4aG7JkQj7rdZadYV0CXyPb//1dHMtTBk6xiPuH8oGtcAZVa12O5Kuf5FxPxohg7unEmKN9WY8JXJowpQmT9ABkqrop8prLHAAAAAElFTkSuQmCC" />
<link rel="icon" type="image/png" sizes="192x192" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAGIklEQVR42u3dMU7jQBSH8dhKzx1IQSKRbWk4AxIn4Gx7AqScYRtaQAoUcAdOwBZLslFwIA7xeDzv9zUrLQWx/f/ee2NPcDXqgfOz0/cRsMXj82uV+ndWAo/IQlRCj8gyVEKPyDLUwo+hccysVYKPyN2gFn5E7gaV4CNyN6iFH5G7QS38iCxBLfyILEEt/IgsQS38iCxBLfyILEHtFCEyteqPyF2gFn5ElsAIBCOQ6o+oXaAWfkSWwAgEIxAQlSr1+PPw9DLb/r/5dLJ0KeLRZxZWW6fHyQ/26mq562dEiBX8t7vr3rOQpAM8PL3MmoL/icViRoLyw98U/G1OLm47zcKqA9TZhP+jOzS1RcQK/6o7dJmFVebrrg947/CTQPgTS9C5AEDu1F0a37r66wKqf+IuUHv6i6icn52+j3P+gH9+/3KVMMwRCCAAEFWA+XSyHC0Why1eFouDF03Ij7e76+XJxe1BWej6gZgOgNBUXd8Fan07NMh2iKYF/uXNfdHH3PZ2aNfVP0kHaDUK2QtUNPPpZO9RKEX4R6NEu0Hn08nyq92gK0GEP4YEX+0GXQmSKgvjlAe+HokaFkmiEWtRvBn2ppykYtxHBdg1AyOmCH2uf9wFQmgIAAIABAAIABAAIAAQgbFTkI7vnn38+f2r+P1AOkDQ4O/74M8DQh0gRLXXCQgg+CCA0IMAgg8CCG0OnzPa2mMs+Gg6T1FEGAs+IotQCz8in0MPwmARHKlybbb03KpbDuNG0zkp+cFcqLtAlzf3vYY+Z/lyOUdGoA6rf5+3FodUQZs+a6lSeBBW8DgDAgg+YgiQy2wPAoQIvtATQLUHAcz1GDK1QH79e4RfB1DtoQNECWqbL7BDByiWiK8wIgBIQQCQggCDDB4poAMQFi3wjbDMJCGKDrAXJe9Z/+44jFM6wM5gRAiHTqED/KhjlNwpdAcCHDQ+lSIGKQhgXUEKApDisIW2vw2K0ERbXBOgw3GitDBtHk8pnYIAxqfQ6woCZCBFxNGDAAjTLQiA4qUY6pqAAAOWQof4OXaDFiiIh1w6QFh0BR1A0KEDCHv6z+g5AFR2AuR58XMMVslbJQgAlZ0Awg4CCDyyxW1Q6AC5cKzbaMfaqltSZW97/F1ud87pvBqBCh1jbIcgQMiZXfAJUHTo7QYlgDEGBBB26ADCDgIIOwIKcHlzn90YJOwEUOUxKGyFaBn0XP5Sgz94S4BeQrcr7CklcP/fCJStIMYwHUAVBAGg+huBIPgESHfxo4xFgm8E2hkMr0mFEeibquklFQi9BvCaVFgEB1pXkIIApNjzGLwmFWGlKOk4CECKTuXwmlToFAWMT7ZC9CCFBagOgD06hoddBCDEQEYor0kFKQgAUlgEo2eEXwcQeBBA2NN+Lq9JzWgm3g7KUC+Q6k6AMFVK2AnQaRcQsuOfYwJA2AdM7aLhu3NY8nkcR7iARh/FI/wIRATBtwbo+QL3IZ8xkAAEBwGEHQTIILA/GYMEngBhJBB2AoSTQOjT4/sAIABAAIAAAAEAAgAEAAgAlEvyB2EPTy+z7f97u7teuhTxOLm4nf3Pxb9/59PJskgBVsFvCvv/EzEhQqTgX10td+UklQjjVOH/qsqvfvbw9DJLXQHQwwTQEPw1Hz9LlYW67/Bvi9A0IiFI+LdESJGF6vzs9D2H8G+3SOuCAseefcO/yWLRaSdwFwih6UyAQ6v/ahTavEOAoNU/wSikA0AHAKKS9TfCfEOqDFYPubLsAI/Pr5VLhIg8Pr9WnY1A8+nk4IXsycWtB2IFMZ9OlqPF4rCFrNugwEAXwYd0AdVfF0hV/dcCdLkOaCOB8JMgVfhXmV8Hv8stEf/uBHy/G1T4Y7B+sNX0cOxDkK6zkFyATwe/XRkQV4QesvBJgJQSAH2yOfK7C4TQEAAEaGoNQOnjT2MHIAGihN8IBCPQvqYApVX/LzsACVB6+I1AMAIdag4w9Oq/VwcgAUoN/94jEAlQYvhbrQFIgNLC33oRTAKUFP7WApAAJYV/NNraDt0W26cx1OAf3AF0A5QS/h93AN0AQw3+UTqAboAhh/+oHUBHwFBCn0QAMmAIU0UvYwshkMsY/Rc2VH/a+oUJTAAAAABJRU5ErkJggg==" />
<link rel="apple-touch-icon" sizes="180x180" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAYAAAA9zQYyAAAF40lEQVR42u3dQU7jShRG4djKnD2QAYlEesqENSCxAtbWK0DKGnrCFJACA9gDK6AHjdMoOCE2Kdt1/Z3Jk4haz04d/763qhwXkw45Pzt9n2B0PD6/Fl39vwoCI5LgBYkRSe6CyIgkdkFkRBK7JDOGxE+dKoiMSGldkhmR0rokMyJJXZIZkaQuyYxIUpdkRiSpSzIjktQlmRFJ6tLXg0iU0hmRUrokMyJJreRA3JJDOiP3lJbQCEXRVTo/PL0stv+2nM/WhiAefYx1tTNv2tnJXV2td31G7Fgiv91d9zbWSRP64ellUSfyF1arBanzl7lO5G1OLm6TjHWV0GXvMn+kd91tCrFkrtI7xVhXDpepTvBgmUk9GplTS22WA+EoU1yxjdNZSo8mnVOndGkxBVE4Pzt9nw7xwP78/mV0oIYGCA1C72M5n60nq1W7Yn+1at1koHve7q7XJxe3rcY61QKLhEYoilSzHI2n74Iuf9c1uJc396HOsen0Xap0TprQjUoPezmyZjmfHVx6pJR5Mkm82245n6337barhCdzDKn37barhE891tMuTnRTgtQ0FVSI1SR+lrfOg9RMu7yCd9WUiCl2H/2CWQ6EgtAgNEBogNAAoUFoHJs/v3/tnKI0dUnoECKTOj1TX8FxJG7776JtVCL0CEUGoUkMQhOZ0GQMfGxjqNenRB7fXSay2FMiEzsSJZmJTWhAydFf4lze3PfWfA3pqe+6Y4m2uDOKhO5K5sub+0HLMYZZjpK0x5E4F1nqjjNSLW1hRdqpoceazCQmNJFBaBJDDU1iTDKb5UglXE6zFJDQ0lhCkxkSOuvmkuSEDi850QktzUHon6YoySGhSR4SG/xHcEeR0AMlytbH745Zso84oSOu8h36+3gYWQ393aNQuSW55NYUhipXNJ6EblWr5iS6BSFCNxY9SuPpIVk0TnfNpoTONukiPUH9+bir88rxNzsIrfnce7y5/Q4eoUmu5ADJCY3Gkg9F8JzqaLMcAZIdhM4WZYmSg6xHOC6zHJC0YxU61eAO+ZEtF6CENvAgNHkJDSJni2k7SOhjc4wpoTb7fyMkbZvvLtVe6SF8n6MpOaKUCVYKRyx0zhJ3/W5FQpNW6hKavOQlNHlBaPISWqNE3uyxsNJC3i4uKr+SpOToNHVT7hE2XUfoZBJVv25a97k32xI6jOhQQ5NLOktodT0ITWRC5zrQlsMRKqE//1JmpMaT5EqOvVJ4/QShw9elJCf0KJov71ghtDSX5oQm+TDSnNAII3ndcXvHCnZKnvsr4XJ7x4r90ANqRiGhlSsgNMnj3lEITXIJjf6bNRCawD84Du9Y6eHWvC1ATgMhfQmddboQmNCtUnqI8gxdZiuFyD4Imvx9yJRjGRzUf1fRvq9p1IFSp47zoh/FI1jEHs/da2og82z6lFaaQhcloUFeQhOy4Q+zE5jQ2UtN4jR4YqWH0oHMhAYIDUIDhAYIDRAaIDRGRGcLKw9PL4vtv73dXa8NQTxOLm4X/8f933+X89k6hNCVyHXy/j/xGbEjiXx1td7lQWqxp6ll3pfC1WcPTy+Lrq5gJAyuGpE3fHyWeqzLvmTeFruuJEEQmbfETjnWxfnZ6XufMm/fstTVGZYZh8r8mdUqSVKb5UAoji5023SuSo/PHTKCpnPC0kNCQ0IDQ2WQT6zYAJ8H1aLJoBL68fm1MDSIwOPza3H0kmM5n7Vu7E4ubi2wZMRyPltPVqt2jZ1pO6AnoduktHQeUUonSueN0Cnq6CZSk3lEUieSuXJ4I3KKJfB/nfD3u+3IHIPNQkndYsuH8KnGujOhv5zs9pWNuGJ3ONZfhO5CaiClzMmaQqAvyl2mA7mls4RG7ISW0sg5nXcmNKmRo8xKDsQvOaQ0ck3nbxOa1MhJ5oNKDlIjF5kPrqFJjRxkbtQUkhpDl7mR0KTG0GVuLDSpMWSZJ5Ot3XZNsTsPQxG5dUJLawxV5h8ntLTGUEQ+utDExhDu8klLBnKj61K10xqY4AROzV/seXuxJLIpzwAAAABJRU5ErkJggg==" />
<meta content="#fff3bf" name="theme-color" />
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" />
<meta content="Tiddas" name="apple-mobile-web-app-title" />
<style nonce="tiddas">
:root {
/* Core palette */
--stone-dark: #2c2722;
--stone-medium: #6a6054;
--stone-light: #d0c4b2;
--wood-dark: #5a341f;
--wood-medium: #7c4a2b;
--wood-light: #9d603a;

/* Accessible text system (defaults tuned for darker themes) */
--text-main: rgba(245,245,245,0.94);
--text-muted: rgba(245,245,245,0.78);
--text-light: #f5f5f5;
/* kept for legacy usages */
--text-gold: #f0c850;

--danger-red: #ff4d4d;
--highlight-cyan: #00ffff;
--info-blue: #63a4ff;

--transition-duration: 0.25s;

--board-border-dark: #201b17;
--board-surface-light: #2b231d;
--parchment-bg: rgba(0,0,0,0.35);

/* Better defaults for visibility */
--cell-border: rgba(240, 200, 80, 0.30);
--panel-bg: rgba(0,0,0,0.45);
--panel-border: rgba(240,200,80,0.35);

/* Stone colors (player setup previews) */
--player1-stone-color-dark: #1a1a1a;
--player1-stone-color-light: #333333;
--player2-stone-color-dark: #cccccc;
--player2-stone-color-light: #ffffff;

/* Typography helpers */
--font-title: 'Space Grotesk', var(--font-ui);
--font-body: 'Inter', var(--font-ui);
--font-ui: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
}

/* ===== Single-file UI Icons (no external font dependencies) ===== */
.icon {
display: inline-flex;
align-items: center;
justify-content: center;
width: 1.15em;
height: 1.15em;
line-height: 1;
font-size: 1.05em;
transform: translateY(0.05em);
}
.icon.icon-modern {
width: 1.15em;
height: 1.15em;
transform: translateY(0.02em);
}
.icon svg {
width: 100%;
height: 100%;
display: block;
stroke: currentColor;
fill: none;
stroke-width: 2;
stroke-linecap: round;
stroke-linejoin: round;
}
.icon.icon-solid svg {
fill: currentColor;
stroke: none;
}

* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
html {
height: 100%;
font-size: clamp(13px, 1.5vw, 16px);
overflow-x: hidden;
}
body {
min-height: 100vh;
min-height: 100dvh;
background: linear-gradient(135deg, #3a2d25, #2a201a);
color: var(--text-main);
font-family: var(--font-body);
line-height: 1.45;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
position: relative;
overflow-x: hidden;
max-width: 100vw;
background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="none" stroke="%234a3d35" stroke-width="2" opacity="0.1"/><path d="M10,50 Q50,10 90,50 Q50,90 10,50 Z" fill="none" stroke="%234a3d35" stroke-width="1" opacity="0.05"/></svg>');
background-size: 80px;
display: flex;
flex-direction: column;
text-rendering: optimizeLegibility;
}
.stone-decoration {
position: absolute;
width: min(12vw, 50px);
height: min(12vw, 50px);
background: radial-gradient(circle at 30% 30%, var(--stone-medium), var(--stone-dark) 70%), linear-gradient(145deg, var(--stone-medium), var(--stone-dark));
border-radius: 50%;
box-shadow: inset 0 -8px 15px rgba(0,0,0,0.3), 0 8px 15px rgba(0,0,0,0.4);
z-index: 0;
display: flex;
align-items: center;
justify-content: center;
font-size: 1.7rem;
color: var(--text-main, var(--text-gold));
text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
opacity: 0.7;
transition: transform 0.5s ease, opacity 0.5s ease, box-shadow 0.3s ease;
filter: saturate(1.2);
border: 2px solid rgba(240, 200, 80, 0.2);
}
.stone-1 {
top: 3%;
left: 3%;
transform: rotate(20deg);
}
.stone-2 {
top: 3%;
right: 3%;
transform: rotate(-30deg);
}
.stone-3 {
bottom: 3%;
left: 3%;
transform: rotate(10deg);
}
.stone-4 {
bottom: 3%;
right: 3%;
transform: rotate(-15deg);
}
header {
text-align: center;
padding: 0.75rem 0 0.5rem;
width: 100%;
position: relative;
flex-shrink: 0;
transition: opacity 0.3s ease, height 0.3s ease, padding 0.3s ease;
overflow: hidden;
}
header::after {
content: '— ⵣ —';
display: block;
font-size: 1.1rem;
color: var(--text-gold);
opacity: 0.45;
letter-spacing: 6px;
margin-top: 0.2rem;
}
header.hidden {
opacity: 0;
height: 0;
padding: 0;
pointer-events: none;
}
h1 {
font-family: var(--font-title);
font-size: clamp(2.2rem, 6vw, 3.2rem);
margin: 0;
color: var(--text-gold);
text-shadow: 3px 3px 6px rgba(0,0,0,0.6), 0 0 30px rgba(240,200,80,0.25);
letter-spacing: 5px;
position: relative;
}
h1::after {
content: 'ⵜⵉⴷⴷⴰⵙ';
display: block;
font-size: 0.32em;
letter-spacing: 8px;
opacity: 0.65;
font-family: var(--font-body);
color: var(--text-gold);
text-shadow: none;
margin-top: -0.2em;
}
/* language-selector styles merged into toolbar section above */
.game-container {
flex-grow: 1;
display: flex;
align-items: center;
justify-content: center;
width: 100%;
padding: clamp(0.5rem, 2vw, 1rem);
min-height: 0;
overflow: hidden;
z-index: 1;
}
.selection-area {
display: none;
flex-direction: column;
align-items: center;
gap: 1.5rem;
width: 100%;
max-width: 950px;
max-height: calc(100dvh - 5rem);
overflow-y: auto;
padding: clamp(1.5rem, 4vw, 3rem);
background: var(--panel-bg, rgba(0,0,0,0.4));
border-radius: 15px;
box-shadow: 0 10px 30px rgba(0,0,0,0.25);
border: 2px solid var(--panel-border, rgba(240, 200, 80, 0.5));
animation: fadeInUp 0.5s ease forwards;
opacity: 0;
position: relative;
backdrop-filter: blur(3px);
}
.selection-area.active {
display: flex;
}
.selection-area h2 {
font-family: var(--font-title);
font-size: clamp(1.8rem, 5vw, 2.5rem);
color: var(--text-gold);
text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
margin-bottom: 1rem;
text-align: center;
letter-spacing: 1px;
}
@keyframes fadeInUp {
from {
opacity: 0;
transform: translateY(20px);
}
to {
opacity: 1;
transform: translateY(0);
}
}
.version-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(min(250px, 90vw), 1fr));
gap: 1.5rem;
width: 100%;
justify-content: center;
}
.version-card {
background: var(--panel-bg, rgba(0,0,0,0.3));
border: 1px solid var(--panel-border, rgba(240, 200, 80, 0.4));
border-radius: 9px;
padding: 1.2rem;
display: flex;
flex-direction: column;
align-items: center;
text-align: center;
cursor: pointer;
transition: all 0.3s ease;
box-shadow: 0 5px 15px rgba(0,0,0,0.4);
position: relative;
overflow: hidden;
backdrop-filter: blur(3px);
}
.version-card:hover {
transform: translateY(-8px) scale(1.03);
box-shadow: 0 12px 25px rgba(0,0,0,0.5), 0 0 20px rgba(240, 200, 80, 0.6);
border-color: var(--text-gold);
}
.version-card.active {
background: var(--text-gold);
color: var(--stone-dark);
box-shadow: 0 0 25px rgba(240, 200, 80, 0.9), inset 0 0 15px rgba(0,0,0,0.5);
border-color: var(--text-gold);
transform: scale(1.05);
}
.version-card h3 {
font-family: var(--font-title);
font-size: clamp(1.2rem, 4vw, 1.5rem);
color: var(--text-gold);
margin-bottom: 8px;
text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
transition: color var(--transition-duration) ease;
}
.version-card.active h3 {
color: var(--stone-dark);
text-shadow: none;
}
.version-card p {
font-size: clamp(0.9rem, 2.5vw, 1rem);
line-height: 1.55;
color: var(--text-muted);
text-shadow: none;
transition: color var(--transition-duration) ease;
}
.version-card.active p {
color: var(--stone-dark);
}
.rules-btn {
margin-top: 1rem;
padding: 0.8rem 1.8rem;
border-radius: 8px;
background: var(--panel-bg, rgba(0,0,0,0.3));
border: 1px solid var(--panel-border, rgba(240, 200, 80, 0.4));
color: var(--text-gold);
font-family: var(--font-title);
font-size: 1.1rem;
cursor: pointer;
transition: all 0.3s ease;
display: flex;
align-items: center;
gap: 10px;
}
.rules-btn:hover {
background: rgba(240, 200, 80, 0.15);
border-color: var(--text-gold);
transform: translateY(-3px);
}
.options-group {
display: flex;
flex-wrap: wrap;
justify-content: center;
gap: 1.5rem;
width: 100%;
}
.option-btn {
flex: 1;
min-width: min(200px, 90vw);
max-width: 280px;
padding: 1.5rem;
border-radius: 12px;
background: var(--panel-bg, rgba(0,0,0,0.3));
border: 1px solid var(--panel-border, rgba(240, 200, 80, 0.4));
color: var(--text-main);
font-family: var(--font-title);
font-size: clamp(1.1rem, 4vw, 1.3rem);
cursor: pointer;
transition: all 0.3s ease;
display: flex;
flex-direction: column;
align-items: center;
gap: 10px;
text-shadow: none;
box-shadow: 0 4px 10px rgba(0,0,0,0.3);
backdrop-filter: blur(2px);
}
.option-btn:hover {
transform: translateY(-8px);
background: rgba(240, 200, 80, 0.15);
box-shadow: 0 12px 25px rgba(0,0,0,0.5), 0 0 20px rgba(240, 200, 80, 0.6);
border-color: var(--text-gold);
}
.option-btn[disabled] {
cursor: not-allowed;
opacity: 0.5;
filter: grayscale(80%);
}
.option-btn[disabled]:hover {
transform: none;
background: rgba(0,0,0,0.3);
box-shadow: 0 4px 10px rgba(0,0,0,0.3);
border-color: rgba(240, 200, 80, 0.4);
}
.option-btn i {
font-size: 2.8rem;
color: var(--text-gold);
filter: drop-shadow(0 0 5px rgba(240, 200, 80, 0.5));
}
.option-btn span {
font-size: 1rem;
font-family: var(--font-body);
opacity: 1;
line-height: 1.45;
color: var(--text-muted);
text-shadow: none;
}
.back-btn {
padding: 0.7rem 1.8rem;
border-radius: 25px;
background: transparent;
border: 1px solid rgba(240, 200, 80, 0.6);
color: var(--text-gold);
font-family: var(--font-body);
cursor: pointer;
transition: all 0.3s ease;
margin-top: 1rem;
box-shadow: 0 2px 5px rgba(0,0,0,0.3);
backdrop-filter: blur(1px);
}
.back-btn:hover {
background: rgba(240, 200, 80, 0.2);
transform: translateY(-3px);
box-shadow: 0 5px 10px rgba(0,0,0,0.4), 0 0 10px rgba(240, 200, 80, 0.4);
}
.player-setup-area {
gap: 2rem;
padding: 2.5rem;
background: rgba(0,0,0,0.5);
border: 2px solid var(--text-gold);
box-shadow: 0 0 25px rgba(240, 200, 80, 0.7), inset 0 0 15px rgba(0,0,0,0.6);
border-radius: 20px;
backdrop-filter: blur(5px);
}
.player-setup-area .setup-section {
width: 100%;
display: flex;
flex-direction: column;
align-items: center;
gap: 1.25rem;
padding: 1.5rem;
border: 1px solid rgba(240, 200, 80, 0.4);
border-radius: 15px;
background: rgba(0,0,0,0.3);
box-shadow: inset 0 0 15px rgba(0,0,0,0.4);
}
.player-setup-area .setup-section h3 {
font-size: clamp(1.4rem, 4vw, 1.8rem);
color: var(--text-gold);
text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
margin-bottom: 1rem;
}
.player-setup-area .input-group {
display: flex;
flex-direction: column;
gap: 10px;
width: 100%;
max-width: 450px;
}
.player-setup-area label {
font-size: clamp(1rem, 3vw, 1.2rem);
color: var(--text-light);
text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}
.player-setup-area input[type="text"] {
padding: 0.8rem 1.25rem;
font-size: 1.1rem;
border-radius: 8px;
border: 1px solid rgba(240, 200, 80, 0.6);
background: rgba(255,255,255,0.1);
color: var(--text-light);
outline: none;
box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
transition: all 0.3s ease;
}
.player-setup-area input[type="text"]::placeholder {
color: rgba(255,255,255,0.6);
}
.player-setup-area input[type="text"]:focus {
border-color: var(--highlight-cyan);
box-shadow: inset 0 2px 5px rgba(0,0,0,0.5), 0 0 10px rgba(0,255,255,0.5);
}
.player-setup-area .color-choice-group {
display: flex;
flex-wrap: wrap;
justify-content: center;
gap: 1.5rem;
margin-top: 1.25rem;
width: 100%;
}
.player-setup-area .color-option {
display: flex;
flex-direction: column;
align-items: center;
gap: 0.8rem;
padding: 1.25rem;
border-radius: 15px;
background: rgba(0,0,0,0.35);
border: 2px solid rgba(240, 200, 80, 0.5);
color: var(--text-light);
font-family: var(--font-body);
font-size: clamp(0.9rem, 3vw, 1.15rem);
cursor: pointer;
transition: all 0.3s ease;
box-shadow: 0 5px 15px rgba(0,0,0,0.4);
position: relative;
overflow: hidden;
min-width: min(180px, 40vw);
flex: 1;
max-width: 220px;
text-align: center;
}
.player-setup-area .color-option:hover {
transform: translateY(-5px);
box-shadow: 0 8px 20px rgba(0,0,0,0.6), 0 0 15px rgba(240, 200, 80, 0.7);
border-color: var(--text-gold);
}
.player-setup-area .color-option.selected {
background: linear-gradient(135deg, var(--text-gold), #e0b040);
color: var(--stone-dark);
border-color: var(--text-gold);
box-shadow: 0 0 25px rgba(240, 200, 80, 0.9), inset 0 0 15px rgba(0,0,0,0.5);
transform: scale(1.03);
}
.player-setup-area .color-option input[type="radio"] {
position: absolute;
opacity: 0;
pointer-events: none;
}
.player-setup-area .color-option .stone-preview {
width: 70px;
height: 70px;
border-radius: 50%;
box-shadow: 0 5px 15px rgba(0,0,0,0.6), inset 0 -5px 15px rgba(0,0,0,0.5), inset 0 5px 10px rgba(255,255,255,0.4);
transition: all 0.3s ease;
}
.player-setup-area .color-option.selected .stone-preview {
box-shadow: 0 0 0 5px rgba(255,255,255,0.5), 0 5px 15px rgba(0,0,0,0.6), inset 0 -5px 15px rgba(0,0,0,0.5);
}
.player-setup-area .color-option .stone-preview.player1 {
background: radial-gradient(circle at 35% 35%, var(--player1-stone-color-light), var(--player1-stone-color-dark) 60%, #000 90%);
}
.player-setup-area .color-option .stone-preview.player2 {
background: radial-gradient(circle at 35% 35%, var(--player2-stone-color-light), var(--player2-stone-color-dark) 60%, #e0e0e0 90%);
}
.player-setup-area .color-option .checkmark {
position: absolute;
top: 10px;
right: 10px;
color: var(--stone-dark);
font-size: 1.8em;
opacity: 0;
transform: scale(0.5);
transition: all 0.3s ease;
text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
}
.player-setup-area .color-option.selected .checkmark {
opacity: 1;
transform: scale(1);
}
.start-game-btn {
display: inline-flex;
align-items: center;
justify-content: center;
gap: 1rem;
padding: 1.1rem 3rem;
border-radius: 50px;
background: linear-gradient(145deg, #FFE066, #FFB700, #FF8C00);
color: #3a1a08;
font-family: var(--font-title);
font-size: clamp(1.4rem, 5vw, 1.9rem);
font-weight: 800;
cursor: pointer;
transition: all 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
box-shadow: 0 6px 24px rgba(0,0,0,0.55), 0 0 0 0 rgba(255,200,0,0.5), 0 3px 0 rgba(0,0,0,0.35);
text-shadow: 0 1px 2px rgba(255,255,255,0.3), 0 2px 4px rgba(0,0,0,0.2);
border: 3px solid rgba(139,69,19,0.6);
letter-spacing: 4px;
text-transform: uppercase;
margin-top: 1.5rem;
position: relative;
overflow: hidden;
z-index: 1;
animation: playBtnPulse 2.5s ease-in-out infinite;
}
.start-game-btn::before {
content: '';
position: absolute;
top: -50%;
left: -60%;
width: 40%;
height: 200%;
background: linear-gradient(100deg, transparent, rgba(255,255,255,0.5), transparent);
transform: skewX(-20deg);
animation: shimmer 2.8s ease-in-out infinite;
}
@keyframes shimmer {
0% {
left: -60%;
opacity: 0;
}
20% {
opacity: 1;
}
60% {
left: 130%;
opacity: 1;
}
100% {
left: 130%;
opacity: 0;
}
}
@keyframes playBtnPulse {
0%, 100% {
box-shadow: 0 6px 24px rgba(0,0,0,0.55), 0 0 0 0 rgba(255,200,0,0.6), 0 3px 0 rgba(0,0,0,0.35);
}
50% {
box-shadow: 0 6px 24px rgba(0,0,0,0.55), 0 0 0 8px rgba(255,200,0,0), 0 3px 0 rgba(0,0,0,0.35);
}
}
.start-game-btn i {
font-size: 0.9em;
filter: drop-shadow(0 1px 3px rgba(0,0,0,0.3));
}
.start-game-btn:hover {
transform: translateY(-6px) scale(1.06);
box-shadow: 0 16px 36px rgba(0,0,0,0.7), 0 0 40px rgba(255,200,0,0.7), 0 4px 0 rgba(0,0,0,0.4);
background: linear-gradient(145deg, #FFE880, #FFD000, #FFA000);
border-color: #A0522D;
letter-spacing: 5px;
}
.start-game-btn:active {
transform: translateY(2px) scale(0.97);
box-shadow: 0 3px 12px rgba(0,0,0,0.5);
background: linear-gradient(145deg, #FFB700, #FF8C00, #FFE066);
animation: none;
}
.game-play-area {
display: none;
width: 100%;
height: 100%;
opacity: 0;
animation: fadeInUp 0.5s ease forwards;
padding: 1rem;
}
.game-play-area.active {
display: flex;
flex-direction: column;
align-items: center;
gap: 1rem;
}
.player-panel-container {
width: 100%;
max-width: 500px;
}
.center-column {
width: 100%;
display: flex;
flex-direction: column;
align-items: center;
gap: 1rem;
}
.game-board-container {
position: relative;
width: min(95vw, calc(95vh - 10rem), 600px);
width: min(95vw, calc(95dvh - 10rem), 600px);
max-width: 600px;
aspect-ratio: 1 / 1;
padding: 15px;
background: linear-gradient(160deg, var(--wood-dark) 0%, var(--wood-medium) 100%);
border-radius: 20px;
box-shadow: 0 10px 30px rgba(0,0,0,0.7), inset 0 0 20px rgba(0,0,0,0.4);
border: 10px solid var(--wood-light);
display: flex;
align-items: center;
justify-content: center;
}

@media (min-width: 1200px) {
.game-play-area.active {
display: grid;
grid-template-columns: 1fr auto 1fr;
align-items: center;
justify-content: center;
gap: 2rem;
padding: 1rem 2rem;
height: 100%;
perspective: 2000px;
}
.player-panel-container {
display: flex;
height: 100%;
align-items: center;
}
.player-panel-left {
justify-content: flex-end;
}
.player-panel-right {
justify-content: flex-start;
}
.player-panel {
width: 100%;
max-width: 320px;
}
.game-board-container {
width: clamp(400px, 70vh, 680px);
transform: rotateX(8deg) scale(1);
transition: transform 0.5s ease;
}
}

.game-board {
background: var(--board-surface-light);
border: 4px solid var(--stone-dark);
border-radius: 9px;
box-shadow: inset 0 0 15px rgba(0,0,0,0.4);
width: 100%;
height: 100%;
display: grid;
grid-template-columns: repeat(5, 1fr);
grid-template-rows: repeat(5, 1fr);
gap: 0;
position: relative;
overflow: hidden;
z-index: 2;
}
.player-info {
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
padding: clamp(0.75rem, 2vw, 1.25rem);
border-radius: 12px;
background: rgba(0,0,0,0.45);
box-shadow: inset 0 0 8px rgba(0,0,0,0.5), 0 5px 10px rgba(0,0,0,0.3);
border: 1.5px solid;
width: 100%;
height: 100%;
transition: all 0.4s ease-in-out;
backdrop-filter: blur(2px);
}
.player-title {
font-size: clamp(1rem, 3vw, 1.2rem);
margin-bottom: 0.75rem;
font-weight: bold;
text-align: center;
color: var(--text-gold);
text-shadow: 1px 1px 4px rgba(0,0,0,0.7);
}
.player-stats {
display: flex;
justify-content: space-around;
align-items: center;
width: 100%;
gap: 1rem;
}
.player-stat {
display: flex;
align-items: center;
justify-content: center;
gap: 0.5rem;
}
.player-stat i {
font-size: clamp(1rem, 2.5vw, 1.2rem);
color: var(--text-gold);
opacity: 0.8;
text-shadow: 0 0 3px rgba(240, 200, 80, 0.5);
}
.stat-value {
font-size: clamp(1.2rem, 3.5vw, 1.4rem);
font-weight: bold;
color: var(--text-gold);
text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
}
.controls {
display: flex;
flex-wrap: wrap;
justify-content: center;
gap: 0.75rem;
width: 100%;
flex-shrink: 0;
padding-top: 0.5rem;
}
.game-info-display {
display: flex;
justify-content: center;
flex-wrap: wrap;
gap: 1.5rem;
width: 100%;
text-align: center;
color: var(--text-main);
text-shadow: none;
font-size: clamp(0.9rem, 2.5vw, 1rem);
padding: 0.75rem 1.25rem;
background: var(--panel-bg, linear-gradient(160deg, rgba(0,0,0,0.4), rgba(0,0,0,0.7)));
border: 1px solid var(--panel-border, rgba(240, 200, 80, 0.5));
border-radius: 12px;
box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
}
.game-info-display span:empty {
display: none;
}
.game-info-display strong {
color: var(--text-gold);
margin-right: 8px;
}
.cell {
width: 100%;
height: 100%;
display: flex;
align-items: center;
justify-content: center;
position: relative;
cursor: pointer;
aspect-ratio: 1 / 1;
z-index: 2;
background: transparent;
transition: all 0.2s ease-out;
border: 1px solid var(--cell-border, rgba(0,0,0,0.18));
box-shadow: inset 1px 1px 5px rgba(255,255,255,0.5), inset -1px -1px 5px rgba(0,0,0,0.4);
}
.status {
padding: 0.75rem;
font-size: clamp(1rem, 3vw, 1.2rem);
min-height: 50px;
text-align: center;
background: var(--panel-bg, rgba(0,0,0,0.5));
border-radius: 12px;
border: min(0.4vw, 2px) solid var(--panel-border, rgba(240, 200, 80, 0.6));
box-shadow: inset 0 0 min(3vw, 15px) rgba(0,0,0,0.5), 0 5px 15px rgba(0,0,0,0.4);
text-shadow: none;
width: 100%;
transition: all var(--transition-duration) ease;
backdrop-filter: blur(2px);
display: flex;
align-items: center;
justify-content: center;
}
.player-info.player1-info {
border-color: #333;
}
.player-info.player2-info {
border-color: #ccc;
}

.player-info.active-player {
transform: scale(1.05);
border-color: var(--text-gold) !important;
background: rgba(240, 200, 80, 0.15);
box-shadow: 0 0 25px rgba(240, 200, 80, 0.8), inset 0 0 15px rgba(240, 200, 80, 0.5);
}

.controls button {
padding: 0.7rem 1.2rem;
border-radius: 35px;
background: linear-gradient(145deg, var(--wood-light), var(--wood-medium));
color: var(--text-light);
font-family: var(--font-ui);
font-weight: bold;
cursor: pointer;
font-size: clamp(0.8rem, 2.5vw, 0.9rem);
transition: all 0.3s ease;
box-shadow: 0 6px 10px rgba(0,0,0,0.5);
width: auto;
max-width: 200px;
border: 1px solid var(--wood-dark);
text-shadow: none;
letter-spacing: 0.4px;
text-transform: none;
display: flex;
align-items: center;
justify-content: center;
gap: 8px;
flex-grow: 1;
flex-basis: 120px;
}
.controls button:not([disabled]):hover {
transform: translateY(-5px);
box-shadow: 0 9px 18px rgba(0,0,0,0.6);
}
.controls button:not([disabled]):active {
transform: translateY(2px);
box-shadow: 0 3px 7px rgba(0,0,0,0.4);
}
.controls button:hover {
background: linear-gradient(145deg, var(--wood-light), var(--wood-medium), var(--text-gold));
}
.controls button.surrender-btn {
background: linear-gradient(145deg, #8B0000, #B22222);
border-color: #6e0000;
}
.controls button.surrender-btn:hover {
background: linear-gradient(145deg, #B22222, #DC143C);
}
#undo-btn {
background: linear-gradient(145deg, #465569, #2c3e50);
border-color: #1a2531;
}
#undo-btn:not([disabled]):hover {
background: linear-gradient(145deg, #5a6d84, #34495e, var(--info-blue));
}
.controls button:disabled {
cursor: not-allowed;
filter: grayscale(80%);
opacity: 0.6;
}
.modal-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.85);
display: none;
justify-content: center;
align-items: center;
z-index: 1010;
backdrop-filter: blur(5px);
padding: 1.25rem;
}
.modal-overlay.active {
display: flex;
}
.modal-content {
background: linear-gradient(160deg, #3a2d25, #2a201a);
border: 2px solid var(--text-gold);
border-radius: 15px;
padding: 2rem;
max-width: 500px;
width: 100%;
position: relative;
box-shadow: 0 10px 40px rgba(0,0,0,0.6);
text-align: center;
}
.modal-content h3 {
font-family: var(--font-title);
color: var(--text-gold);
margin-bottom: 1.25rem;
font-size: 1.5rem;
}
.modal-content p {
margin-bottom: 1.5rem;
line-height: 1.6;
font-size: 1rem;
}
.modal-actions {
display: flex;
justify-content: center;
gap: 1.25rem;
}
.modal-actions button {
padding: 0.75rem 2rem;
border-radius: 25px;
font-family: var(--font-body);
cursor: pointer;
transition: all 0.3s ease;
font-size: 1rem;
box-shadow: 0 4px 10px rgba(0,0,0,0.4);
border: none;
}
.modal-confirm-btn {
background: var(--danger-red);
color: var(--text-light);
}
.modal-confirm-btn:hover {
background: #ff6666;
transform: translateY(-3px);
}
.modal-cancel-btn {
background: var(--stone-medium);
color: var(--text-light);
}
.modal-cancel-btn:hover {
background: var(--stone-light);
color: var(--stone-dark);
transform: translateY(-3px);
}
.rules-modal-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.8);
display: none;
justify-content: center;
align-items: center;
z-index: 1300;
backdrop-filter: blur(5px);
padding: 1rem;
}
.rules-modal-overlay.active {
display: flex;
}
.rules-book {
background: var(--parchment-bg);
color: var(--wood-dark);
border: clamp(5px, 2vw, 15px) solid var(--wood-dark);
border-radius: 9px;
padding: clamp(0.8rem, 3vw, 2rem) clamp(0.8rem, 4vw, 2.5rem);
max-width: 800px;
width: 100%;
max-height: min(90vh, 90dvh);
overflow-y: auto;
position: relative;
box-shadow: inset 0 0 20px rgba(0,0,0,0.5), 0 10px 40px rgba(0,0,0,0.7);
opacity: 0;
transform: scale(0.8);
transition: opacity 0.4s ease, transform 0.4s ease;
}
.rules-modal-overlay.active .rules-book {
opacity: 1;
transform: scale(1);
}
.rules-book h3 {
font-family: var(--font-title);
color: var(--wood-dark);
text-align: center;
font-size: clamp(1.5rem, 4vw, 2rem);
margin-bottom: 1.25rem;
border-bottom: 2px solid rgba(90, 52, 31, 0.3);
padding-bottom: 0.75rem;
}
.rules-book h4 {
font-family: var(--font-title);
color: var(--wood-medium);
margin-top: 1.25rem;
margin-bottom: 0.75rem;
font-size: clamp(1.1rem, 3vw, 1.3rem);
border-bottom: 1px solid rgba(90, 52, 31, 0.2);
padding-bottom: 5px;
}
.rules-book p, .rules-book li {
line-height: 1.7;
margin-bottom: 0.8rem;
font-size: clamp(0.95rem, 2.5vw, 1rem);
}
.rules-book ul {
list-style-type: none;
padding-left: 0;
}
.rules-book li {
position: relative;
padding-left: 1.5rem;
}
.rules-book li::before {
content: '•';
position: absolute;
left: 5px;
color: var(--wood-medium);
font-weight: bold;
}
.rules-book strong {
color: var(--danger-red);
font-weight: bold;
}
.rules-book .rules-section p:first-of-type {
margin-top: 5px;
}
.rules-close-btn {
position: absolute;
top: 10px;
right: 15px;
background: none;
border: none;
font-size: 2rem;
color: var(--wood-dark);
cursor: pointer;
transition: transform 0.3s ease, color 0.3s ease;
}
.rules-close-btn:hover {
transform: scale(1.2);
color: var(--danger-red);
}
.rules-content {
display: none;
}
.dark-cell {
background: rgba(0,0,0,0.1);
}
.cell:hover {
background: rgba(255,255,255,0.2);
transform: scale(1.03);
z-index: 3;
box-shadow: inset 0 0 15px rgba(255,255,255,0.6), inset 0 0 15px rgba(0,0,0,0.5), 0 0 10px rgba(240, 200, 80, 0.3);
}
.stone {
width: 65%;
height: 65%;
position: relative;
z-index: 2;
transition: all 0.3s ease;
border-radius: 50%;
box-shadow: 0 5px 12px rgba(0,0,0,0.5), inset 0 -5px 12px rgba(0,0,0,0.4), inset 0 5px 10px rgba(255,255,255,0.3);
}
.cell.selected {
z-index: 4;
animation: pulse 1.5s infinite;
}
.cell.possible-move {
background: rgba(255, 215, 0, 0.2);
outline: min(0.4vw, 2px) dashed var(--text-gold);
box-shadow: inset 0 0 12px rgba(255, 215, 0, 0.4);
}
.cell.possible-move:hover {
background: rgba(255, 215, 0, 0.4);
}
@keyframes pulse {
0% {
box-shadow: inset 2px 2px 10px rgba(255,255,255,0.5), inset -2px -2px 10px rgba(0,0,0,0.4), 0 0 0 0 rgba(255, 215, 0, 0.5);
}
70% {
box-shadow: inset 2px 2px 10px rgba(255,255,255,0.5), inset -2px -2px 10px rgba(0,0,0,0.4), 0 0 0 min(3vw, 15px) rgba(255, 215, 0, 0);
}
100% {
box-shadow: inset 2px 2px 10px rgba(255,255,255,0.5), inset -2px -2px 10px rgba(0,0,0,0.4), 0 0 0 0 rgba(255, 215, 0, 0);
}
}
.cell.capturable {
background: rgba(255, 0, 0, 0.25);
outline: min(0.6vw, 3px) dashed var(--danger-red);
animation: capturable-pulse 2s infinite;
}
@keyframes capturable-pulse {
0% {
outline-color: var(--danger-red);
}
50% {
outline-color: rgba(255, 0, 0, 0.5);
}
100% {
outline-color: var(--danger-red);
}
}
.cell.mill-highlight {
background: rgba(0, 255, 255, 0.2);
outline: min(0.6vw, 3px) solid var(--highlight-cyan);
animation: mill-pulse 1.5s infinite;
}
@keyframes mill-pulse {
0% {
outline-color: var(--highlight-cyan);
}
50% {
outline-color: rgba(0, 255, 255, 0.5);
}
100% {
outline-color: var(--highlight-cyan);
}
}
.stone::after {
content: "";
position: absolute;
top: 15%;
left: 15%;
width: 30%;
height: 20%;
background: rgba(255,255,255,0.5);
border-radius: 50%;
transform: rotate(-20deg);
z-index: 3;
filter: blur(2px);
}
.stone.player1 {
background: radial-gradient(circle at 35% 35%, var(--player1-stone-color-light), var(--player1-stone-color-dark) 60%, #000 90%);
}
.stone.player2 {
background: radial-gradient(circle at 35% 35%, var(--player2-stone-color-light), var(--player2-stone-color-dark) 60%, #e0e0e0 90%);
}
.stone.selected {
transform: scale(1.25);
animation: stone-pulse 1.5s infinite;
filter: brightness(1.1);
}
@keyframes stone-pulse {
0% {
box-shadow: 0 0 0 0 rgba(240, 200, 80, 0.7), 0 min(2.8vw, 14px) min(7vw, 35px) rgba(0,0,0,0.8), inset 0 min(-1.8vw, -9px) min(4.5vw, 22px) rgba(0,0,0,0.4);
}
70% {
box-shadow: 0 0 0 min(3.5vw, 18px) rgba(240, 200, 80, 0), 0 min(2.8vw, 14px) min(7vw, 35px) rgba(0,0,0,0.8), inset 0 min(-1.8vw, -9px) min(4.5vw, 22px) rgba(0,0,0,0.4);
}
100% {
box-shadow: 0 0 0 0 rgba(240, 200, 80, 0), 0 min(2.8vw, 14px) min(7vw, 35px) rgba(0,0,0,0.8), inset 0 min(-1.8vw, -9px) min(4.5vw, 22px) rgba(0,0,0,0.4);
}
}
.stone.moving {
animation: placeStone 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
}
@keyframes placeStone {
0% {
opacity: 0;
transform: scale(0.2) translateY(-50px);
}
70% {
opacity: 1;
transform: scale(1.1) translateY(5px);
}
100% {
opacity: 1;
transform: scale(1) translateY(0);
}
}
.stone.captured, .stone.fade-out {
animation: fadeOutStone 0.5s ease-in forwards;
}
@keyframes fadeOutStone {
to {
transform: scale(0.3) rotate(30deg);
opacity: 0;
filter: blur(5px);
}
}
.status.status-error {
background-color: rgba(255, 0, 0, 0.6);
border-color: var(--danger-red);
animation: shake 0.5s ease-in-out;
}
@keyframes shake {
0%, 100% {
transform: translateX(0);
}
25% {
transform: translateX(-5px);
}
50% {
transform: translateX(5px);
}
75% {
transform: translateX(-5px);
}
}
footer {
text-align: center;
padding: 0.75rem 0 0.5rem;
color: var(--text-gold);
font-size: clamp(0.78rem, 2vw, 0.88rem);
opacity: 0.85;
width: 100%;
display: flex;
flex-direction: column;
align-items: center;
gap: 3px;
text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
flex-shrink: 0;
border-top: 1px solid rgba(240,200,80,0.12);
}
footer::before {
content: 'ⵣ ⵎ ⵣ';
font-size: 0.95rem;
letter-spacing: 8px;
opacity: 0.35;
}

/* ─────────────────────────────────────────────
           BOUTONS ACCUEIL (règles + à propos) en ligne
        ───────────────────────────────────────────── */
.version-btns-row {
display: flex;
gap: .75rem;
flex-wrap: wrap;
justify-content: center;
}
.about-btn {
margin-left: 0;
}

/* ─────────────────────────────────────────────
           MODALE À PROPOS
        ───────────────────────────────────────────── */
@keyframes aboutBookIn {
from {
opacity: 0;
transform: translateY(36px) scale(.94);
}
to {
opacity: 1;
transform: translateY(0)    scale(1);
}
}
@keyframes aboutGemPulse {
0%,100% {
opacity: .5;
transform: rotate(45deg) scale(1);
}
50% {
opacity: 1;
transform: rotate(45deg) scale(1.35);
}
}

.about-modal-overlay {
position: fixed;
inset: 0;
background: rgba(0,0,0,.82);
display: none;
justify-content: center;
align-items: center;
z-index: 1300;
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
padding: 1rem;
}
.about-modal-overlay.active {
display: flex;
}

.about-book {
position: relative;
background:
linear-gradient(160deg, rgba(255,255,255,.03) 0%, transparent 50%),
radial-gradient(ellipse at 50% 0%, rgba(240,200,80,.06), transparent 65%),
#1c140a;
border: 1.5px solid rgba(240,200,80,.28);
border-radius: 20px;
padding: clamp(1.5rem, 4vw, 2.8rem) clamp(1.5rem, 5vw, 3.2rem);
max-width: 660px;
width: 100%;
max-height: min(90vh, 90dvh);
overflow-y: auto;
box-shadow:
0 0 0 1px rgba(255,255,255,.04),
0 0 50px rgba(240,200,80,.18),
0 28px 70px rgba(0,0,0,.75);
opacity: 0;
transform: translateY(36px) scale(.94);
transition: opacity .4s ease, transform .4s ease;
scrollbar-width: thin;
scrollbar-color: rgba(240,200,80,.3) transparent;
}
.about-modal-overlay.active .about-book {
opacity: 1;
transform: translateY(0) scale(1);
}

/* Scrollbar webkit */
.about-book::-webkit-scrollbar {
width: 5px;
}
.about-book::-webkit-scrollbar-track {
background: transparent;
}
.about-book::-webkit-scrollbar-thumb {
background: rgba(240,200,80,.3);
border-radius: 99px;
}

/* Bouton fermer */
.about-close-btn {
position: absolute;
top: 14px;
right: 16px;
background: none;
border: none;
cursor: pointer;
color: rgba(240,200,80,.55);
line-height: 1;
padding: 4px;
border-radius: 6px;
transition: color .2s, background .2s;
display: flex;
align-items: center;
}
.about-close-btn svg {
stroke: currentColor;
fill: none;
stroke-width: 2.2;
stroke-linecap: round;
stroke-linejoin: round;
}
.about-close-btn:hover {
color: var(--danger-red, #ff4d4d);
background: rgba(255,60,60,.08);
}

/* En-tête */
.about-header {
text-align: center;
margin-bottom: 1.6rem;
}
.about-tifinagh {
font-size: clamp(1.6rem, 5vw, 2.4rem);
letter-spacing: .25em;
color: rgba(240,200,80,.35);
margin-bottom: .4rem;
font-weight: 300;
}
.about-title {
font-family: var(--font-title);
font-size: clamp(1.25rem, 4vw, 1.75rem);
font-weight: 800;
color: var(--text-gold, #f0c850);
letter-spacing: -.01em;
margin: 0 0 .9rem;
text-shadow: 0 0 18px rgba(240,200,80,.35);
}
.about-sep {
display: flex;
align-items: center;
gap: 10px;
width: 60%;
margin: 0 auto;
}
.about-sep span {
flex: 1;
height: 1px;
background: linear-gradient(90deg, transparent, rgba(240,200,80,.35), transparent);
}
.about-gem {
font-size: .55rem;
color: var(--text-gold, #f0c850);
animation: aboutGemPulse 2.8s ease-in-out infinite;
transform-origin: center;
}

/* Corps */
.about-body {
color: rgba(245,235,210,.82);
font-size: clamp(.9rem, 2.2vw, 1rem);
line-height: 1.78;
display: flex;
flex-direction: column;
gap: 1rem;
}
.about-body p {
margin: 0;
}
.about-intro {
font-size: clamp(.95rem, 2.4vw, 1.08rem) !important;
color: rgba(245,235,210,.92) !important;
}
.about-body strong {
color: var(--text-gold, #f0c850);
font-weight: 700;
}
.about-body em {
color: #e8c87a;
font-style: italic;
}

/* Ligne séparatrice fine */
.about-rule-line {
height: 1px;
background: linear-gradient(90deg, transparent, rgba(240,200,80,.22), transparent);
margin: .3rem 0;
}

/* Cartes variantes */
.about-variants {
display: flex;
gap: 10px;
flex-wrap: wrap;
}
.about-variant-card {
flex: 1;
min-width: 190px;
display: flex;
align-items: center;
gap: 12px;
background: rgba(240,200,80,.06);
border: 1px solid rgba(240,200,80,.2);
border-radius: 12px;
padding: .85rem 1rem;
}
.about-variant-icon {
font-size: 1.5rem;
line-height: 1;
flex-shrink: 0;
}
.about-variant-card strong {
display: block;
font-size: .95rem;
margin-bottom: .2rem;
}
.about-variant-card span {
font-size: .82rem;
color: rgba(245,235,210,.65);
line-height: 1.4;
}

/* Citation */
.about-quote {
position: relative;
background: rgba(240,200,80,.06);
border-left: 3px solid rgba(240,200,80,.5);
border-radius: 0 10px 10px 0;
padding: 1rem 1.2rem 1rem 1.5rem;
margin: .4rem 0;
}
.about-quote-mark {
position: absolute;
top: -6px;
left: 10px;
font-size: 2rem;
color: rgba(240,200,80,.25);
line-height: 1;
font-family: Georgia, serif;
}
.about-quote blockquote {
margin: 0 0 .4rem;
font-size: clamp(1rem, 2.5vw, 1.12rem);
font-weight: 700;
color: var(--text-gold, #f0c850);
font-style: italic;
font-family: var(--font-title);
letter-spacing: .01em;
text-shadow: 0 0 14px rgba(240,200,80,.3);
}
.about-quote cite {
font-size: .82rem;
color: rgba(245,235,210,.6);
font-style: normal;
}

/* Pied de la modale */
.about-footer {
margin-top: 1.8rem;
padding-top: 1rem;
border-top: 1px solid rgba(240,200,80,.12);
text-align: center;
display: flex;
flex-direction: column;
align-items: center;
gap: .45rem;
}
.about-tifinagh-small {
font-size: .9rem;
letter-spacing: 10px;
color: rgba(240,200,80,.25);
}
.about-author {
display: flex;
align-items: center;
gap: 6px;
font-size: .9rem;
color: rgba(245,235,210,.75);
}
.about-author-icon {
stroke: rgba(240,200,80,.6);
fill: none;
stroke-width: 1.8;
stroke-linecap: round;
stroke-linejoin: round;
flex-shrink: 0;
}
.about-author strong {
color: var(--text-gold, #f0c850);
}
.about-heritage {
font-size: .75rem;
color: rgba(245,235,210,.35);
letter-spacing: .06em;
}

/* Responsive */
@media (max-width: 480px) {
.about-book {
padding: 1.2rem 1.1rem 1.4rem;
}
.about-variants {
flex-direction: column;
}
}
/* ═══════════════════════════════════════
           WINNER OVERLAY — redesign complet
        ═══════════════════════════════════════ */
@keyframes winnerFadeIn {
from {
opacity: 0
}

to {
opacity: 1
}
}
@keyframes woCardUp {
from {
opacity: 0;
transform: translateY(48px) scale(.94)
}

to {
opacity: 1;
transform: translateY(0) scale(1)
}
}
@keyframes woTrophyPop {
0% {
opacity: 0;
transform: scale(.3) rotate(-15deg)
}

70% {
transform: scale(1.2) rotate(4deg)
}

100% {
opacity: 1;
transform: scale(1) rotate(0)
}
}
@keyframes woLabelIn {
from {
opacity: 0;
transform: translateY(-14px)
}

to {
opacity: 1;
transform: translateY(0)
}
}
@keyframes woSubIn {
from {
opacity: 0;
transform: translateX(20px)
}

to {
opacity: 1;
transform: translateX(0)
}
}
@keyframes woNamePop {
from {
opacity: 0;
transform: scale(.6)
}

to {
opacity: 1;
transform: scale(1)
}
}
@keyframes woDivExpand {
from {
opacity: 0;
transform: scaleX(0)
}

to {
opacity: 1;
transform: scaleX(1)
}
}
@keyframes woActionsIn {
from {
opacity: 0;
transform: translateY(20px)
}

to {
opacity: 1;
transform: translateY(0)
}
}
@keyframes woPulseRing {
0%,100% {
transform: scale(1);
opacity: .5
}

50% {
transform: scale(1.35);
opacity: 0
}
}
@keyframes woGemSpin {
from {
transform: rotate(0deg) scale(1)
}

50% {
transform: rotate(180deg) scale(1.4)
}

to {
transform: rotate(360deg) scale(1)
}
}
@keyframes woParticle {
0% {
transform: translateY(0) rotate(0deg);
opacity: .8
}

100% {
transform: translateY(-105vh) rotate(540deg);
opacity: 0
}
}
@keyframes woShake {
0%,100% {
transform: translateX(0)
}

20% {
transform: translateX(-8px) rotate(-2deg)
}

40% {
transform: translateX(8px) rotate(2deg)
}

60% {
transform: translateX(-5px)
}

80% {
transform: translateX(5px)
}
}
@keyframes slideInUp {
from {
transform: translateY(50px);
opacity: 0
}

to {
transform: translateY(0);
opacity: 1
}
}
@keyframes zoomIn {
from {
transform: scale(.5);
opacity: 0
}

to {
transform: scale(1);
opacity: 1
}
}
@keyframes fadeIn {
from {
opacity: 0
}

to {
opacity: 1
}
}

.winner-overlay {
position: fixed;
inset: 0;
z-index: 1001;
display: flex;
align-items: center;
justify-content: center;
opacity: 0;
pointer-events: none;
transition: opacity .4s ease;
/* Tokens par défaut : VICTOIRE */
--woa: #f0c850;
/* accent principal */
--woa2: #e88c30;
/* accent secondaire */
--wog: rgba(240,200,80,.5);
/* glow */
--wobg1: rgba(22,14,5,.97);
--wobg2: rgba(44,25,8,.93);
--wocb: rgba(240,200,80,.3);
/* card border */
--wosub: #e8c87a;
--wotxt: rgba(255,248,220,.85);
}
.winner-overlay.active {
opacity: 1;
pointer-events: all;
animation: winnerFadeIn .45s ease-out forwards;
}
/* État DÉFAITE */
.winner-overlay.wo-defeat {
--woa: #6ab0ff;
--woa2: #3a6ec8;
--wog: rgba(80,140,255,.45);
--wobg1: rgba(4,8,22,.97);
--wobg2: rgba(8,14,38,.93);
--wocb: rgba(80,140,255,.3);
--wosub: #8ab8ff;
--wotxt: rgba(190,210,255,.85);
}

/* Fond radial */
.wo-bg {
position: absolute;
inset: 0;
background: radial-gradient(ellipse at 50% 38%, var(--wobg1) 0%, var(--wobg2) 100%);
backdrop-filter: blur(14px);
-webkit-backdrop-filter: blur(14px);
}

/* Particules */
.wo-particles {
position: absolute;
inset: 0;
overflow: hidden;
pointer-events: none;
}
.wo-particles .p {
position: absolute;
border-radius: 50%;
animation: woParticle linear infinite;
}

/* Carte centrale */
.wo-card {
position: relative;
z-index: 2;
display: flex;
flex-direction: column;
align-items: center;
gap: clamp(.9rem, 2.2vh, 1.4rem);
padding: clamp(2rem, 5vw, 3.2rem) clamp(2rem, 7vw, 4.5rem);
background: linear-gradient(160deg, rgba(255,255,255,.04) 0%, rgba(0,0,0,.0) 100%), var(--wobg1);
border: 1.5px solid var(--wocb);
border-radius: 26px;
box-shadow:
0 0 0 1px rgba(255,255,255,.04),
0 0 55px var(--wog),
0 28px 70px rgba(0,0,0,.75),
inset 0 1px 0 rgba(255,255,255,.07);
max-width: min(500px, 88vw);
width: 100%;
opacity: 0;
animation: woCardUp .65s cubic-bezier(.22,1,.36,1) .2s forwards;
}

/* Trophée / icône */
.wo-trophy {
font-size: clamp(3rem, 9vw, 4.5rem);
line-height: 1;
filter: drop-shadow(0 0 18px var(--wog));
opacity: 0;
animation: woTrophyPop .65s cubic-bezier(.34,1.56,.64,1) .65s forwards;
position: relative;
}
.wo-trophy::before,
.wo-trophy::after {
content: '';
position: absolute;
inset: -8px;
border-radius: 50%;
border: 1.5px solid var(--wog);
}
.wo-trophy::before {
animation: woPulseRing 2.4s ease-out 1.3s infinite;
}
.wo-trophy::after {
animation: woPulseRing 2.4s ease-out 1.8s infinite;
}

/* Zone résultat */
.wo-result {
display: flex;
flex-direction: column;
align-items: center;
gap: .25rem;
}
.winner-overlay .winner-message {
font-family: var(--font-title);
font-size: clamp(.8rem, 2.2vw, 1rem);
font-weight: 700;
letter-spacing: .18em;
text-transform: uppercase;
color: var(--wotxt);
opacity: 0;
animation: woLabelIn .5s ease-out 1.1s forwards;
text-shadow: none;
margin: 0;
}
.wo-result-sub {
font-family: var(--font-title);
font-size: clamp(.65rem, 1.8vw, .82rem);
font-weight: 500;
letter-spacing: .12em;
text-transform: uppercase;
color: var(--woa);
opacity: 0;
animation: woSubIn .5s ease-out 1.35s forwards;
}

/* Nom du gagnant */
.winner-overlay .winner-name {
font-family: var(--font-title);
font-size: clamp(1.7rem, 7vw, 3.2rem) !important;
font-weight: 900 !important;
color: var(--woa);
text-align: center;
line-height: 1.15;
text-shadow: 0 0 22px var(--wog), 0 4px 10px rgba(0,0,0,.65) !important;
letter-spacing: -.01em;
opacity: 0;
animation: woNamePop .65s cubic-bezier(.34,1.56,.64,1) 1.5s forwards;
}

/* Séparateur */
.wo-divider {
display: flex;
align-items: center;
gap: 10px;
width: 78%;
opacity: 0;
animation: woDivExpand .45s ease-out 1.9s forwards;
}
.wo-divider span {
flex: 1;
height: 1px;
background: linear-gradient(90deg, transparent, var(--wocb), transparent);
}
.wo-gem {
width: 7px;
height: 7px;
background: var(--woa);
transform: rotate(45deg);
box-shadow: 0 0 7px var(--wog);
animation: woGemSpin 3s ease-in-out 2.1s infinite;
flex-shrink: 0;
}

/* Boutons */
.wo-actions {
display: flex;
flex-direction: column;
align-items: center;
gap: 10px;
width: 100%;
opacity: 0;
animation: woActionsIn .55s ease-out 2.1s forwards;
}
.wo-row {
  display: flex;
  flex-wrap: wrap;
gap: 8px;
width: 100%;
justify-content: center;
}
.winner-overlay .replay-button {
border: none;
cursor: pointer;
font-family: var(--font-title);
font-weight: 700;
border-radius: 13px;
transition: transform .2s ease, box-shadow .2s ease, filter .2s ease;
position: relative;
overflow: hidden;
text-shadow: none;
}
.winner-overlay .replay-button:not(.secondary) {
width: 100%;
padding: .95rem 1.5rem;
font-size: clamp(.95rem, 3.2vw, 1.2rem) !important;
background: linear-gradient(135deg, var(--woa), var(--woa2));
color: #1a0e04;
box-shadow: 0 5px 22px var(--wog), 0 2px 8px rgba(0,0,0,.4);
letter-spacing: .03em;
opacity: 1;
animation: none;
}
.winner-overlay .replay-button:not(.secondary)::after {
content: '';
position: absolute;
inset: 0;
background: linear-gradient(135deg, rgba(255,255,255,.18), transparent 60%);
pointer-events: none;
}
.winner-overlay .replay-button:not(.secondary):hover {
transform: translateY(-3px) scale(1.02);
box-shadow: 0 10px 30px var(--wog), 0 4px 12px rgba(0,0,0,.5);
filter: brightness(1.08);
}
.winner-overlay .replay-button.secondary {
flex: 1;
padding: .7rem 1rem;
font-size: clamp(.78rem, 2.2vw, .92rem) !important;
background: rgba(255,255,255,.06);
color: var(--wotxt);
border: 1px solid var(--wocb) !important;
box-shadow: 0 2px 8px rgba(0,0,0,.3);
opacity: 1;
animation: none;
}
.winner-overlay .replay-button.secondary:hover:not(:disabled) {
transform: translateY(-2px);
background: rgba(255,255,255,.1);
border-color: var(--woa) !important;
color: var(--woa);
}
.winner-overlay .replay-button.secondary:disabled {
opacity: .32 !important;
cursor: not-allowed;
}
/* Défaite : animation shake sur la carte */
.winner-overlay.wo-defeat .wo-card {
animation: woCardUp .65s cubic-bezier(.22,1,.36,1) .2s forwards, woShake .6s ease-out .9s 1;
}
/* ─── Ghost référence JS (ne recouvre rien, invisible) ─── */
#ephemeral-message-bubble {
display: none !important;
}

/* ─── Badge joueur : message éphémère IN-CARD ─── */
.player-badge {
/* Slot fermé → 0 espace quand vide */
width: 100%;
max-height: 0;
overflow: hidden;
opacity: 0;
margin-top: 0;
pointer-events: none;
display: flex;
align-items: center;
justify-content: center;
gap: 6px;
/* Transitions fluides */
transition:
  max-height 0.35s cubic-bezier(0.34, 1.56, 0.64, 1),
  opacity 0.25s ease,
  margin-top 0.25s ease;
}

/* Pastille intérieure via pseudo-element pour chaque variante */
.player-badge .badge-pill {
display: inline-flex;
align-items: center;
gap: 6px;
padding: 0.3rem 0.9rem;
border-radius: 50px;
font-size: clamp(0.76rem, 2.2vw, 0.88rem);
font-weight: 800;
letter-spacing: 0.08em;
white-space: nowrap;
/* Frosted glass — pas de fond opaque */
background: rgba(255, 255, 255, 0.10);
border: 1px solid rgba(240, 200, 80, 0.40);
color: var(--text-gold, #f0c850);
backdrop-filter: blur(12px) saturate(1.4);
-webkit-backdrop-filter: blur(12px) saturate(1.4);
box-shadow:
  0 1px 6px rgba(0,0,0,0.18),
  inset 0 1px 0 rgba(255,255,255,0.12);
text-shadow: 0 0 8px rgba(240,200,80,0.4);
}

.player-badge.active {
max-height: 38px;
opacity: 1;
margin-top: 0.45rem;
animation: badgeIn 0.36s cubic-bezier(0.34, 1.56, 0.64, 1) both;
}

@keyframes badgeIn {
0%   { opacity:0; transform: scaleX(0.5) scaleY(0.3) translateY(-4px); }
60%  { transform: scaleX(1.04) scaleY(1.06) translateY(0); }
100% { opacity:1; transform: scaleX(1) scaleY(1) translateY(0); }
}

/* Variante mill : teinte cyan */
.player-badge.badge-mill .badge-pill {
border-color: rgba(0, 220, 200, 0.50);
color: #00dcc8;
background: rgba(0, 220, 200, 0.08);
text-shadow: 0 0 8px rgba(0,220,200,0.5);
}

/* Variante capture : teinte or chaud */
.player-badge.badge-capture .badge-pill {
border-color: rgba(255, 180, 0, 0.50);
color: #ffcc44;
background: rgba(255, 180, 0, 0.08);
text-shadow: 0 0 8px rgba(255,180,0,0.45);
}

/* Variante sacrifiée (bessif) : teinte rouge doux */
.player-badge.badge-sacrifice .badge-pill {
border-color: rgba(255, 100, 100, 0.45);
color: #ff8888;
background: rgba(255, 80, 80, 0.07);
text-shadow: 0 0 8px rgba(255,80,80,0.4);
}

/* Variante phase : teinte bleue */
.player-badge.badge-phase .badge-pill {
border-color: rgba(100, 160, 255, 0.45);
color: #88b8ff;
background: rgba(100, 160, 255, 0.07);
text-shadow: 0 0 8px rgba(100,160,255,0.4);
}

/* Thème kabylie/desert : texte plus sombre sur fond clair */
[data-theme="kabylie"] .player-badge .badge-pill,
[data-theme="desert"]  .player-badge .badge-pill {
background: rgba(0, 0, 0, 0.07);
color: var(--stone-dark, #2c2722);
border-color: rgba(90, 52, 31, 0.38);
text-shadow: none;
box-shadow: 0 1px 6px rgba(0,0,0,0.10), inset 0 1px 0 rgba(255,255,255,0.35);
}
[data-theme="kabylie"] .player-badge.badge-mill .badge-pill,
[data-theme="desert"]  .player-badge.badge-mill .badge-pill {
color: #00695c; border-color: rgba(0,105,92,0.4);
}
[data-theme="kabylie"] .player-badge.badge-capture .badge-pill,
[data-theme="desert"]  .player-badge.badge-capture .badge-pill {
color: #b8860b; border-color: rgba(184,134,11,0.4);
}
[data-theme="kabylie"] .player-badge.badge-sacrifice .badge-pill,
[data-theme="desert"]  .player-badge.badge-sacrifice .badge-pill {
color: #c0392b; border-color: rgba(192,57,43,0.4);
}



/* ============================================================
   Online lobby — CSS fusionné (voir bloc principal ci-dessous)
   ============================================================ */

/* ==================== ACCESSIBILITY TWEAKS ==================== */
@media (prefers-reduced-motion: reduce) {
*, *::before, *::after {
animation-duration: 0.01ms !important;
animation-iteration-count: 1 !important;
transition-duration: 0.01ms !important;
scroll-behavior: auto !important;
}
}
@media (prefers-contrast: more) {
:root {
--panel-bg: rgba(0,0,0,0.65);
--panel-border: rgba(240,200,80,0.55);
--cell-border: rgba(240,200,80,0.55);
}
[data-theme="kabylie"] {
--panel-bg: rgba(255,255,255,0.98);
--panel-border: rgba(31,26,18,0.35);
--cell-border: rgba(31,26,18,0.45);
}
.selection-area, .version-card, .difficulty-card, .mode-card, .option-btn,
.player-info, .status, .game-info-display, .move-history-panel {
backdrop-filter: none !important;
-webkit-backdrop-filter: none !important;
}
}

/* ==================== THEMES ==================== */

/* Kabylie-inspired bright theme (default) */
[data-theme="kabylie"] {
--kab-blue: #1e88e5;
--kab-green: #2e7d32;
--kab-yellow: #fdd835;
--kab-red: #d32f2f;

--text-main: #1f1a12;
--text-muted: #4a3f33;
--text-light: #ffffff;
--text-gold: #9c6b00;

--stone-dark: #2b2a28;
--stone-medium: #6f6458;
--stone-light: #f2eadf;

--wood-dark: #8a5a2b;
--wood-medium: #b37634;
--wood-light: #d7a25a;

--board-border-dark: rgba(47,42,37,0.55);
--board-surface-light: rgba(255,250,240,0.92);
--parchment-bg: rgba(255,255,255,0.92);

--cell-border: rgba(47,42,37,0.30);
--highlight-cyan: rgba(30,136,229,0.95);
--danger-red: #c62828;

--bg-start: #fff3bf;
--bg-end: #d7f3ff;

--panel-bg: rgba(255,255,255,0.88);
--panel-border: rgba(31,26,18,0.18);
}
[data-theme="kabylie"] body {
background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
color: var(--text-main);
/* Subtle Amazigh-inspired pattern */
background-image:
url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="140" height="140" viewBox="0 0 140 140"><rect width="140" height="140" fill="none"/><path d="M0 70h140M70 0v140" stroke="%231e88e5" stroke-width="2" opacity="0.05"/><path d="M20 20l30 30M90 90l30 30M120 20l-30 30M50 90l-30 30" stroke="%232e7d32" stroke-width="2" opacity="0.05"/><text x="70" y="78" text-anchor="middle" font-size="32" fill="%23d32f2f" opacity="0.06">ⵣ</text></svg>'),
radial-gradient(circle at 15% 20%, rgba(253,216,53,0.35), rgba(253,216,53,0) 55%),
radial-gradient(circle at 85% 70%, rgba(30,136,229,0.25), rgba(30,136,229,0) 60%);
background-size: 140px 140px, auto, auto;
}
[data-theme="kabylie"] header h1 {
color: var(--kab-red);
text-shadow: 0 2px 0 rgba(255,255,255,0.55), 0 8px 18px rgba(0,0,0,0.12);
}
[data-theme="kabylie"] header h1::after {
color: var(--kab-blue);
}
[data-theme="kabylie"] header::after {
color: var(--kab-red);
}
[data-theme="kabylie"] .stone-decoration {
color: rgba(210,47,47,0.18);
text-shadow: none;
}
[data-theme="kabylie"] .selection-area,
[data-theme="kabylie"] .version-card,
[data-theme="kabylie"] .difficulty-card,
[data-theme="kabylie"] .mode-card,
[data-theme="kabylie"] .ai-difficulty-panel,
[data-theme="kabylie"] .rules-modal-content {
background: var(--panel-bg);
border-color: rgba(30,136,229,0.28);
box-shadow: 0 12px 28px rgba(0,0,0,0.12);
color: var(--text-main);
backdrop-filter: blur(8px);
}
[data-theme="kabylie"] .selection-area h2,
[data-theme="kabylie"] .ai-difficulty-panel h2,
[data-theme="kabylie"] .rules-modal-content h2 {
color: var(--kab-blue);
text-shadow: none;
}
[data-theme="kabylie"] .version-card:hover,
[data-theme="kabylie"] .difficulty-card:hover,
[data-theme="kabylie"] .mode-card:hover {
box-shadow: 0 14px 30px rgba(0,0,0,0.14);
border-color: rgba(46,125,50,0.45);
}
[data-theme="kabylie"] .version-card.active,
[data-theme="kabylie"] .difficulty-card.active,
[data-theme="kabylie"] .mode-card.active {
background: linear-gradient(145deg, rgba(253,216,53,0.85), rgba(30,136,229,0.15));
color: var(--text-main);
border-color: rgba(210,47,47,0.45);
}
[data-theme="kabylie"] .toolbar-btn,
[data-theme="kabylie"] .language-selector {
background: rgba(255,255,255,0.86);
border: 1px solid rgba(31,26,18,0.18);
box-shadow: 0 6px 16px rgba(0,0,0,0.10);
color: var(--text-main);
}
[data-theme="kabylie"] .toolbar-btn:hover {
background: rgba(255,255,255,0.95);
border-color: rgba(30,136,229,0.35);
}
[data-theme="kabylie"] .language-selector i {
color: var(--kab-blue);
}
[data-theme="kabylie"] .language-selector select {
color: var(--text-main);
}
[data-theme="kabylie"] .language-selector select option {
background: #ffffff;
color: #1f1a12;
}

[data-theme="kabylie"] .game-info-display {
background: rgba(255,255,255,0.86);
border-color: rgba(46,125,50,0.28);
box-shadow: 0 10px 22px rgba(0,0,0,0.10), inset 0 0 0 rgba(0,0,0,0);
color: var(--text-main);
text-shadow: none;
}
[data-theme="kabylie"] .game-info-display strong {
color: var(--kab-blue);
}
[data-theme="kabylie"] .status {
background: rgba(255,255,255,0.88);
color: var(--text-main);
border-color: rgba(30,136,229,0.32);
box-shadow: 0 10px 22px rgba(0,0,0,0.10);
}
[data-theme="kabylie"] .status.error {
border-color: rgba(198,40,40,0.55);
background: rgba(255,235,238,0.92);
}

[data-theme="kabylie"] .game-board-container {
background: linear-gradient(160deg, rgba(183,118,52,0.65), rgba(215,162,90,0.55));
border-color: rgba(138,90,43,0.55);
box-shadow: 0 14px 34px rgba(0,0,0,0.16), inset 0 0 18px rgba(255,255,255,0.35);
}
[data-theme="kabylie"] .game-board {
background: rgba(255,250,240,0.92);
border-color: rgba(47,42,37,0.55);
}
[data-theme="kabylie"] .cell {
box-shadow: inset 1px 1px 4px rgba(255,255,255,0.55), inset -1px -1px 4px rgba(0,0,0,0.10);
}
[data-theme="kabylie"] .cell.dark-cell {
background: rgba(31,26,18,0.04);
}
[data-theme="kabylie"] .cell.possible-move {
background: rgba(46,125,50,0.14);
outline-color: rgba(46,125,50,0.85);
box-shadow: inset 0 0 12px rgba(46,125,50,0.18);
}
[data-theme="kabylie"] .cell.mill-highlight {
background: rgba(30,136,229,0.14);
outline-color: rgba(30,136,229,0.95);
}

[data-theme="kabylie"] .stone.player1 {
background: radial-gradient(circle at 35% 35%, #444, #1f1a12 60%, #0d0b09 92%);
box-shadow: 0 6px 12px rgba(0,0,0,0.30), inset 0 -6px 12px rgba(0,0,0,0.28), inset 0 5px 10px rgba(255,255,255,0.15);
}
[data-theme="kabylie"] .stone.player2 {
background: radial-gradient(circle at 35% 35%, #ffffff, #e9e4db 60%, #bdb7ad 92%);
box-shadow: 0 6px 12px rgba(0,0,0,0.18), inset 0 -6px 12px rgba(0,0,0,0.12), inset 0 5px 10px rgba(255,255,255,0.65);
}
[data-theme="kabylie"] .stone.selected {
outline-color: rgba(210,47,47,0.85);
}

[data-theme="kabylie"] .move-history-panel {
background: rgba(255,255,255,0.92);
color: var(--text-main);
border-color: rgba(31,26,18,0.22);
box-shadow: 0 4px 12px rgba(0,0,0,0.10);
}
[data-theme="kabylie"] .move-log-entry {
color: var(--text-main);
}
[data-theme="kabylie"] .move-history-title {
color: var(--kab-blue);
opacity: 1;
}
[data-theme="kabylie"] .move-log-entry.mill-entry {
background: rgba(30,136,229,0.10);
border-left-color: var(--kab-blue);
}
[data-theme="kabylie"] .move-log-entry.capture-entry {
background: rgba(198,40,40,0.08);
border-left-color: var(--kab-red);
}

[data-theme="desert"] {
--stone-dark: #3d2a14;
--stone-medium: #7a5a32;
--stone-light: #f3e5c8;
--wood-dark: #7a3a0a;
--wood-medium: #a0561e;
--wood-light: #c87030;
--text-gold: #b87a10;
--board-surface-light: #f6e2b8;
--parchment-bg: #fff8e8;
--board-border-dark: rgba(61,42,20,0.55);
--cell-border: rgba(61,42,20,0.28);

--text-main: #1f1a12;
--text-muted: #4a3f33;
--panel-bg: rgba(255,255,255,0.86);
--panel-border: rgba(31,26,18,0.18);

--bg-start: #fff1d6;
--bg-end: #f2d0a0;
}
[data-theme="desert"] body {
background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
color: var(--text-main, var(--text-light));
}
[data-theme="desert"] .move-history-panel {
background: rgba(255,248,232,0.92);
color: var(--text-main);
border-color: rgba(61,42,20,0.30);
}
[data-theme="desert"] .move-log-entry {
color: var(--text-main);
}
[data-theme="desert"] .move-history-title {
color: var(--text-gold);
opacity: 1;
}
[data-theme="desert"] .move-log-entry.mill-entry {
background: rgba(160,86,30,0.10);
border-left-color: var(--wood-medium);
}
[data-theme="desert"] .move-log-entry.capture-entry {
background: rgba(122,58,10,0.10);
border-left-color: var(--wood-dark);
}
[data-theme="desert"] .status {
background: rgba(255,248,232,0.90);
color: var(--text-main);
border-color: rgba(61,42,20,0.28);
}
[data-theme="desert"] .game-info-display {
background: rgba(255,248,232,0.88);
color: var(--text-main);
border-color: rgba(61,42,20,0.20);
}
[data-theme="desert"] .game-info-display strong {
color: var(--wood-dark);
}
[data-theme="desert"] .player-info {
background: rgba(255,248,232,0.86);
color: var(--text-main);
border-color: rgba(61,42,20,0.22) !important;
}
[data-theme="desert"] .player-title {
color: var(--wood-dark);
text-shadow: none;
}
[data-theme="desert"] .stat-value {
color: var(--wood-medium);
text-shadow: none;
}
[data-theme="desert"] .player-stat i {
color: var(--wood-light);
opacity: 1;
}
[data-theme="desert"] .player-info.active-player {
background: rgba(200,112,48,0.12);
border-color: rgba(200,112,48,0.55) !important;
box-shadow: 0 0 20px rgba(200,112,48,0.25);
}
[data-theme="desert"] .selection-area, [data-theme="desert"] .version-card {
background: rgba(255,248,232,0.90);
border-color: rgba(61,42,20,0.22);
color: var(--text-main);
}
[data-theme="desert"] .version-card h3, [data-theme="desert"] .selection-area h2 {
color: var(--wood-dark);
text-shadow: none;
}
[data-theme="desert"] .version-card p {
color: var(--text-muted);
}
[data-theme="desert"] .option-btn {
background: rgba(255,248,232,0.88);
color: var(--text-main);
border-color: rgba(61,42,20,0.22);
}
[data-theme="desert"] .option-btn span {
color: var(--text-muted);
}
[data-theme="desert"] .option-btn i {
color: var(--wood-medium);
}
[data-theme="nuit"] {
--stone-dark: #080818;
--stone-medium: #1a1a3a;
--stone-light: #2a2a5a;
--wood-dark: #100830;
--wood-medium: #1e0f50;
--wood-light: #3a1a80;

--text-main: rgba(240,234,255,0.94);
--text-muted: rgba(240,234,255,0.76);
--text-light: #f0eaff;
--text-gold: #bb86fc;

--highlight-cyan: #03dac6;
--info-blue: #7dd3f7;
--danger-red: #ff6b8a;

--panel-bg: rgba(10, 8, 30, 0.72);
--panel-border: rgba(187, 134, 252, 0.22);

--board-surface-light: #0d0d2a;
--board-border-dark: #050510;
--parchment-bg: #0d0d2a;
--cell-border: rgba(187, 134, 252, 0.15);
}
[data-theme="nuit"] body {
background: linear-gradient(135deg, #0d0820, #050510);
color: var(--text-main);
background-image:
radial-gradient(circle at 15% 20%, rgba(187,134,252,0.18), transparent 45%),
radial-gradient(circle at 80% 70%, rgba(3,218,198,0.10), transparent 55%),
radial-gradient(circle at 50% 50%, rgba(255,255,255,0.04), transparent 40%);
}
[data-theme="nuit"] .stone.player1 {
background: radial-gradient(circle at 35% 35%, #7c3aed, #2d1b69 60%, #110830 90%);
box-shadow: 0 5px 12px rgba(0,0,0,0.7), inset 0 -5px 12px rgba(0,0,0,0.5), inset 0 5px 10px rgba(187,134,252,0.3), 0 0 10px rgba(187,134,252,0.3);
}
[data-theme="nuit"] .stone.player2 {
background: radial-gradient(circle at 35% 35%, #03dac6, #018786 60%, #003a3a 90%);
box-shadow: 0 5px 12px rgba(0,0,0,0.7), inset 0 -5px 12px rgba(0,0,0,0.5), inset 0 5px 10px rgba(3,218,198,0.3), 0 0 10px rgba(3,218,198,0.3);
}
[data-theme="nuit"] .game-board {
background: #0d0d2a;
border-color: #1a0a4a;
}
[data-theme="nuit"] .game-board-container {
background: linear-gradient(160deg, #1a0a4a, #0d0828);
border-color: #3a1a80;
}
[data-theme="nuit"] .cell {
border-color: rgba(187, 134, 252, 0.1);
}
[data-theme="nuit"] .cell.dark-cell {
background: rgba(187,134,252,0.05);
}
[data-theme="nuit"] .cell.possible-move {
background: rgba(3,218,198,0.15);
outline-color: #03dac6;
}
[data-theme="nuit"] .cell.mill-highlight {
background: rgba(187,134,252,0.2);
outline-color: #bb86fc;
}
[data-theme="nuit"] .stone.player1.selected,
[data-theme="nuit"] .stone.player2.selected {
filter: brightness(1.3);
}
[data-theme="nuit"] .move-history-panel {
background: rgba(10,8,30,0.8);
border-color: rgba(187,134,252,0.28);
color: var(--text-main);
}
[data-theme="nuit"] .move-log-entry {
color: rgba(240,234,255,0.95);
}
[data-theme="nuit"] .move-history-title {
color: #bb86fc;
opacity: 1;
}
[data-theme="nuit"] .move-log-entry.mill-entry {
background: rgba(3,218,198,0.12);
border-left-color: #03dac6;
}
[data-theme="nuit"] .move-log-entry.capture-entry {
background: rgba(255,107,138,0.12);
border-left-color: #ff6b8a;
}
[data-theme="nuit"] .status {
background: rgba(10,8,30,0.78);
color: var(--text-main);
border-color: rgba(187,134,252,0.30);
}
[data-theme="nuit"] .game-info-display {
background: rgba(10,8,30,0.75);
color: var(--text-main);
border-color: rgba(187,134,252,0.25);
}
[data-theme="nuit"] .game-info-display strong {
color: #bb86fc;
}
[data-theme="nuit"] .player-info {
background: rgba(10,8,30,0.72);
color: var(--text-main);
border-color: rgba(187,134,252,0.22) !important;
}
[data-theme="nuit"] .player-title {
color: #bb86fc;
}
[data-theme="nuit"] .stat-value {
color: #bb86fc;
}
[data-theme="nuit"] .player-stat i {
color: #03dac6;
}

/* ==================== GLASSMORPHISM THEME ==================== */
[data-theme="glass"] {
--glass-blur: 18px;
--glass-accent: #e8b4f8;
--glass-accent2: #7dd3f7;
--stone-dark: #0a0814;
--stone-medium: #1a1030;
--stone-light: #2d1f55;
--wood-dark: #1a0a30;
--wood-medium: #2d1550;
--wood-light: #5a2898;
--text-gold: #e8b4f8;
--text-light: #f0eaff;
--text-main: #f0eaff;
--text-muted: rgba(240,234,255,0.78);
--highlight-cyan: #7dd3f7;
--danger-red: #ff7eb3;
--board-surface-light: rgba(255,255,255,0.06);
--board-border-dark: rgba(232,180,248,0.2);
--parchment-bg: rgba(10,8,20,0.95);
--cell-border: rgba(232,180,248,0.12);
--panel-bg: rgba(255,255,255,0.07);
--panel-border: rgba(255,255,255,0.18);
}
[data-theme="glass"] body {
background:
radial-gradient(ellipse at 15% 20%, rgba(168,85,247,0.4) 0%, transparent 55%),
radial-gradient(ellipse at 85% 80%, rgba(59,130,246,0.38) 0%, transparent 55%),
radial-gradient(ellipse at 50% 50%, rgba(20,10,50,0.95) 0%, rgba(5,3,18,1) 100%);
background-attachment: fixed;
color: var(--text-light);
}
[data-theme="glass"] header h1 {
background: linear-gradient(135deg, #e8b4f8 0%, #a78bfa 40%, #7dd3f7 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
text-shadow: none;
filter: drop-shadow(0 0 20px rgba(168,85,247,0.55));
}
[data-theme="glass"] .selection-area,
[data-theme="glass"] .version-card,
[data-theme="glass"] .option-btn {
background: linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04));
border: 1px solid rgba(232,180,248,0.22);
box-shadow: 0 8px 32px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.12);
backdrop-filter: blur(var(--glass-blur));
-webkit-backdrop-filter: blur(var(--glass-blur));
color: var(--text-light);
}
[data-theme="glass"] .selection-area h2 {
background: linear-gradient(135deg, #e8b4f8, #7dd3f7);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
text-shadow: none;
}
[data-theme="glass"] .version-card:hover,
[data-theme="glass"] .option-btn:hover {
background: linear-gradient(135deg, rgba(232,180,248,0.18), rgba(125,211,247,0.10));
border-color: rgba(232,180,248,0.5);
box-shadow: 0 12px 40px rgba(0,0,0,0.5), 0 0 20px rgba(168,85,247,0.3), inset 0 1px 0 rgba(255,255,255,0.18);
}
[data-theme="glass"] .version-card.active {
background: linear-gradient(135deg, rgba(168,85,247,0.3), rgba(59,130,246,0.2));
border-color: rgba(232,180,248,0.6);
color: var(--text-light);
}
[data-theme="glass"] .version-card h3 {
color: #e8b4f8;
}
[data-theme="glass"] .version-card.active h3 {
color: #f0eaff;
text-shadow: none;
}
[data-theme="glass"] .version-card.active p {
color: rgba(240,234,255,0.85);
}

[data-theme="glass"] .option-btn i {
color: #e8b4f8;
filter: drop-shadow(0 0 6px rgba(168,85,247,0.5));
}
[data-theme="glass"] .game-board-container {
background: linear-gradient(135deg, rgba(168,85,247,0.14), rgba(59,130,246,0.10));
border: 2px solid rgba(232,180,248,0.22);
box-shadow: 0 16px 48px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.07);
backdrop-filter: blur(6px);
-webkit-backdrop-filter: blur(6px);
}
[data-theme="glass"] .game-board {
background: rgba(255,255,255,0.04);
border-color: rgba(232,180,248,0.14);
}
[data-theme="glass"] .cell {
border-color: rgba(232,180,248,0.10);
box-shadow: inset 1px 1px 3px rgba(255,255,255,0.05), inset -1px -1px 3px rgba(0,0,0,0.2);
}
[data-theme="glass"] .cell.dark-cell {
background: rgba(232,180,248,0.04);
}
[data-theme="glass"] .cell.possible-move {
background: rgba(125,211,247,0.15);
outline-color: #7dd3f7;
box-shadow: inset 0 0 14px rgba(125,211,247,0.28);
}
[data-theme="glass"] .cell.mill-highlight {
background: rgba(232,180,248,0.18);
outline-color: #e8b4f8;
}
[data-theme="glass"] .cell.capturable {
background: rgba(255,126,179,0.18);
outline-color: #ff7eb3;
}
[data-theme="glass"] .stone.player1 {
background: radial-gradient(circle at 35% 35%, #c4b5fd, #7c3aed 55%, #2e1065 90%);
box-shadow: 0 5px 14px rgba(0,0,0,0.6), inset 0 -5px 12px rgba(0,0,0,0.4), inset 0 5px 10px rgba(196,181,253,0.4), 0 0 14px rgba(168,85,247,0.45);
}
[data-theme="glass"] .stone.player2 {
background: radial-gradient(circle at 35% 35%, #bae6fd, #0ea5e9 55%, #0c4a6e 90%);
box-shadow: 0 5px 14px rgba(0,0,0,0.6), inset 0 -5px 12px rgba(0,0,0,0.4), inset 0 5px 10px rgba(186,230,253,0.4), 0 0 14px rgba(59,130,246,0.45);
}
[data-theme="glass"] .status,
[data-theme="glass"] .game-info-display,
[data-theme="glass"] .player-info,
[data-theme="glass"] .move-history-panel {
background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
border-color: rgba(232,180,248,0.22);
backdrop-filter: blur(12px);
-webkit-backdrop-filter: blur(12px);
box-shadow: 0 4px 18px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.10);
color: #f0eaff;
}
[data-theme="glass"] .move-log-entry {
color: rgba(240,234,255,0.95);
}
[data-theme="glass"] .move-history-title {
color: #e8b4f8;
opacity: 1;
}
[data-theme="glass"] .move-log-entry.mill-entry {
background: rgba(125,211,247,0.12);
border-left-color: #7dd3f7;
}
[data-theme="glass"] .move-log-entry.capture-entry {
background: rgba(255,126,179,0.12);
border-left-color: #ff7eb3;
}
[data-theme="glass"] .player-info {
border-color: rgba(232,180,248,0.18) !important;
}
[data-theme="glass"] .player-info.active-player {
background: linear-gradient(135deg, rgba(168,85,247,0.22), rgba(59,130,246,0.14));
border-color: rgba(232,180,248,0.6) !important;
box-shadow: 0 0 30px rgba(168,85,247,0.42), inset 0 0 20px rgba(168,85,247,0.08);
}
[data-theme="glass"] .player-title,
[data-theme="glass"] .stat-value {
color: #e8b4f8;
text-shadow: 0 0 8px rgba(232,180,248,0.4);
}
[data-theme="glass"] .player-stat i {
color: #7dd3f7;
}
[data-theme="glass"] .game-info-display strong {
color: #7dd3f7;
}
[data-theme="glass"] .controls button {
background: linear-gradient(145deg, rgba(168,85,247,0.28), rgba(59,130,246,0.18));
border: 1px solid rgba(232,180,248,0.28);
backdrop-filter: blur(8px);
-webkit-backdrop-filter: blur(8px);
color: #f0eaff;
text-shadow: none;
box-shadow: 0 4px 14px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.10);
}
[data-theme="glass"] .controls button:not([disabled]):hover {
background: linear-gradient(145deg, rgba(168,85,247,0.48), rgba(59,130,246,0.32));
border-color: rgba(232,180,248,0.55);
box-shadow: 0 8px 24px rgba(0,0,0,0.5), 0 0 14px rgba(168,85,247,0.32);
}
[data-theme="glass"] .controls button.surrender-btn {
background: linear-gradient(145deg, rgba(255,126,179,0.28), rgba(190,18,60,0.18));
border-color: rgba(255,126,179,0.38);
}
[data-theme="glass"] #undo-btn {
background: linear-gradient(145deg, rgba(125,211,247,0.22), rgba(14,165,233,0.14));
border-color: rgba(125,211,247,0.32);
}
[data-theme="glass"] .toolbar-btn,
[data-theme="glass"] .language-selector {
background: linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.05));
border-color: rgba(232,180,248,0.3);
backdrop-filter: blur(14px);
-webkit-backdrop-filter: blur(14px);
color: #e8b4f8;
}
[data-theme="glass"] .toolbar-btn:hover,
[data-theme="glass"] .language-selector:hover {
background: linear-gradient(135deg, rgba(168,85,247,0.22), rgba(59,130,246,0.14));
border-color: rgba(232,180,248,0.55);
}
[data-theme="glass"] .language-selector i,
[data-theme="glass"] .language-selector select {
color: #e8b4f8;
}
[data-theme="glass"] #settings-fab {
background: linear-gradient(145deg, rgba(168,85,247,0.7), rgba(59,130,246,0.5));
border-color: rgba(232,180,248,0.55);
color: #f0eaff;
}
[data-theme="glass"] .back-btn,
[data-theme="glass"] .rules-btn {
background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
border-color: rgba(232,180,248,0.3);
color: #e8b4f8;
backdrop-filter: blur(8px);
-webkit-backdrop-filter: blur(8px);
}
[data-theme="glass"] .back-btn:hover, [data-theme="glass"] .rules-btn:hover {
background: linear-gradient(135deg, rgba(168,85,247,0.2), rgba(59,130,246,0.12));
border-color: rgba(232,180,248,0.55);
}
[data-theme="glass"] .start-game-btn {
background: linear-gradient(145deg, #c4b5fd, #7c3aed, #5b21b6);
border-color: rgba(232,180,248,0.6);
color: #fff;
text-shadow: 0 1px 3px rgba(0,0,0,0.4);
box-shadow: 0 8px 28px rgba(0,0,0,0.6), 0 0 30px rgba(168,85,247,0.5);
}
[data-theme="glass"] .start-game-btn:hover {
background: linear-gradient(145deg, #ddd6fe, #a78bfa, #7c3aed);
box-shadow: 0 14px 40px rgba(0,0,0,0.7), 0 0 50px rgba(168,85,247,0.65);
}
[data-theme="glass"] .player-setup-area {
background: linear-gradient(135deg, rgba(255,255,255,0.09), rgba(255,255,255,0.04));
border-color: rgba(232,180,248,0.3);
backdrop-filter: blur(16px);
-webkit-backdrop-filter: blur(16px);
}
[data-theme="glass"] .player-setup-area .setup-section {
background: rgba(255,255,255,0.05);
border-color: rgba(232,180,248,0.18);
}
[data-theme="glass"] .player-setup-area input[type="text"] {
background: rgba(255,255,255,0.07);
border-color: rgba(232,180,248,0.35);
color: #f0eaff;
}
[data-theme="glass"] .player-setup-area input[type="text"]:focus {
border-color: #7dd3f7;
box-shadow: 0 0 14px rgba(125,211,247,0.4);
}
[data-theme="glass"] .stone-decoration {
color: rgba(232,180,248,0.18);
}


/* ==================== KABYLIE: EXTRA READABILITY ==================== */
[data-theme="kabylie"] .option-btn {
background: rgba(255,255,255,0.88);
border-color: rgba(30,136,229,0.28);
box-shadow: 0 10px 22px rgba(0,0,0,0.10);
}
[data-theme="kabylie"] .option-btn:hover {
background: rgba(30,136,229,0.06);
border-color: rgba(30,136,229,0.45);
box-shadow: 0 14px 30px rgba(0,0,0,0.12);
}
[data-theme="kabylie"] .option-btn i {
color: var(--kab-red);
filter: none;
}

[data-theme="kabylie"] .player-info {
background: rgba(255,255,255,0.86);
border-color: rgba(31,26,18,0.18);
box-shadow: 0 10px 22px rgba(0,0,0,0.10);
color: var(--text-main);
}
[data-theme="kabylie"] .player-title {
color: var(--kab-blue);
text-shadow: none;
}
[data-theme="kabylie"] .player-stat i {
color: var(--kab-green);
text-shadow: none;
opacity: 0.9;
}
[data-theme="kabylie"] .stat-value {
color: var(--kab-red);
text-shadow: none;
}
[data-theme="kabylie"] .player-info.active-player {
background: rgba(46,125,50,0.12);
border-color: rgba(46,125,50,0.55) !important;
box-shadow: 0 0 22px rgba(46,125,50,0.28), 0 10px 22px rgba(0,0,0,0.10);
}
[data-theme="kabylie"] .start-game-btn {
background: linear-gradient(145deg, #43a047, #1b5e20);
border-color: rgba(27,94,32,0.7);
color: #fff;
text-shadow: 0 1px 3px rgba(0,0,0,0.4);
box-shadow: 0 8px 24px rgba(0,0,0,0.25), 0 0 24px rgba(67,160,71,0.4);
}
[data-theme="kabylie"] .start-game-btn:hover {
background: linear-gradient(145deg, #66bb6a, #2e7d32);
box-shadow: 0 12px 32px rgba(0,0,0,0.28), 0 0 36px rgba(67,160,71,0.55);
}

/* ==================== HIGH-CONTRAST THEME ==================== */
[data-theme="contrast"] {
--stone-dark: #000000;
--stone-medium: #1a1a1a;
--stone-light: #ffffff;

--wood-dark: #000000;
--wood-medium: #0f0f0f;
--wood-light: #2a2a2a;

--text-main: #ffffff;
--text-muted: #e6e6e6;
--text-light: #ffffff;
--text-gold: #ffd400;

--highlight-cyan: #00e5ff;
--info-blue: #00e5ff;
--danger-red: #ff3b3b;

--panel-bg: #000000;
--panel-border: #ffffff;

--board-surface-light: #000000;
--board-border-dark: #ffffff;
--parchment-bg: #000000;

--cell-border: rgba(255,255,255,0.65);
}
[data-theme="contrast"] body {
background: #000000;
color: #ffffff;
background-image: none;
}
[data-theme="contrast"] header h1 {
color: var(--text-gold);
text-shadow: none;
}
[data-theme="contrast"] header::after {
color: rgba(255,255,255,0.85);
}
[data-theme="contrast"] .selection-area,
[data-theme="contrast"] .version-card,
[data-theme="contrast"] .difficulty-card,
[data-theme="contrast"] .mode-card,
[data-theme="contrast"] .ai-difficulty-panel,
[data-theme="contrast"] .rules-modal-content,
[data-theme="contrast"] .status,
[data-theme="contrast"] .game-info-display,
[data-theme="contrast"] .player-info,
[data-theme="contrast"] .move-history-panel {
background: #000000 !important;
border-color: #ffffff !important;
box-shadow: none !important;
backdrop-filter: none !important;
-webkit-backdrop-filter: none !important;
color: #ffffff !important;
}
[data-theme="contrast"] .option-btn i {
color: var(--text-gold);
filter: none;
}
[data-theme="contrast"] .move-log-entry {
color: #ffffff;
}
[data-theme="contrast"] .move-history-title {
color: var(--text-gold);
opacity: 1;
}
[data-theme="contrast"] .move-log-entry.mill-entry {
background: rgba(0,229,255,0.15);
border-left-color: var(--highlight-cyan);
}
[data-theme="contrast"] .move-log-entry.capture-entry {
background: rgba(255,59,59,0.15);
border-left-color: var(--danger-red);
}
[data-theme="contrast"] .game-board-container {
box-shadow: none !important;
border-color: #ffffff !important;
}
[data-theme="contrast"] .game-board {
background: #000000;
border-color: #ffffff;
box-shadow: none !important;
}
[data-theme="contrast"] .cell {
box-shadow: none !important;
}
[data-theme="contrast"] .cell.possible-move {
background: rgba(0,229,255,0.22);
outline-color: #00e5ff;
}
[data-theme="contrast"] .cell.mill-highlight {
background: rgba(255,212,0,0.22);
outline-color: #ffd400;
}
[data-theme="contrast"] .cell.capturable {
background: rgba(255,59,59,0.22);
outline-color: #ff3b3b;
}
[data-theme="contrast"] .stone.player1 {
background: #111111;
box-shadow: inset 0 0 0 2px #ffffff, 0 6px 12px rgba(0,0,0,0.7);
}
[data-theme="contrast"] .stone.player2 {
background: #eeeeee;
box-shadow: inset 0 0 0 2px #000000, 0 6px 12px rgba(0,0,0,0.7);
}
[data-theme="contrast"] .stone.selected {
outline-color: #00e5ff;
}

/* ==================== FLOATING SETTINGS PANEL (bottom-right) ==================== */
/* Removed from top so it never obstructs the game view */
.toolbar-buttons {
position: fixed;
bottom: 1.25rem;
right: 1.25rem;
z-index: 1020;
display: flex;
flex-direction: column;
align-items: flex-end;
gap: 0.5rem;
max-width: min(280px, calc(100vw - 1.5rem));
}

/* Toggle FAB */
#settings-fab {
display: flex;
align-items: center;
justify-content: center;
width: 44px;
height: 44px;
border-radius: 50%;
background: linear-gradient(145deg, var(--wood-light, #9d603a), var(--wood-dark, #5a341f));
border: 2px solid rgba(240,200,80,0.5);
box-shadow: 0 4px 14px rgba(0,0,0,0.4), 0 0 0 0 rgba(240,200,80,0);
cursor: pointer;
color: var(--text-gold, #f0c850);
font-size: 1.15rem;
transition: all 0.25s ease;
flex-shrink: 0;
z-index: 2;
}
#settings-fab:hover {
transform: scale(1.08) rotate(15deg);
box-shadow: 0 6px 18px rgba(0,0,0,0.5), 0 0 16px rgba(240,200,80,0.35);
}
#settings-fab.open {
transform: rotate(45deg);
}

/* Collapsible tray */
.settings-tray {
display: flex;
flex-direction: column;
align-items: flex-start;
gap: 0.45rem;
overflow: hidden;
max-height: 0;
opacity: 0;
pointer-events: none;
transition: max-height 0.35s cubic-bezier(0.4,0,0.2,1), opacity 0.25s ease;
}
.settings-tray.open {
max-height: min(420px, calc(100dvh - 6rem));
opacity: 1;
pointer-events: all;
overflow-y: auto;
overscroll-behavior: contain;
}
.settings-tray.open::-webkit-scrollbar {
width: 8px;
}
.settings-tray.open::-webkit-scrollbar-thumb {
background: rgba(240, 200, 80, 0.22);
border-radius: 999px;
}
.settings-tray.open::-webkit-scrollbar-track {
background: transparent;
}

.toolbar-btn {
display: flex;
align-items: center;
justify-content: center;
background: rgba(20, 15, 10, 0.82);
border-radius: 22px;
padding: 0.4rem 0.85rem;
border: 1px solid rgba(240, 200, 80, 0.35);
box-shadow: 0 3px 10px rgba(0,0,0,0.4);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
transition: all 0.2s ease;
cursor: pointer;
color: var(--text-gold, #f0c850);
font-size: 0.92rem;
gap: 0.45rem;
white-space: nowrap;
min-height: 36px;
}
.toolbar-btn:hover {
background: rgba(240, 200, 80, 0.14);
border-color: rgba(240, 200, 80, 0.6);
transform: translateX(-3px);
}
.toolbar-btn.sound-off {
opacity: 0.55;
}

/* Language selector inside tray */
.language-selector {
position: relative;
display: flex;
align-items: center;
background: rgba(20, 15, 10, 0.82);
border-radius: 22px;
padding: 0.4rem 0.85rem;
border: 1px solid rgba(240, 200, 80, 0.35);
box-shadow: 0 3px 10px rgba(0,0,0,0.4);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
transition: all 0.2s ease;
gap: 0.45rem;
}
.language-selector::after {
content: '▾';
font-size: 0.75rem;
opacity: 0.75;
margin-left: 0.15rem;
line-height: 1;
}

.language-selector:hover {
background: rgba(240, 200, 80, 0.14);
border-color: rgba(240, 200, 80, 0.6);
transform: translateX(-3px);
}
.language-selector i {
color: var(--text-gold, #f0c850);
font-size: 0.92rem;
}
.language-selector select {
background: transparent;
color: inherit;
border: none;
padding: 0.12rem 1.25rem 0.12rem 0.25rem;
min-width: 120px;
font-family: var(--font-body);
font-size: 0.88rem;
font-weight: 700;
cursor: pointer;
outline: none;
appearance: none;
-webkit-appearance: none;
-moz-appearance: none;
}
.language-selector select option {
background: #2c2722;
color: #f5f5f5;
}

/* ==================== MOVE HISTORY PANEL ==================== */
.move-history-panel {
width: 100%;
max-height: 160px;
overflow: hidden;
background: rgba(0,0,0,0.5);
border: 1.5px solid rgba(240,200,80,0.4);
border-radius: 9px;
padding: 0.6rem 0.85rem;
transition: max-height 0.3s ease;
}
.move-history-title {
font-size: 0.78rem;
color: var(--text-gold);
opacity: 0.9;
text-transform: uppercase;
letter-spacing: 1px;
margin-bottom: 5px;
display: flex;
align-items: center;
gap: 6px;
font-weight: 700;
}
.move-log-list {
display: flex;
flex-direction: column-reverse;
gap: 3px;
max-height: 110px;
overflow-y: auto;
scrollbar-width: thin;
scrollbar-color: rgba(240,200,80,0.3) transparent;
}
.move-log-entry {
font-size: 0.78rem;
color: var(--text-main);
opacity: 1;
padding: 2px 6px;
border-radius: 4px;
display: flex;
align-items: center;
gap: 6px;
animation: logFadeIn 0.3s ease;
font-weight: 500;
}
.move-log-entry .log-stone {
width: 10px;
height: 10px;
border-radius: 50%;
flex-shrink: 0;
}
.move-log-entry .log-stone.p1 {
background: var(--player1-stone-color-light);
border: 1px solid #555;
}
.move-log-entry .log-stone.p2 {
background: var(--player2-stone-color-light);
border: 1px solid #ccc;
}
.move-log-entry.mill-entry {
background: rgba(0,255,255,0.12);
border-left: 2px solid var(--highlight-cyan);
}
.move-log-entry.capture-entry {
background: rgba(255,77,77,0.12);
border-left: 2px solid var(--danger-red);
}
@keyframes logFadeIn {
from {
opacity: 0;
transform: translateX(-10px);
}
to {
opacity: 1;
transform: translateX(0);
}
}

/* ==================== SPECTATOR MODE ==================== */
.spectator-badge {
position: fixed;
bottom: 1rem;
left: 50%;
transform: translateX(-50%);
background: rgba(0,0,0,0.7);
border: 1px solid var(--text-gold);
border-radius: 20px;
padding: 0.3rem 1rem;
color: var(--text-gold);
font-size: 0.85rem;
font-family: var(--font-title);
letter-spacing: 1px;
z-index: 5;
display: none;
animation: fadeIn 0.5s ease;
pointer-events: none;
}
.spectator-badge.visible {
display: block;
}

/* ==================== SAVE NOTIFICATION ==================== */
.save-notification {
position: fixed;
bottom: 1.5rem;
right: 1.5rem;
background: rgba(20,20,20,0.95);
border: 1px solid var(--text-gold);
border-radius: 12px;
padding: 0.8rem 1.2rem;
color: var(--text-light);
font-size: 0.9rem;
z-index: 1030;
display: none;
gap: 0.8rem;
align-items: center;
box-shadow: 0 5px 20px rgba(0,0,0,0.6);
max-width: 320px;
animation: slideInRight 0.4s ease;
}
.save-notification.visible {
display: flex;
}
@keyframes slideInRight {
from {
transform: translateX(100px);
opacity: 0;
}
to {
transform: translateX(0);
opacity: 1;
}
}
.save-notification .save-btns {
display: flex;
gap: 0.5rem;
flex-shrink: 0;
}
.save-notification button {
padding: 0.35rem 0.9rem;
border-radius: 20px;
border: 1px solid var(--text-gold);
cursor: pointer;
font-size: 0.8rem;
font-family: var(--font-body);
transition: all 0.2s;
}
.save-notification .btn-resume {
background: var(--text-gold);
color: var(--stone-dark);
font-weight: bold;
}
.save-notification .btn-resume:hover {
filter: brightness(1.15);
}
.save-notification .btn-discard {
background: transparent;
color: var(--text-gold);
}
.save-notification .btn-discard:hover {
background: rgba(240,200,80,0.1);
}

/* ==================== MILL FLASH ANIMATION ==================== */
@keyframes millFlash {
0% {
box-shadow: inset 0 0 0 rgba(0,255,255,0), 0 0 0 0 rgba(0,255,255,0);
}
30% {
box-shadow: inset 0 0 25px rgba(0,255,255,0.9), 0 0 30px rgba(0,255,255,0.8);
}
60% {
box-shadow: inset 0 0 10px rgba(0,255,255,0.5), 0 0 15px rgba(0,255,255,0.4);
}
100% {
box-shadow: inset 0 0 5px rgba(0,255,255,0.2), 0 0 5px rgba(0,255,255,0.2);
}
}
.cell.mill-highlight {
animation: mill-pulse 1.5s infinite, millFlash 0.6s ease-out !important;
}

/* ==================== MOBILE IMPROVEMENTS ==================== */
@media (max-width: 480px) {
.controls button {
flex-basis: 70px;
padding: 0.6rem 0.6rem;
font-size: 0.66rem;
max-width: none;
}
.controls button span {
display: none;
}
.controls button i {
font-size: 1.1rem;
}
.toolbar-btn span {
display: none;
}
.move-history-panel {
max-height: 90px;
}
.game-info-display {
font-size: 0.78rem;
padding: 0.4rem 0.6rem;
gap: 0.6rem;
}
.selection-area {
padding: 1rem;
}
.options-group {
gap: 0.8rem;
}
.version-card {
padding: 1rem;
}
.game-play-area.active {
gap: 0.6rem;
padding: 0.5rem;
}
}
@media (max-width: 360px) {
.splash-langs {
flex-direction: column;
align-items: center;
}
.splash-lang-btn {
min-width: 80%;
max-width: 80%;
}
}
@media (max-width: 380px) {
.stone {
width: 72%;
height: 72%;
}
}

/* ==================== SPECTATOR SPEED CONTROLS ==================== */
.spectator-controls {
display: none;
align-items: center;
gap: 0.5rem;
background: rgba(0,0,0,0.4);
border: 1px solid rgba(240,200,80,0.3);
border-radius: 8px;
padding: 0.3rem 0.75rem;
font-size: 0.85rem;
color: var(--text-gold);
}
.spectator-controls.visible {
display: flex;
}
.spectator-controls select {
background: transparent;
color: var(--text-gold);
border: none;
outline: none;
font-family: var(--font-body);
font-size: 0.85rem;
cursor: pointer;
appearance: none;
-webkit-appearance: none;
}
.spectator-controls select option {
background: var(--stone-dark);
color: var(--text-light);
}

/* ===== Accessibility + robustness improvements ===== */
:focus-visible {
outline: 3px solid rgba(240,200,80,0.9);
outline-offset: 3px;
}
@media (prefers-reduced-motion: reduce) {
* {
animation-duration: 0.001ms !important;
animation-iteration-count: 1 !important;
transition-duration: 0.001ms !important;
scroll-behavior: auto !important;
}
}
/* Debug overlay (runtime errors, rejections, logs) */
/* Confetti canvas (no external dependency) */
#confetti-canvas {
position: fixed;
inset: 0;
pointer-events: none;
z-index: 2500;
width: 100%;
height: 100%;
}



/* =====================================================================
   DESIGN REFRESH v4 — Ergonomie + lisibilité + graphisme modernisé
   (Overrides placed at end to avoid touching core logic)
   ===================================================================== */

:root {
/* Shape + depth */
--radius-xs: 10px;
--radius-sm: 14px;
--radius-md: 18px;
--radius-lg: 24px;
--radius-xl: 30px;

--shadow-1: 0 10px 24px rgba(0,0,0,.18);
--shadow-2: 0 18px 48px rgba(0,0,0,.24);
--shadow-3: 0 26px 76px rgba(0,0,0,.30);

/* Layout rhythm */
--space-1: .35rem;
--space-2: .6rem;
--space-3: 1rem;
--space-4: 1.4rem;
--space-5: 2rem;

/* Mapping to existing theme variables */
--surface-1: var(--panel-bg, rgba(0,0,0,.45));
--surface-2: rgba(0,0,0,.55);
--surface-3: rgba(255,255,255,.06);
--border-1: var(--panel-border, rgba(240, 200, 80, 0.45));

--focus-ring: 0 0 0 3px rgba(0, 255, 255, 0.35);
--ease-out: cubic-bezier(.2,.9,.2,1);
}

/* Better mixing when supported */
@supports (color: color-mix(in srgb, #000 50%, #fff)) {
:root {
--surface-2: color-mix(in srgb, var(--surface-1) 88%, #000 12%);
--surface-3: color-mix(in srgb, var(--surface-1) 82%, #fff 18%);
--border-1: color-mix(in srgb, var(--panel-border, rgba(240,200,80,.45)) 75%, transparent);
--focus-ring: 0 0 0 3px color-mix(in srgb, var(--highlight-cyan) 55%, transparent);
}
}

/* Shadows tuned per theme brightness */
[data-theme="kabylie"], [data-theme="desert"] {
--shadow-1: 0 10px 25px rgba(31,26,18,.12);
--shadow-2: 0 18px 55px rgba(31,26,18,.18);
--shadow-3: 0 28px 78px rgba(31,26,18,.22);
}
[data-theme="nuit"], [data-theme="glass"], [data-theme="contrast"] {
--shadow-1: 0 10px 25px rgba(0,0,0,.26);
--shadow-2: 0 18px 55px rgba(0,0,0,.30);
--shadow-3: 0 28px 78px rgba(0,0,0,.36);
}

/* =====================================================================
   Global readability + accessibility
   ===================================================================== */

html {
text-size-adjust: 100%;
}
body {
font-family: var(--font-ui);
line-height: 1.6;
letter-spacing: .1px;
text-rendering: optimizeLegibility;
}
::selection {
background: rgba(0, 255, 255, 0.22);
}
a, button, select, input, textarea {
-webkit-tap-highlight-color: transparent;
}
:focus {
outline: none;
}
:focus-visible {
box-shadow: var(--focus-ring) !important;
outline: none !important;
}
@media (prefers-reduced-motion: reduce) {
* {
animation: none !important;
transition: none !important;
scroll-behavior: auto !important;
}
}

/* Subtle texture + depth behind the app (graphisme) */
.game-container {
position: relative;
}
.game-container::before {
content: "";
position: absolute;
inset: -24px;
pointer-events: none;
z-index: 0;
opacity: .24;
background:
radial-gradient(600px 220px at 18% 12%, rgba(255,255,255,.18), transparent 65%),
radial-gradient(520px 260px at 82% 8%, rgba(0,255,255,.10), transparent 68%),
radial-gradient(620px 320px at 52% 82%, rgba(240,200,80,.10), transparent 70%),
url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 160 160'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='2' stitchTiles='stitch'/></filter><rect width='160' height='160' filter='url(%23n)' opacity='.22'/></svg>");
mix-blend-mode: overlay;
filter: saturate(1.05) contrast(1.02);
}
.game-container > * {
position: relative;
z-index: 1;
}

/* Scrollbars (ergonomie) */
.selection-area, .rules-book, .move-log-list {
scrollbar-width: thin;
scrollbar-color: rgba(240,200,80,.55) transparent;
}
.selection-area::-webkit-scrollbar,
.rules-book::-webkit-scrollbar,
.move-log-list::-webkit-scrollbar {
width: 10px;
}
.selection-area::-webkit-scrollbar-thumb,
.rules-book::-webkit-scrollbar-thumb,
.move-log-list::-webkit-scrollbar-thumb {
background: rgba(240,200,80,.35);
border-radius: 999px;
border: 2px solid transparent;
background-clip: padding-box;
}
.selection-area::-webkit-scrollbar-thumb:hover,
.rules-book::-webkit-scrollbar-thumb:hover,
.move-log-list::-webkit-scrollbar-thumb:hover {
background: rgba(240,200,80,.55);
background-clip: padding-box;
}

/* =====================================================================
   Header + title (moins chargé, plus premium)
   ===================================================================== */

header {
padding: .9rem 0 .7rem;
}
header::before {
content: "";
position: absolute;
inset: auto 10% 0 10%;
height: 1px;
background: linear-gradient(90deg, transparent, rgba(240,200,80,.6), transparent);
opacity: .55;
}
h1 {
font-weight: 800;
letter-spacing: .22em;
text-transform: uppercase;
text-shadow: 0 8px 18px rgba(0,0,0,.30);
}
h1::after {
filter: drop-shadow(0 10px 22px rgba(0,0,0,.26));
opacity: .55;
}

/* =====================================================================
   Cards / panels (cohérence visuelle)
   ===================================================================== */

.selection-area {
border-radius: var(--radius-xl);
border: 1px solid var(--border-1);
background: var(--surface-1);
box-shadow: var(--shadow-3);
backdrop-filter: blur(var(--glass-blur, 10px));
-webkit-backdrop-filter: blur(var(--glass-blur, 10px));
gap: 1.25rem;
}
.selection-area h2 {
letter-spacing: .06em;
text-shadow: 0 10px 18px rgba(0,0,0,.18);
}
.selection-area p {
max-width: 72ch;
line-height: 1.62;
color: var(--text-main);
opacity: .92;
}

/* Shared card treatment for selectable tiles */
.version-card, .mode-card, .difficulty-card, .option-btn {
border-radius: var(--radius-lg);
border: 1px solid color-mix(in srgb, var(--border-1) 70%, transparent);
box-shadow: var(--shadow-1);
overflow: hidden;
transform: translateZ(0);
transition: transform .22s var(--ease-out), box-shadow .22s var(--ease-out), border-color .22s var(--ease-out), filter .22s var(--ease-out);
}
@supports not (color: color-mix(in srgb, #000 50%, #fff)) {
.version-card, .mode-card, .difficulty-card, .option-btn {
border: 1px solid var(--border-1);
}
}
.version-card:hover, .mode-card:hover, .difficulty-card:hover, .option-btn:hover {
transform: translateY(-4px) scale(1.01);
box-shadow: var(--shadow-2);
filter: saturate(1.05);
}
.version-card:active, .mode-card:active, .difficulty-card:active, .option-btn:active {
transform: translateY(-1px) scale(0.99);
box-shadow: var(--shadow-1);
}

.version-card h3, .mode-card h3, .difficulty-card h3 {
letter-spacing: .14em;
}
.version-card p, .mode-card p, .difficulty-card p, .option-btn p {
color: var(--text-main);
opacity: .9;
}

/* =====================================================================
   Buttons (ergonomie + interactions)
   ===================================================================== */

.controls button,
.start-game-btn,
.rules-btn,
.back-btn,
.toolbar-btn,
#settings-fab,
.modal-actions button,
#confirm-surrender-btn,
#cancel-surrender-btn {
border-radius: 999px;
border: 1px solid color-mix(in srgb, var(--border-1) 70%, transparent);
box-shadow: var(--shadow-1);
transition: transform .18s var(--ease-out), box-shadow .18s var(--ease-out), filter .18s var(--ease-out), background-color .18s var(--ease-out);
position: relative;
overflow: hidden;
}
@supports not (color: color-mix(in srgb, #000 50%, #fff)) {
.controls button,
.start-game-btn,
.rules-btn,
.back-btn,
.toolbar-btn,
#settings-fab,
.modal-actions button,
#confirm-surrender-btn,
#cancel-surrender-btn {
border: 1px solid var(--border-1);
}
}

.controls button:hover,
.start-game-btn:hover,
.rules-btn:hover,
.back-btn:hover,
.toolbar-btn:hover,
#settings-fab:hover,
.modal-actions button:hover {
transform: translateY(-2px);
box-shadow: var(--shadow-2);
filter: saturate(1.05);
}
.controls button:active,
.start-game-btn:active,
.rules-btn:active,
.back-btn:active,
.toolbar-btn:active,
#settings-fab:active,
.modal-actions button:active {
transform: translateY(-1px);
box-shadow: var(--shadow-1);
}

/* Ripple-like feedback (CSS only) */
.controls button::after,
.start-game-btn::after,
.rules-btn::after,
.back-btn::after,
.toolbar-btn::after,
#settings-fab::after,
.modal-actions button::after {
content: "";
position: absolute;
inset: -1px;
background:
radial-gradient(220px 220px at var(--mx, 50%) var(--my, 50%),
rgba(255,255,255,.28), transparent 55%);
opacity: 0;
transition: opacity .22s var(--ease-out);
}
.controls button:active::after,
.start-game-btn:active::after,
.rules-btn:active::after,
.back-btn:active::after,
.toolbar-btn:active::after,
#settings-fab:active::after,
.modal-actions button:active::after {
opacity: 1;
}

/* Typography tweak inside pill buttons */
.start-game-btn, .rules-btn, .back-btn {
letter-spacing: .08em;
text-transform: uppercase;
}

/* =====================================================================
   Form controls (plus nets et cohérents)
   ===================================================================== */

select, input[type="text"] {
border-radius: var(--radius-md);
border: 1px solid color-mix(in srgb, var(--border-1) 75%, transparent);
background: var(--surface-2);
color: var(--text-main);
box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
}
select:hover, input[type="text"]:hover {
filter: saturate(1.05);
}
[data-theme="kabylie"] select, [data-theme="kabylie"] input[type="text"],
[data-theme="desert"] select, [data-theme="desert"] input[type="text"] {
background: rgba(255,255,255,.85);
color: #1f1a12;
}

/* =====================================================================
   Board + cells (graphisme + lisibilité des états)
   ===================================================================== */

.board {
border-radius: var(--radius-xl);
box-shadow: var(--shadow-3);
overflow: hidden;
outline: 1px solid rgba(255,255,255,.06);
}
.cell {
border-radius: 14px;
transition: transform .18s var(--ease-out), box-shadow .18s var(--ease-out), background-color .18s var(--ease-out), border-color .18s var(--ease-out);
}
.cell:hover {
transform: translateY(-1px);
border-color: rgba(240,200,80,.55);
box-shadow:
inset 1px 1px 6px rgba(255,255,255,0.45),
inset -1px -1px 6px rgba(0,0,0,0.45),
0 10px 18px rgba(0,0,0,0.18);
}
.cell.possible-move {
outline-style: solid;
outline-color: rgba(0,255,255,.55);
background: rgba(0,255,255,.10);
}
.cell.possible-move:hover {
background: rgba(0,255,255,.18);
}
.cell.mill-highlight {
box-shadow: 0 0 0 3px rgba(240,200,80,.45), inset 0 0 18px rgba(240,200,80,.22);
}

/* Stones a bit more “premium” */
.stone {
box-shadow:
0 10px 22px rgba(0,0,0,0.45),
inset 0 -8px 16px rgba(0,0,0,0.40),
inset 0 10px 12px rgba(255,255,255,0.22);
}
.stone::after {
content: "";
position: absolute;
inset: 12% 18% auto 18%;
height: 28%;
border-radius: 999px;
background: linear-gradient(180deg, rgba(255,255,255,.35), transparent);
opacity: .65;
pointer-events: none;
}

/* =====================================================================
   Modal / Rules (lecture plus confortable)
   ===================================================================== */

.modal-content, .rules-book {
border-radius: var(--radius-xl);
border: 1px solid var(--border-1);
box-shadow: var(--shadow-3);
}
.rules-book {
font-family: var(--font-body);
line-height: 1.7;
font-size: 1.02rem;
}
.rules-book h2, .rules-book h3 {
font-family: var(--font-title);
letter-spacing: .08em;
}

/* =====================================================================
   Toolbars (moins “brut”, plus cohérent)
   ===================================================================== */

.toolbar-btn {
gap: .55rem;
padding: .65rem .9rem !important;
}
#settings-fab {
width: 46px;
height: 46px;
border-radius: 999px;
box-shadow: var(--shadow-2);
}

/* =====================================================================
   Micro-animations (subtiles)
   ===================================================================== */

@keyframes softFloat {
0% {
transform: translateY(0);
}
50% {
transform: translateY(-10px);
}
100% {
transform: translateY(0);
}
}
.stone-decoration {
animation: softFloat 6s var(--ease-out) infinite;
opacity: .14;
}
.stone-2 {
animation-duration: 7.5s;
}
.stone-3 {
animation-duration: 6.8s;
}
.stone-4 {
animation-duration: 8.6s;
}

/* player-badge thèmes déjà gérés dans le bloc principal */


/* Soft sheen on selectable cards */
.version-card::after, .mode-card::after, .difficulty-card::after, .option-btn::after {
content: "";
position: absolute;
inset: -1px;
background:
radial-gradient(260px 260px at var(--mx, 30%) var(--my, 10%),
rgba(255,255,255,.22), transparent 58%),
linear-gradient(135deg, transparent, rgba(255,255,255,.05), transparent);
opacity: 0;
transition: opacity .22s var(--ease-out);
pointer-events: none;
}
.version-card:hover::after, .mode-card:hover::after, .difficulty-card:hover::after, .option-btn:hover::after {
opacity: .65;
}


@supports not (color: color-mix(in srgb, #000 50%, #fff)) {
select, input[type="text"] {
border: 1px solid var(--border-1);
}
}


/* ==================== MODERN THEME (Clean UI) ==================== */
/* A modern, readable UI layer that stays compatible with the existing game visuals. */
[data-theme="modern"],
[data-theme="modern-dark"] {
/* Typography + rhythm */
--font-ui: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
--font-title: 'Space Grotesk', var(--font-ui);
--font-body: 'Inter', var(--font-ui);
--transition-duration: 0.18s;

/* Radii + shadows */
--radius-sm: 10px;
--radius-md: 14px;
--radius-lg: 18px;
--shadow-sm: 0 1px 2px rgba(0,0,0,0.06);
--shadow-md: 0 10px 28px rgba(0,0,0,0.10);
--shadow-lg: 0 18px 50px rgba(0,0,0,0.14);
}

/* Light */
[data-theme="modern"] {
--text-main: #0f172a;
--text-muted: #475569;
--text-light: #ffffff;
--text-gold: #2563eb;

/* Turn the old “wood/stone” variables into a modern primary/accent system */
--wood-dark: #2563eb;
--wood-medium: #3b82f6;
--wood-light: #60a5fa;

--stone-dark: #0f172a;
--stone-medium: #334155;
--stone-light: #e2e8f0;

--highlight-cyan: #06b6d4;
--danger-red: #ef4444;

--bg-start: #f8fafc;
--bg-end: #eef2ff;

--panel-bg: rgba(255,255,255,0.92);
--panel-border: rgba(15,23,42,0.10);
--cell-border: rgba(15,23,42,0.12);

--board-surface-light: rgba(255,255,255,0.85);
--parchment-bg: rgba(255,255,255,0.75);
--board-border-dark: rgba(15,23,42,0.14);
}

/* Dark */
[data-theme="modern-dark"] {
--text-main: rgba(248,250,252,0.96);
--text-muted: rgba(226,232,240,0.78);
--text-light: #ffffff;
--text-gold: #38bdf8;

--wood-dark: #0ea5e9;
--wood-medium: #38bdf8;
--wood-light: #7dd3fc;

--stone-dark: #020617;
--stone-medium: #0f172a;
--stone-light: #1f2937;

--highlight-cyan: #22d3ee;
--danger-red: #fb7185;

--bg-start: #0b1220;
--bg-end: #0a0f1c;

--panel-bg: rgba(2,6,23,0.60);
--panel-border: rgba(148,163,184,0.16);
--cell-border: rgba(148,163,184,0.16);

--board-surface-light: rgba(2,6,23,0.50);
--parchment-bg: rgba(2,6,23,0.50);
--board-border-dark: rgba(148,163,184,0.18);
}

/* Body / background (remove the decorative svg texture for a cleaner look) */
[data-theme="modern"] body {
background: radial-gradient(800px 500px at 15% 10%, rgba(59,130,246,0.14), transparent 55%),
radial-gradient(700px 450px at 85% 15%, rgba(16,185,129,0.10), transparent 55%),
linear-gradient(180deg, var(--bg-start), var(--bg-end));
color: var(--text-main);
font-family: var(--font-body);
line-height: 1.6;
letter-spacing: 0.1px;
text-shadow: none;
background-image: none;
}

[data-theme="modern-dark"] body {
background: radial-gradient(900px 600px at 15% 10%, rgba(56,189,248,0.16), transparent 60%),
radial-gradient(700px 520px at 85% 20%, rgba(34,211,238,0.10), transparent 60%),
linear-gradient(180deg, var(--bg-start), var(--bg-end));
color: var(--text-main);
font-family: var(--font-body);
line-height: 1.6;
letter-spacing: 0.1px;
text-shadow: none;
background-image: none;
}

/* Headings (no fantasy glow) */
[data-theme="modern"] h1,
[data-theme="modern-dark"] h1 {
font-family: var(--font-title);
color: var(--text-main);
text-shadow: none;
letter-spacing: -0.5px;
}
[data-theme="modern"] h2,
[data-theme="modern-dark"] h2 {
font-family: var(--font-title);
color: var(--text-main);
text-shadow: none;
letter-spacing: -0.2px;
}

/* Panels / cards */
[data-theme="modern"] .selection-area,
[data-theme="modern-dark"] .selection-area,
[data-theme="modern"] .player-info,
[data-theme="modern-dark"] .player-info,
[data-theme="modern"] .status,
[data-theme="modern-dark"] .status,
[data-theme="modern"] .game-info-display,
[data-theme="modern-dark"] .game-info-display,
[data-theme="modern"] .move-history-panel,
[data-theme="modern-dark"] .move-history-panel,
[data-theme="modern"] .version-card,
[data-theme="modern-dark"] .version-card,
[data-theme="modern"] .difficulty-card,
[data-theme="modern-dark"] .difficulty-card,
[data-theme="modern"] .mode-card,
[data-theme="modern-dark"] .mode-card {
background: var(--panel-bg) !important;
border: 1px solid var(--panel-border) !important;
border-radius: var(--radius-lg) !important;
box-shadow: var(--shadow-md) !important;
color: var(--text-main) !important;
backdrop-filter: none !important;
-webkit-backdrop-filter: none !important;
}

[data-theme="modern"] .selection-area p,
[data-theme="modern-dark"] .selection-area p,
[data-theme="modern"] .move-history-panel p,
[data-theme="modern-dark"] .move-history-panel p {
color: var(--text-muted) !important;
}

/* Tool buttons / language selector (top UI) */
[data-theme="modern"] .toolbar-btn,
[data-theme="modern-dark"] .toolbar-btn,
[data-theme="modern"] .language-selector,
[data-theme="modern-dark"] .language-selector {
background: var(--panel-bg) !important;
border: 1px solid var(--panel-border) !important;
box-shadow: var(--shadow-sm) !important;
color: var(--text-main) !important;
border-radius: var(--radius-md) !important;
}

[data-theme="modern"] .toolbar-btn:hover,
[data-theme="modern-dark"] .toolbar-btn:hover {
transform: translateY(-1px);
box-shadow: var(--shadow-md) !important;
}

/* Buttons (modern, less “pill”, clearer states) */
[data-theme="modern"] button,
[data-theme="modern-dark"] button,
[data-theme="modern"] .option-btn,
[data-theme="modern-dark"] .option-btn,
[data-theme="modern"] .btn-resume,
[data-theme="modern-dark"] .btn-resume,
[data-theme="modern"] .btn-discard,
[data-theme="modern-dark"] .btn-discard {
border-radius: var(--radius-md) !important;
border: 1px solid rgba(255,255,255,0.0);
box-shadow: var(--shadow-sm) !important;
text-transform: none !important;
letter-spacing: 0.15px !important;
}

[data-theme="modern"] button,
[data-theme="modern"] .option-btn,
[data-theme="modern"] .btn-resume {
background: linear-gradient(180deg, rgba(37,99,235,0.98), rgba(59,130,246,0.92)) !important;
color: #ffffff !important;
border-color: rgba(15,23,42,0.06) !important;
}

[data-theme="modern-dark"] button,
[data-theme="modern-dark"] .option-btn,
[data-theme="modern-dark"] .btn-resume {
background: linear-gradient(180deg, rgba(14,165,233,0.95), rgba(56,189,248,0.85)) !important;
color: #001018 !important;
border-color: rgba(125,211,252,0.35) !important;
}

[data-theme="modern"] .btn-discard,
[data-theme="modern-dark"] .btn-discard {
background: transparent !important;
border: 1px solid var(--panel-border) !important;
color: var(--text-main) !important;
}

[data-theme="modern"] button:hover,
[data-theme="modern-dark"] button:hover,
[data-theme="modern"] .option-btn:hover,
[data-theme="modern-dark"] .option-btn:hover {
transform: translateY(-1px);
box-shadow: var(--shadow-md) !important;
filter: saturate(1.08);
}

[data-theme="modern"] button:active,
[data-theme="modern-dark"] button:active,
[data-theme="modern"] .option-btn:active,
[data-theme="modern-dark"] .option-btn:active {
transform: translateY(0px) scale(0.99);
}

/* Focus rings (keyboard accessibility) */
[data-theme="modern"] :focus-visible,
[data-theme="modern-dark"] :focus-visible {
outline: 3px solid rgba(37,99,235,0.35);
outline-offset: 2px;
border-radius: 9px;
}

/* Board: cleaner grid, less inset “carving” */
[data-theme="modern"] .game-board,
[data-theme="modern-dark"] .game-board {
border-radius: var(--radius-lg) !important;
border: 1px solid var(--board-border-dark) !important;
box-shadow: var(--shadow-lg) !important;
background: var(--board-surface-light) !important;
}

[data-theme="modern"] .cell,
[data-theme="modern-dark"] .cell {
box-shadow: none !important;
border-color: var(--cell-border) !important;
background: rgba(15,23,42,0.02);
}

[data-theme="modern-dark"] .cell {
background: rgba(148,163,184,0.06);
}

[data-theme="modern"] .cell:hover,
[data-theme="modern-dark"] .cell:hover {
background: rgba(37,99,235,0.10) !important;
}

/* Modals: clean surface */
[data-theme="modern"] .modal-content,
[data-theme="modern-dark"] .modal-content {
background: var(--panel-bg) !important;
border: 1px solid var(--panel-border) !important;
border-radius: var(--radius-lg) !important;
box-shadow: var(--shadow-lg) !important;
color: var(--text-main) !important;
text-shadow: none !important;
}

[data-theme="modern"] .modal-content h3,
[data-theme="modern-dark"] .modal-content h3 {
color: var(--text-main) !important;
text-shadow: none !important;
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
[data-theme="modern"] *,
[data-theme="modern-dark"] * {
animation-duration: 0.001ms !important;
animation-iteration-count: 1 !important;
transition-duration: 0.001ms !important;
scroll-behavior: auto !important;
}
}

/* Move history visibility in modern themes */
[data-theme="modern"] .move-log-entry {
color: var(--text-main) !important;
}
[data-theme="modern"] .move-history-title {
color: var(--wood-medium) !important;
opacity: 1 !important;
}
[data-theme="modern"] .move-log-entry.mill-entry {
background: rgba(6,182,212,0.10) !important;
border-left-color: var(--highlight-cyan) !important;
}
[data-theme="modern"] .move-log-entry.capture-entry {
background: rgba(239,68,68,0.08) !important;
border-left-color: var(--danger-red) !important;
}
[data-theme="modern-dark"] .move-log-entry {
color: var(--text-main) !important;
}
[data-theme="modern-dark"] .move-history-title {
color: var(--text-gold) !important;
opacity: 1 !important;
}
[data-theme="modern-dark"] .move-log-entry.mill-entry {
background: rgba(34,211,238,0.12) !important;
border-left-color: var(--highlight-cyan) !important;
}
[data-theme="modern-dark"] .move-log-entry.capture-entry {
background: rgba(251,113,133,0.12) !important;
border-left-color: var(--danger-red) !important;
}

/* Modern theme play button */
[data-theme="modern"] .start-game-btn,
[data-theme="modern-dark"] .start-game-btn {
background: linear-gradient(145deg, #3b82f6, #2563eb, #1d4ed8) !important;
color: #ffffff !important;
border-color: rgba(15,23,42,0.2) !important;
text-shadow: 0 1px 2px rgba(0,0,0,0.3) !important;
box-shadow: 0 8px 24px rgba(37,99,235,0.4), 0 3px 0 rgba(0,0,0,0.2) !important;
letter-spacing: 3px !important;
animation: playBtnPulseBlue 2.5s ease-in-out infinite !important;
}
[data-theme="modern"] .start-game-btn:hover,
[data-theme="modern-dark"] .start-game-btn:hover {
background: linear-gradient(145deg, #60a5fa, #3b82f6, #2563eb) !important;
box-shadow: 0 14px 36px rgba(37,99,235,0.5), 0 0 40px rgba(59,130,246,0.45) !important;
}
@keyframes playBtnPulseBlue {
0%, 100% {
box-shadow: 0 8px 24px rgba(37,99,235,0.4), 0 0 0 0 rgba(59,130,246,0.5), 0 3px 0 rgba(0,0,0,0.2);
}
50% {
box-shadow: 0 8px 24px rgba(37,99,235,0.4), 0 0 0 8px rgba(59,130,246,0), 0 3px 0 rgba(0,0,0,0.2);
}
}



/* =======================================================================
   Modern Responsive + Buttons Visibility Patch (v3)
   - Better mobile/tablet layout (without shrinking desktop layout)
   - Settings button emphasized
   - Ensures button text/icons stay readable across themes
   ======================================================================= */

/* Button design tokens (safe defaults) */
:root {
--btn-radius: 14px;
--btn-bg: linear-gradient(145deg, var(--wood-light), var(--wood-medium));
--btn-bg-hover: linear-gradient(145deg, var(--wood-medium), var(--wood-dark));
--btn-border: rgba(0,0,0,0.18);
--btn-fg: var(--text-light);
--btn-shadow: 0 10px 22px rgba(0,0,0,0.28);
--btn-shadow-hover: 0 14px 30px rgba(0,0,0,0.33);
}

/* Modern themes: consistent, high-contrast buttons */
[data-theme="modern"],
[data-theme="modern-dark"] {
--btn-radius: 14px;
--btn-bg: linear-gradient(180deg, rgba(37,99,235,0.96), rgba(29,78,216,0.96));
--btn-bg-hover: linear-gradient(180deg, rgba(29,78,216,0.99), rgba(30,64,175,0.99));
--btn-border: rgba(15,23,42,0.14);
--btn-fg: #ffffff;
--btn-shadow: 0 12px 26px rgba(2,6,23,0.18);
--btn-shadow-hover: 0 16px 34px rgba(2,6,23,0.24);
}

/* Fix incomplete modern-dark theme vars (bg + panel + board + text) */
[data-theme="modern-dark"] {
--text-main: #e5e7eb;
--text-muted: rgba(229,231,235,0.74);
--text-light: #ffffff;
--text-gold: #60a5fa;

--stone-dark: #0b1220;
--stone-medium: #111827;
--stone-light: #1f2937;

--wood-dark: #2563eb;
--wood-medium: #3b82f6;
--wood-light: #60a5fa;

--bg-start: #070b16;
--bg-end: #0b1220;

--panel-bg: rgba(15,23,42,0.72);
--panel-border: rgba(148,163,184,0.18);
--board-surface-light: rgba(15,23,42,0.64);
--parchment-bg: rgba(15,23,42,0.52);
--board-border-dark: rgba(148,163,184,0.22);
--cell-border: rgba(148,163,184,0.16);
}

/* Universal button readability */
button {
border-radius: var(--btn-radius);
background: var(--btn-bg);
color: var(--btn-fg);
border: 1px solid var(--btn-border);
box-shadow: var(--btn-shadow);
max-width: none;
/* important for mobile */
text-shadow: none;
}
button:hover {
background: var(--btn-bg-hover);
box-shadow: var(--btn-shadow-hover);
}
button:active {
transform: translateY(1px);
}
button:focus-visible {
outline: 3px solid rgba(59,130,246,0.45);
outline-offset: 3px;
}
button:disabled {
opacity: 0.58;
filter: saturate(0.9);
cursor: not-allowed;
}
button i, button svg, .toolbar-btn i, .toolbar-btn svg {
color: currentColor;
}

/* Settings entry point: bigger + clearer + persistent label on larger screens */
#settings-fab {
position: relative;
width: auto;
min-width: 48px;
height: 48px;
padding: 0.65rem 0.9rem;
border-radius: 999px;
gap: 0.55rem;
font-size: 0.98rem;
background: rgba(30, 22, 14, 0.82);
border: 1.5px solid rgba(240,200,80,0.40);
box-shadow: 0 4px 18px rgba(0,0,0,0.38), inset 0 1px 0 rgba(255,255,255,0.06);
color: var(--text-gold, #f0c850);
transform: none;
backdrop-filter: blur(8px);
-webkit-backdrop-filter: blur(8px);
transition: background 0.22s ease, box-shadow 0.22s ease, border-color 0.22s ease, transform 0.22s ease;
}
#settings-fab::before {
content: none;
}
#settings-fab:hover {
transform: translateY(-2px);
background: rgba(50, 36, 20, 0.92);
border-color: rgba(240,200,80,0.65);
box-shadow: 0 8px 26px rgba(0,0,0,0.48), 0 0 14px rgba(240,200,80,0.18);
}
#settings-fab.open {
transform: none;
background: rgba(60, 44, 22, 0.96);
border-color: rgba(240,200,80,0.55);
}

.settings-icon {
display: inline-flex;
align-items: center;
justify-content: center;
font-size: 1.15rem;
line-height: 1;
}
.settings-label {
display: none;
font-size: 0.88rem;
font-weight: 800;
letter-spacing: 0.2px;
white-space: nowrap;
}
#settings-fab.open .settings-label {
display: inline;
}
@media (min-width: 640px) {
.settings-label {
display: inline;
}
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce) {
#settings-fab::before {
animation: none;
}
button:active {
transform: none;
}
}

@keyframes settingsPulse {
0% {
transform: scale(0.96);
opacity: 0.55;
}
50% {
transform: scale(1.02);
opacity: 0.95;
}
100% {
transform: scale(0.96);
opacity: 0.55;
}
}

/* Keep the FAB from covering content on phones */
@media (max-width: 720px) {
.game-play-area.active {
padding-bottom: 5.5rem;
}
.toolbar-buttons {
bottom: calc(0.75rem + env(safe-area-inset-bottom));
left: calc(0.75rem + env(safe-area-inset-left));
right: auto !important;
gap: 0.6rem;
}
}

/* Responsive board sizing (only for tablets/phones) */
@media (max-width: 1024px) {
.game-board-container {
width: min(94vw, 72vh, 600px);
}
}
@media (max-width: 640px) {
.game-board-container {
width: min(94vw, 68vh, 560px);
padding: 12px;
border-width: 9px;
}
}
/* Short screens (landscape phones) */
@media (max-height: 680px) {
.game-board-container {
width: min(94vw, 62vh, 560px);
padding: 12px;
border-width: 8px;
}
}

/* Controls: better wrapping on mobile + keep labels visible */
@media (max-width: 760px) {
.controls button {
flex: 1 1 calc(50% - 0.75rem);
min-height: 44px;
}
}
@media (max-width: 480px) {
.controls {
gap: 0.6rem;
}
.controls button {
flex-basis: auto;
padding: 0.65rem 0.75rem;
font-size: 0.78rem;
gap: 6px;
}
/* undo previous rules that were hiding labels */
.controls button span {
display: inline !important;
}
.toolbar-btn span {
display: inline !important;
}
.controls button i {
font-size: 0.98rem;
}
}
@media (max-width: 360px) {
.controls button {
flex: 1 1 100%;
font-size: 0.8rem;
}
}


/* =======================================================================
   UI Placement + Back Button Fix (v4)
   - Move Settings button to a more visible top-right position (with safe-area)
   - Fix "Retour" buttons (style + sticky visibility in scroll panels)
   - Patch a few remaining responsive display issues (dvh, overflow)
   ======================================================================= */

/* Better mobile viewport handling (prevents cut-off on iOS/Android) */
@supports (height: 100dvh) {
body {
min-height: 100dvh;
}
}

/* Selection panels: use dynamic viewport when available */
@supports (max-height: 100dvh) {
.selection-area {
max-height: min(90vh, calc(100dvh - 120px));
}
}

/* SETTINGS: Bottom-left anchor — ne gêne pas le × des règles (haut-droite) */
.toolbar-buttons {
top: auto !important;
left: calc(0.9rem + env(safe-area-inset-left));
right: auto !important;
bottom: calc(0.9rem + env(safe-area-inset-bottom));
flex-direction: column;
/* tray s'ouvre vers le haut */
align-items: flex-start;
z-index: 1200;
}

/* Short screens (landscape phones): same */
@media (max-height: 560px) {
.toolbar-buttons {
bottom: calc(0.5rem + env(safe-area-inset-bottom));
flex-direction: column;
}
}

/* Ensure tray stays readable + doesn't look "floating dark" in modern theme */
.settings-tray {
background: transparent;
}
.settings-tray .toolbar-btn,
.settings-tray .language-selector {
backdrop-filter: blur(10px);
}

/* Toolbar buttons: force high contrast + consistent hit area */
.toolbar-btn {
min-height: 44px;
padding: 0.55rem 0.9rem !important;
background: var(--btn-bg) !important;
color: var(--btn-fg) !important;
border: 1px solid var(--btn-border) !important;
box-shadow: var(--btn-shadow) !important;
}
.toolbar-btn:hover {
background: var(--btn-bg-hover) !important;
box-shadow: var(--btn-shadow-hover) !important;
}
.toolbar-btn span {
display: inline !important;
}

/* Language selector to match toolbar buttons */
.language-selector {
min-height: 44px;
padding: 0.45rem 0.9rem;
border-radius: 999px;
background: var(--btn-bg);
color: var(--btn-fg);
border: 1px solid var(--btn-border);
box-shadow: var(--btn-shadow);
}
.language-selector select,
.language-selector i {
color: inherit !important;
}

/* BACK buttons: make them visible everywhere + modern look */
:root {
--btn-secondary-bg: rgba(0,0,0,0.16);
--btn-secondary-bg-hover: rgba(0,0,0,0.24);
--btn-secondary-fg: var(--text-light);
--btn-secondary-border: rgba(255,255,255,0.22);
}
[data-theme="modern"] {
--btn-secondary-bg: rgba(15,23,42,0.06);
--btn-secondary-bg-hover: rgba(15,23,42,0.10);
--btn-secondary-fg: var(--text-main);
--btn-secondary-border: rgba(15,23,42,0.12);
}
[data-theme="modern-dark"] {
--btn-secondary-bg: rgba(148,163,184,0.10);
--btn-secondary-bg-hover: rgba(148,163,184,0.16);
--btn-secondary-fg: var(--text-main);
--btn-secondary-border: rgba(148,163,184,0.18);
}

.back-btn {
display: inline-flex;
align-items: center;
justify-content: center;
gap: 0.55rem;
min-height: 44px;
padding: 0.65rem 1.1rem;
border-radius: 999px;
background: var(--btn-secondary-bg) !important;
color: var(--btn-secondary-fg) !important;
border: 1px solid var(--btn-secondary-border) !important;
box-shadow: var(--shadow-sm, 0 6px 16px rgba(0,0,0,0.18)) !important;
text-shadow: none !important;
letter-spacing: 0.2px;
margin-top: 1.1rem;
}
.back-btn::before {
content: "←";
font-weight: 900;
line-height: 1;
opacity: 0.9;
}
.back-btn:hover {
background: var(--btn-secondary-bg-hover) !important;
transform: translateY(-1px);
}

/* Keep back buttons visible even when selection area scrolls */
.selection-area .back-btn {
position: sticky;
bottom: 0.75rem;
z-index: 2;
}
.selection-area {
padding-bottom: 4.5rem;
/* space for the sticky back button */
}

/* Prevent text/icon clipping inside small buttons */
button, .toolbar-btn, .back-btn {
line-height: 1.15;
}


/* ============================================================
   REPLAY Dock (modern + subtle)
   ============================================================ */
.sr-only {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0,0,0,0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}

#replay-modal.modal-overlay.app-modal {
  /* ultra léger, pas de gros voile */
  background: rgba(0,0,0,0.18) !important;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  align-items: flex-end !important;
  justify-content: center !important;
  padding: 12px 10px calc(12px + env(safe-area-inset-bottom, 0px)) !important;
}

#replay-modal .replay-modal-content {
  max-width: none !important;
  width: min(680px, 96vw) !important;
  margin: 0 !important;
  border-radius: 18px !important;
  padding: 10px 12px 12px !important;
  background: rgba(18,14,12,0.72) !important;
  border: 1px solid rgba(255,255,255,0.12) !important;
  box-shadow: 0 18px 55px rgba(0,0,0,0.55) !important;
}

.replay-dock {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.replay-dock-top {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}

.replay-pill {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 6px 10px;
  border-radius: 999px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(240,200,80,0.22);
  font-weight: 850;
  color: var(--text-main);
  font-variant-numeric: tabular-nums;
  max-width: 78%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.replay-pill-ico {
  opacity: 0.92;
}

.replay-dock-actions {
  display: inline-flex;
  gap: 8px;
  align-items: center;
}

.replay-ghost-btn {
  all: unset;
  width: 34px;
  height: 34px;
  display: grid;
  place-items: center;
  border-radius: 999px;
  cursor: pointer;
  color: var(--text-main);
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.10);
  font-weight: 900;
  transition: transform 0.12s ease, background 0.15s ease;
}
.replay-ghost-btn:hover {
  transform: translateY(-1px);
  background: rgba(240,200,80,0.12);
}


#replay-exit-btn.replay-ghost-btn,
#replay-info-btn.replay-ghost-btn {
  all: unset !important;
  width: 34px !important;
  height: 34px !important;
  display: grid !important;
  place-items: center !important;
  border-radius: 999px !important;
  cursor: pointer !important;
  color: var(--text-main) !important;
  background: rgba(255,255,255,0.06) !important;
  border: 1px solid rgba(255,255,255,0.10) !important;
  font-weight: 900 !important;
  transition: transform 0.12s ease, background 0.15s ease !important;
}
#replay-exit-btn.replay-ghost-btn:hover,
#replay-info-btn.replay-ghost-btn:hover {
  transform: translateY(-1px) !important;
  background: rgba(240,200,80,0.12) !important;
}
.replay-meta {
  font-size: 0.85rem;
  color: var(--modal-subtext, rgba(255,255,255,0.75)) !important;
  line-height: 1.25;
  padding: 6px 10px;
  border-radius: 12px;
  background: rgba(0,0,0,0.22);
  border: 1px solid rgba(255,255,255,0.08);
}

.replay-range-dock {
  width: 100%;
  margin: 0 !important;
  accent-color: color-mix(in srgb, var(--text-gold) 70%, #fff);
}

.replay-controls-dock {
  margin: 0 !important;
  gap: 8px !important;
  justify-content: space-between !important;
  flex-wrap: nowrap !important;
}

.replay-controls-dock button {
  padding: 0 !important;
  width: 42px;
  height: 38px;
  display: grid;
  place-items: center;
  border-radius: 12px !important;
  background: rgba(255,255,255,0.06) !important;
  border: 1px solid rgba(255,255,255,0.10) !important;
  transition: transform 0.12s ease, background 0.15s ease;
}
.replay-controls-dock button:hover {
  transform: translateY(-1px);
  background: rgba(240,200,80,0.12) !important;
}

.replay-speed-pill {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  height: 38px;
  padding: 0 10px;
  border-radius: 12px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.10);
}
.replay-speed-pill select {
  height: 30px !important;
  padding: 0 28px 0 10px !important;
  border-radius: 10px !important;
  background: transparent !important;
  border: 1px solid rgba(255,255,255,0.12) !important;
  color: var(--text-main) !important;
  font-weight: 800 !important;
  font-size: 0.9rem !important;
}


#replay-step-indicator {
  margin: 0 !important;
  font-size: 0.86rem !important;
  color: var(--text-main) !important;
}
body.replay-active .replay-board-indicator,
body.replay-active .replay-badge {
  display: none !important;
}

/* Stats: version simplifiée */
.stats-simple-note {
  font-size: 0.9rem;
  color: var(--modal-subtext) !important;
  margin: 4px 0 10px;
}
.stats-chips {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin: 6px 0 12px;
}
.stats-chip {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 10px;
  border-radius: 999px;
  background: rgba(0,0,0,0.26);
  border: 1px solid rgba(240,200,80,0.18);
  font-weight: 800;
  font-size: 0.9rem;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.stats-chip .dot {
  width: 10px;
  height: 10px;
  border-radius: 999px;
  flex-shrink: 0;
  background: rgba(255,255,255,0.7);
  box-shadow: 0 0 0 2px rgba(0,0,0,0.25) inset;
}
.stats-rowline {
  margin-top: 8px;
  display: grid;
  grid-template-columns: 1fr;
  gap: 10px;
}
.stats-mini {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  align-items: baseline;
  font-size: 0.95rem;
}
.stats-mini .label { color: var(--modal-subtext) !important; font-weight: 650; }
.stats-mini .value { color: var(--modal-text) !important; font-weight: 900; font-variant-numeric: tabular-nums; }



/* ==================== CAPTURE HIGHLIGHT (ROBUST ACROSS THEMES) ====================
   Some themes (ex: Kabylie) apply cell background styles (e.g., .cell.dark-cell) that
   can override the capturable background when a cell has both classes.
   We force the red emphasis via a pseudo-element overlay + stronger glow/outline.
*/
.cell.capturable{
  background: transparent !important;
  outline: min(0.6vw, 3px) dashed var(--danger-red) !important;
  animation: capturable-pulse 1.6s infinite;
}
.cell.capturable::after{
  content:"";
  position:absolute;
  inset: 0;
  background: rgba(255, 0, 0, 0.18);
  border-radius: 6px;
  pointer-events:none;
  z-index: 1; /* behind the stone (z-index:2) */
  animation: capturable-fill 1.6s infinite;
}
@keyframes capturable-fill{
  0%,100%{ opacity: 0.18; }
  50%{ opacity: 0.42; }
}
/* Override earlier definition to also pulse glow so it's visible on any cell background */
@keyframes capturable-pulse{
  0%,100%{
    outline-color: var(--danger-red);
    box-shadow: 0 0 0 0 rgba(255,0,0,0), inset 0 0 0 0 rgba(255,0,0,0);
  }
  50%{
    outline-color: rgba(255,0,0,0.55);
    box-shadow: 0 0 min(3vw, 14px) rgba(255,0,0,0.55),
                inset 0 0 min(2vw, 10px) rgba(255,0,0,0.25);
  }
}



/* ============================================================
   Online lobby — Design épuré v3
   Mobile-first · 2-col desktop · Premium graphisme
   ============================================================ */

/* ── Variables locales ────────────────────────────────────── */
.online-lobby {
  --ol-gold:      #f0c850;
  --ol-gold-dim:  rgba(240,200,80,0.18);
  --ol-gold-line: rgba(240,200,80,0.22);
  --ol-cyan:      #00e5ff;
  --ol-cyan-dim:  rgba(0,229,255,0.10);
  --ol-green:     #4cde80;
  --ol-surface:   rgba(255,255,255,0.035);
  --ol-surface2:  rgba(255,255,255,0.055);
  --ol-border:    rgba(255,255,255,0.09);
  --ol-border2:   rgba(255,255,255,0.06);
  --ol-radius:    20px;
  --ol-radius-sm: 13px;
  --ol-radius-xs: 9px;
  --ol-trans:     0.2s ease;
  --ol-text-dim:  rgba(245,245,245,0.50);
  --ol-num-color: rgba(240,200,80,0.38);
  padding: clamp(12px, 4vw, 28px) clamp(10px, 4vw, 24px);
  gap: 0;
}
/* Ne pas écraser display:none — flex uniquement quand la section est active */
.selection-area.active.online-lobby {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* ── En-tête ──────────────────────────────────────────────── */
.ol-header {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  margin-bottom: 28px;
  text-align: center;
}
.ol-header-icon {
  width: 48px; height: 48px;
  color: var(--ol-gold);
  opacity: 0.7;
  margin-bottom: 4px;
  animation: ol-pulse 3s ease-in-out infinite;
}
@keyframes ol-pulse {
  0%,100% { opacity: 0.5; transform: scale(1); }
  50%      { opacity: 0.85; transform: scale(1.06); }
}
.ol-title {
  font-size: clamp(1.3rem, 4.5vw, 1.75rem);
  font-weight: 900;
  letter-spacing: -0.01em;
  color: var(--text-main);
  margin: 0;
}
.ol-subtitle {
  font-size: clamp(0.82rem, 2.5vw, 0.92rem);
  color: var(--ol-text-dim);
  max-width: 38ch;
  line-height: 1.5;
  margin: 0;
}
.ol-global-msg {
  font-size: 0.85rem;
  color: var(--ol-cyan);
  min-height: 1.2em;
  margin: 2px 0 0;
  transition: opacity var(--ol-trans);
}
.ol-global-msg:empty { opacity: 0; }

/* ── Layout corps ─────────────────────────────────────────── */
.ol-body {
  width: 100%;
  max-width: 860px;
  display: grid;
  grid-template-columns: 1fr;
  gap: 14px;
}
@media (min-width: 860px) {
  .ol-body {
    grid-template-columns: 1fr 1fr;
    align-items: start;
    gap: 18px;
  }
}

/* ── Sections ─────────────────────────────────────────────── */
.ol-col-setup {
  display: flex;
  flex-direction: column;
  gap: 12px;
}
.ol-section {
  background: var(--ol-surface);
  border: 1px solid var(--ol-border);
  border-radius: var(--ol-radius);
  padding: clamp(16px, 4vw, 22px);
  position: relative;
  overflow: hidden;
  transition: border-color var(--ol-trans);
}
.ol-section::before {
  content: '';
  position: absolute;
  top: 0; left: 20px; right: 20px;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--ol-gold-line), transparent);
  pointer-events: none;
}
.ol-section:focus-within { border-color: rgba(240,200,80,0.32); }

/* ── Labels de section ────────────────────────────────────── */
.ol-section-label {
  display: flex;
  align-items: baseline;
  gap: 10px;
  font-size: 0.72rem;
  font-weight: 900;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: var(--ol-text-dim);
  margin-bottom: 14px;
}
.ol-section-num {
  font-size: 0.65rem;
  font-weight: 900;
  letter-spacing: 0.08em;
  color: var(--ol-num-color);
  font-variant-numeric: tabular-nums;
}

/* ── Input pseudo ─────────────────────────────────────────── */
.ol-input-wrap {
  position: relative;
  display: flex;
  align-items: center;
}
.ol-input-icon {
  position: absolute;
  left: 14px;
  width: 18px; height: 18px;
  color: var(--ol-text-dim);
  pointer-events: none;
  transition: color var(--ol-trans);
}
.ol-input-icon svg { width: 100%; height: 100%; display: block; }
.ol-input {
  width: 100%;
  padding: 14px 14px 14px 44px;
  border-radius: var(--ol-radius-sm);
  border: 1.5px solid var(--ol-border);
  background: rgba(0,0,0,0.28);
  color: var(--text-main);
  font-size: 1rem;
  font-weight: 600;
  outline: none;
  transition: border-color var(--ol-trans), box-shadow var(--ol-trans);
  -webkit-appearance: none;
  min-width: 0;
}
.ol-input::placeholder { color: var(--ol-text-dim); }
.ol-input:focus {
  border-color: rgba(240,200,80,0.55);
  box-shadow: 0 0 0 3px rgba(240,200,80,0.08);
}
.ol-input-wrap:focus-within .ol-input-icon { color: var(--ol-gold); }
.ol-hint {
  margin-top: 8px;
  font-size: 0.78rem;
  color: var(--ol-text-dim);
}

/* ── Boutons d'action Créer / Rejoindre / Récents ─────────── */
.ol-actions {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}
.ol-action-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 16px 10px;
  min-height: 90px;
  border-radius: var(--ol-radius-sm);
  border: 1.5px solid var(--ol-border);
  background: var(--ol-surface);
  color: var(--text-main);
  cursor: pointer;
  text-align: center;
  transition: background var(--ol-trans), border-color var(--ol-trans), transform 0.15s;
  touch-action: manipulation;
  position: relative;
  overflow: hidden;
}
.ol-action-btn::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: inherit;
  opacity: 0;
  transition: opacity var(--ol-trans);
  pointer-events: none;
}
.ol-action-create::after { background: radial-gradient(ellipse at center, rgba(240,200,80,0.12), transparent 70%); }
.ol-action-join::after   { background: radial-gradient(ellipse at center, rgba(0,229,255,0.10), transparent 70%); }
.ol-action-recent::after { background: radial-gradient(ellipse at center, rgba(76,222,128,0.10), transparent 70%); }
.ol-action-btn:hover { transform: translateY(-2px); border-color: rgba(255,255,255,0.18); }
.ol-action-btn:hover::after { opacity: 1; }
.ol-action-btn:active { transform: translateY(0); }
.ol-action-btn.active {
  border-color: rgba(240,200,80,0.5);
  background: rgba(240,200,80,0.07);
}
.ol-action-icon {
  width: 26px; height: 26px;
  color: var(--ol-text-dim);
}
.ol-action-icon svg { width: 100%; height: 100%; display: block; }
.ol-action-create .ol-action-icon { color: var(--ol-gold); }
.ol-action-join   .ol-action-icon { color: var(--ol-cyan); }
.ol-action-recent .ol-action-icon { color: var(--ol-green); }
.ol-action-main {
  font-size: 0.88rem;
  font-weight: 800;
  line-height: 1.2;
}
.ol-action-sub {
  font-size: 0.72rem;
  color: var(--ol-text-dim);
  line-height: 1.2;
}
@media (max-width: 380px) { .ol-action-sub { display: none; } }

/* ── Panneaux accordéon ───────────────────────────────────── */
.ol-panel {
  overflow: hidden;
  max-height: 0;
  transition: max-height 0.35s cubic-bezier(.4,0,.2,1), opacity 0.28s;
  opacity: 0;
  margin-top: 0;
}
.ol-panel.open {
  max-height: 600px;
  opacity: 1;
  margin-top: 12px;
}

/* ── Panneau Créer ────────────────────────────────────────── */
.ol-preview-box {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 14px;
  padding: 20px;
  border-radius: var(--ol-radius-sm);
  background: rgba(240,200,80,0.05);
  border: 1px solid rgba(240,200,80,0.28);
}
.ol-preview-label {
  font-size: 0.78rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: var(--ol-text-dim);
}
.ol-preview-code-wrap {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}
.ol-preview-code {
  font-size: clamp(2rem, 8vw, 2.8rem);
  font-weight: 900;
  letter-spacing: 0.3em;
  color: var(--ol-gold);
  text-shadow: 0 0 32px rgba(240,200,80,0.45);
  font-variant-numeric: tabular-nums;
}
.ol-preview-dots { display: flex; gap: 6px; }
.ol-preview-dots span {
  width: 6px; height: 6px;
  border-radius: 50%;
  background: var(--ol-gold);
  opacity: 0.4;
  animation: ol-dot-blink 1.4s ease-in-out infinite;
}
.ol-preview-dots span:nth-child(2) { animation-delay: 0.2s; }
.ol-preview-dots span:nth-child(3) { animation-delay: 0.4s; }
.ol-preview-dots span:nth-child(4) { animation-delay: 0.6s; }
@keyframes ol-dot-blink {
  0%,80%,100% { opacity: 0.25; }
  40%          { opacity: 0.9; }
}
.ol-confirm-btn {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 12px 24px;
  border-radius: var(--ol-radius-sm);
  border: 1.5px solid rgba(240,200,80,0.55);
  background: rgba(240,200,80,0.12);
  color: var(--ol-gold);
  font-weight: 900;
  font-size: 0.92rem;
  cursor: pointer;
  transition: background var(--ol-trans), transform 0.15s;
  touch-action: manipulation;
  width: 100%;
  justify-content: center;
}
.ol-confirm-btn svg { width: 16px; height: 16px; flex-shrink: 0; }
.ol-confirm-btn:hover { background: rgba(240,200,80,0.22); transform: translateY(-1px); }

/* ── Panneau Rejoindre ────────────────────────────────────── */
.ol-join-wrap { padding: 4px 0; }
.ol-join-label {
  font-size: 0.72rem;
  font-weight: 800;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: var(--ol-text-dim);
  margin-bottom: 10px;
}
.ol-code-row {
  display: flex;
  gap: 8px;
  align-items: stretch;
}
.ol-code-input,
.online-code-input.ol-code-input {
  flex: 1;
  min-width: 0;
  padding: 16px 12px;
  border-radius: var(--ol-radius-sm);
  border: 1.5px solid var(--ol-border);
  background: rgba(0,0,0,0.30);
  color: var(--text-main);
  outline: none;
  font-size: clamp(1.4rem, 5vw, 1.75rem);
  font-weight: 900;
  letter-spacing: 0.32em;
  text-transform: uppercase;
  text-align: center;
  transition: border-color var(--ol-trans), box-shadow var(--ol-trans);
  -webkit-appearance: none;
  caret-color: var(--ol-gold);
}
.ol-code-input::placeholder { color: rgba(255,255,255,0.18); letter-spacing: 0.18em; }
.ol-code-input:focus {
  border-color: rgba(240,200,80,0.55);
  box-shadow: 0 0 0 3px rgba(240,200,80,0.08);
}
.ol-code-input.input-valid { border-color: rgba(76,222,128,0.65); }
.ol-code-input.input-error {
  border-color: rgba(255,80,80,0.75);
  animation: ol-shake .3s ease;
}
@keyframes ol-shake {
  0%,100% { transform: translateX(0) }
  25%     { transform: translateX(-4px) }
  75%     { transform: translateX(4px) }
}
.ol-connect-btn {
  flex-shrink: 0;
  width: 52px;
  border-radius: var(--ol-radius-sm);
  border: none;
  background: linear-gradient(135deg, #f0c850, #c89628);
  color: #1a0e04;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.15s, filter 0.15s, opacity var(--ol-trans);
  touch-action: manipulation;
}
.ol-connect-btn svg { width: 20px; height: 20px; }
.ol-connect-btn:hover { transform: translateY(-2px); filter: brightness(1.1); }
.ol-connect-btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }

/* ── Panneau Récents ──────────────────────────────────────── */
.ol-recent-header {
  font-size: 0.72rem;
  font-weight: 900;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: var(--ol-text-dim);
  margin-bottom: 10px;
}
.online-recent-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.online-room-chip {
  display: grid;
  grid-template-columns: auto 1fr auto auto;
  align-items: center;
  gap: 10px;
  padding: 11px 14px;
  border-radius: var(--ol-radius-sm);
  border: 1px solid var(--ol-border);
  background: var(--ol-surface);
  color: var(--text-main);
  cursor: pointer;
  text-align: left;
  transition: background var(--ol-trans), border-color var(--ol-trans);
  width: 100%;
  min-height: 48px;
  touch-action: manipulation;
}
.online-room-chip:hover { background: var(--ol-surface2); border-color: rgba(240,200,80,0.35); }
.online-room-chip .chip-code { font-weight: 900; letter-spacing: 0.18em; color: var(--ol-gold); font-size: 0.9rem; }
.online-room-chip .chip-vs { font-size: 0.82rem; font-weight: 700; opacity: 0.8; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.online-room-chip .chip-vs em { font-style: normal; opacity: 0.55; }
.online-room-chip .chip-result { font-size: 1rem; }
.online-room-chip .chip-date { font-size: 0.7rem; opacity: 0.5; white-space: nowrap; font-weight: 700; }

/* ── Colonne statut ───────────────────────────────────────── */
.ol-col-status {
  background: var(--ol-surface);
  border: 1px solid var(--ol-border);
  border-radius: var(--ol-radius);
  padding: clamp(16px, 4vw, 22px);
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  gap: 0;
}
.ol-col-status::before {
  content: '';
  position: absolute;
  top: 0; left: 20px; right: 20px;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--ol-gold-line), transparent);
  pointer-events: none;
}

/* ── Bannière de statut ─────────────────────────────────── */
.ol-status-banner {
  display: flex;
  align-items: center;
  gap: 10px;
  padding-bottom: 14px;
  border-bottom: 1px solid var(--ol-border2);
  margin-bottom: 16px;
}
.ol-status-dot {
  width: 10px; height: 10px;
  border-radius: 50%;
  background: var(--ol-text-dim);
  flex-shrink: 0;
  transition: background var(--ol-trans), box-shadow var(--ol-trans);
}
.ol-status-dot.connecting {
  background: var(--ol-gold);
  animation: ol-blink-dot 1s ease-in-out infinite;
}
.ol-status-dot.connected {
  background: var(--ol-green);
  box-shadow: 0 0 8px rgba(76,222,128,0.6);
  animation: none;
}
@keyframes ol-blink-dot {
  0%,100% { opacity: 0.4; }
  50%      { opacity: 1; }
}
.ol-status-text {
  font-size: 0.9rem;
  font-weight: 700;
  color: var(--text-main);
  line-height: 1.35;
}

/* ── Slots joueurs ────────────────────────────────────────── */
.ol-players {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  align-items: center;
  gap: 8px;
  margin-bottom: 16px;
}
.ol-player {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 14px 10px;
  border-radius: var(--ol-radius-sm);
  border: 1px dashed rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.15);
  text-align: center;
  position: relative;
  transition: border-color var(--ol-trans), background var(--ol-trans);
}
.ol-player.online-connected {
  border-style: solid;
  border-color: rgba(76,222,128,0.4);
  background: rgba(76,222,128,0.05);
}
.ol-player-avatar {
  width: 38px; height: 38px;
  border-radius: 50%;
  background: var(--ol-gold-dim);
  border: 1.5px solid rgba(240,200,80,0.35);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--ol-gold);
}
.ol-player-avatar svg { width: 20px; height: 20px; display: block; }
.ol-player-tag {
  font-size: 0.65rem;
  font-weight: 900;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--ol-text-dim);
}
.ol-player-name {
  font-size: 0.88rem;
  font-weight: 800;
  color: var(--text-main);
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  min-width: 0;
}
.ol-player-status-dot {
  position: absolute;
  top: 8px; right: 8px;
  width: 7px; height: 7px;
  border-radius: 50%;
  background: rgba(255,255,255,0.18);
  transition: background var(--ol-trans);
}
.ol-player.online-connected .ol-player-status-dot {
  background: var(--ol-green);
  box-shadow: 0 0 6px rgba(76,222,128,0.7);
}
.ol-versus {
  font-size: 0.7rem;
  font-weight: 900;
  letter-spacing: 0.08em;
  color: var(--ol-text-dim);
  text-align: center;
}

/* ── Bloc partage ─────────────────────────────────────────── */
.ol-share-block {
  border-top: 1px solid var(--ol-border2);
  padding-top: 14px;
  margin-bottom: 14px;
}
.ol-share-label {
  font-size: 0.72rem;
  font-weight: 900;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: var(--ol-text-dim);
  margin-bottom: 10px;
}
.ol-share-code-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}
.ol-share-code {
  font-size: clamp(1.6rem, 5vw, 2rem);
  font-weight: 900;
  letter-spacing: 0.28em;
  color: var(--ol-gold);
  text-shadow: 0 0 28px rgba(240,200,80,0.38);
  flex: 1;
}
.ol-icon-btn {
  width: 38px; height: 38px;
  border-radius: var(--ol-radius-xs);
  border: 1px solid var(--ol-border);
  background: var(--ol-surface);
  color: var(--text-main);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  flex-shrink: 0;
  transition: background var(--ol-trans), border-color var(--ol-trans);
  touch-action: manipulation;
}
.ol-icon-btn svg { width: 16px; height: 16px; display: block; }
.ol-icon-btn:hover { background: var(--ol-surface2); border-color: rgba(255,255,255,0.18); }

.ol-invite-toggle {
  width: 100%;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 11px 14px;
  border-radius: var(--ol-radius-sm);
  border: 1px solid var(--ol-border);
  background: var(--ol-surface);
  color: var(--ol-cyan);
  font-size: 0.88rem;
  font-weight: 800;
  cursor: pointer;
  transition: background var(--ol-trans), border-color var(--ol-trans);
  touch-action: manipulation;
}
.ol-invite-toggle svg:first-child { width: 16px; height: 16px; flex-shrink: 0; }
.ol-invite-toggle span { flex: 1; text-align: left; }
.ol-chevron { width: 12px; height: 12px; flex-shrink: 0; transition: transform var(--ol-trans); }
.ol-invite-toggle[aria-expanded="true"] .ol-chevron { transform: rotate(180deg); }
.ol-invite-toggle:hover { background: var(--ol-cyan-dim); border-color: rgba(0,229,255,0.3); }

.ol-invite-panel {
  overflow: hidden;
  max-height: 0;
  opacity: 0;
  transition: max-height 0.3s ease, opacity 0.25s;
}
.ol-invite-panel.open { max-height: 300px; opacity: 1; margin-top: 8px; }
.ol-invite-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 9px 0;
  border-bottom: 1px solid var(--ol-border2);
}
.ol-invite-row:last-child { border-bottom: none; }
.ol-inv-label {
  font-size: 0.78rem;
  color: var(--ol-text-dim);
  font-weight: 700;
  white-space: nowrap;
  min-width: 40px;
}
.ol-inv-value {
  flex: 1;
  font-size: 0.8rem;
  font-weight: 700;
  color: var(--ol-gold);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  min-width: 0;
  padding: 0 4px;
}
.ol-inv-btn {
  padding: 5px 12px;
  border-radius: var(--ol-radius-xs);
  border: 1px solid var(--ol-gold-line);
  background: var(--ol-gold-dim);
  color: var(--ol-gold);
  font-weight: 800;
  font-size: 0.78rem;
  cursor: pointer;
  white-space: nowrap;
  flex-shrink: 0;
  touch-action: manipulation;
  transition: background var(--ol-trans);
}
.ol-inv-btn:hover { background: rgba(240,200,80,0.28); }
.ol-inv-btn.copied { background: rgba(76,222,128,0.16); border-color: rgba(76,222,128,0.5); color: var(--ol-green); }

/* ── Revanche ─────────────────────────────────────────────── */
.ol-rematch {
  border: 1px solid var(--ol-border);
  border-radius: var(--ol-radius-sm);
  padding: 14px;
  background: rgba(0,0,0,0.15);
  margin-bottom: 14px;
}
.ol-rematch-title {
  font-size: 0.72rem;
  font-weight: 900;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--ol-text-dim);
  margin-bottom: 10px;
}
.ol-rematch-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
}
.ol-rematch-chip {
  flex: 1;
  padding: 7px 10px;
  border-radius: var(--ol-radius-xs);
  border: 1px solid var(--ol-border);
  background: var(--ol-surface);
  font-weight: 900;
  font-size: 0.82rem;
  color: var(--text-main);
  text-align: center;
  transition: all var(--ol-trans);
}
.ol-rematch-chip.ready {
  border-color: rgba(76,222,128,0.5);
  background: rgba(76,222,128,0.10);
  color: var(--ol-green);
}
.ol-rematch-divider { color: var(--ol-text-dim); font-size: 1.2rem; }
.ol-rematch-btn {
  width: 100%;
  padding: 12px;
  border-radius: var(--ol-radius-sm);
  border: 1.5px solid rgba(240,200,80,0.35);
  background: var(--ol-gold-dim);
  color: var(--ol-gold);
  font-weight: 900;
  font-size: 0.9rem;
  cursor: pointer;
  touch-action: manipulation;
  transition: background var(--ol-trans), transform 0.15s;
}
.ol-rematch-btn:hover { background: rgba(240,200,80,0.28); transform: translateY(-1px); }
.ol-rematch-btn.active {
  border-color: rgba(76,222,128,0.55);
  background: rgba(76,222,128,0.12);
  color: var(--ol-green);
}
.ol-rematch-note {
  margin-top: 8px;
  font-size: 0.76rem;
  color: var(--ol-text-dim);
  text-align: center;
}

/* ── Bouton Lancer ────────────────────────────────────────── */
.ol-start-btn {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding: 15px 20px;
  border-radius: var(--ol-radius-sm);
  border: none;
  background: linear-gradient(135deg, #f0c850, #c89628);
  color: #1a0e04;
  font-weight: 900;
  cursor: pointer;
  touch-action: manipulation;
  transition: transform 0.15s, filter 0.15s, opacity var(--ol-trans);
  box-shadow: 0 6px 24px rgba(240,200,80,0.28);
  position: relative;
  overflow: hidden;
  margin-top: auto;
}
.ol-start-btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(255,255,255,0.15), transparent);
  pointer-events: none;
}
.ol-start-btn:hover { transform: translateY(-2px); filter: brightness(1.07); }
.ol-start-btn:active { transform: translateY(0); }
.ol-start-btn:disabled { opacity: 0.45; cursor: not-allowed; transform: none; }
.ol-start-icon {
  width: 22px; height: 22px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}
.ol-start-icon svg { width: 100%; height: 100%; display: block; }
.ol-start-text {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 1px;
}
.ol-start-sub {
  font-size: 0.72rem;
  font-weight: 700;
  opacity: 0.7;
}

/* ── Thèmes clairs ────────────────────────────────────────── */
[data-theme="kabylie"] .online-lobby,
[data-theme="desert"]  .online-lobby {
  --ol-surface:  rgba(0,0,0,0.04);
  --ol-surface2: rgba(0,0,0,0.08);
  --ol-border:   rgba(0,0,0,0.10);
  --ol-border2:  rgba(0,0,0,0.07);
  --ol-text-dim: rgba(30,22,10,0.48);
}
[data-theme="kabylie"] .ol-input,
[data-theme="desert"]  .ol-input,
[data-theme="kabylie"] .ol-code-input,
[data-theme="desert"]  .ol-code-input { background: rgba(255,255,255,0.65); color: #1a1208; }
[data-theme="kabylie"] .ol-player,
[data-theme="desert"]  .ol-player { background: rgba(0,0,0,0.04); }
[data-theme="kabylie"] .ol-rematch,
[data-theme="desert"]  .ol-rematch { background: rgba(0,0,0,0.03); }

</style>
<style nonce="tiddas">
/* =========================================================
   TIDDAS v6 – Pack UI/UX + Gameplay + Produit additions
   (single-file patch)
   ========================================================= */

/* Improve touch on mobile */
button, .toolbar-btn, .cell {
touch-action: manipulation;
}

/* Better keyboard focus */
.cell:focus-visible, button:focus-visible, select:focus-visible {
outline: 3px solid rgba(240,200,80,0.95);
outline-offset: 2px;
}

/* Last action highlights */
.cell.last-move-from {
box-shadow: inset 0 0 0 2px rgba(99,164,255,0.95), 0 0 18px rgba(99,164,255,0.35);
}
.cell.last-move-to {
box-shadow: inset 0 0 0 2px rgba(0,255,255,0.95), 0 0 18px rgba(0,255,255,0.35);
}
.cell.last-capture {
box-shadow: inset 0 0 0 2px rgba(255,77,77,0.98), 0 0 18px rgba(255,77,77,0.35);
}

/* Pion sur le point d'être capturé – mise en évidence avant suppression */
.cell.capture-pending {
box-shadow: inset 0 0 0 3px rgba(255,60,60,1), 0 0 28px rgba(255,60,60,0.75);
z-index: 2;
position: relative;
}
.cell.capture-pending .stone {
animation: capturePendingPulse 0.45s ease-in-out infinite !important;
filter: drop-shadow(0 0 12px rgba(255, 50, 50, 1)) !important;
outline: 3px solid rgba(255,60,60,0.95);
outline-offset: 2px;
}
@keyframes capturePendingPulse {
0%, 100% {
transform: scale(1);
opacity: 1;
}
50% {
transform: scale(1.18);
opacity: 0.75;
}
}
@media (prefers-reduced-motion: reduce) {
.cell.capture-pending .stone {
animation: none !important;
}
}

/* ── MODE GLISSER-DÉPOSER ── */

/* Empêche le scroll/zoom pendant le drag (mobile) + évite la sélection de texte */
.drag-mode-active {
touch-action: none;
-webkit-user-select: none;
user-select: none;
}
.drag-mode-active .cell,
.drag-mode-active .stone {
touch-action: none;
}


/* Pion en cours de glissement : semi-transparent, légèrement réduit */
.stone.dragging {
opacity: 0.35;
transform: scale(0.85);
transition: opacity 0.12s ease, transform 0.12s ease;
filter: brightness(0.7) !important;
}

/* Case cible valide survolée pendant le glissement */
.cell.drag-over {
background: rgba(240, 200, 80, 0.38) !important;
outline: 3px solid var(--text-gold) !important;
box-shadow: inset 0 0 18px rgba(240, 200, 80, 0.65), 0 0 22px rgba(240, 200, 80, 0.45) !important;
z-index: 5;
}

/* Curseur grab sur les pions déplaçables en mode drag */
.drag-mode-active .cell[data-draggable="true"] {
cursor: grab;
}
.drag-mode-active .cell[data-draggable="true"]:active {
cursor: grabbing;
}

/* Ghost : pion fantôme qui suit le curseur */
#drag-ghost {
position: fixed;
pointer-events: none;
z-index: 9999;
left: 0;
top: 0;
width: 48px;
height: 48px;
border-radius: 50%;
opacity: 0.85;
/* Positionnement via transform = composite GPU, zéro reflow */
transform: translate(-9999px, -9999px) scale(1.15);
will-change: transform;
box-shadow: 0 8px 24px rgba(0,0,0,0.55), inset 0 -5px 12px rgba(0,0,0,0.4), inset 0 5px 10px rgba(255,255,255,0.3);
display: none;
transition: none;
}
#drag-ghost.visible {
display: block;
}
#drag-ghost.player1 {
background: radial-gradient(circle at 35% 35%, var(--player1-stone-color-light), var(--player1-stone-color-dark) 60%, #000 90%);
}
#drag-ghost.player2 {
background: radial-gradient(circle at 35% 35%, var(--player2-stone-color-light), var(--player2-stone-color-dark) 60%, #e0e0e0 90%);
}

/* Bouton drag actif dans la tray */
#drag-btn.active {
background: linear-gradient(145deg, rgba(240,200,80,0.28), rgba(240,200,80,0.14)) !important;
border-color: rgba(240,200,80,0.75) !important;
color: var(--text-gold) !important;
}

@media (prefers-reduced-motion: reduce) {
.stone.dragging {
transition: none;
}
}

/* Guided mode pulsing pieces */
.stone.hint-piece {
animation: tiddasHintPulse 1.05s ease-in-out infinite;
filter: drop-shadow(0 0 10px rgba(240,200,80,0.25));
}
@keyframes tiddasHintPulse {
0%,100% {
transform: scale(1);
}
50% {
transform: scale(1.06);
}
}

/* Toasts */
.toast {
position: fixed;
left: 50%;
transform: translateX(-50%) translateY(12px);
bottom: calc(16px + env(safe-area-inset-bottom, 0px));
background: rgba(0,0,0,0.82);
border: 1px solid rgba(240,200,80,0.35);
color: var(--text-main);
padding: 10px 14px;
border-radius: 14px;
max-width: min(92vw, 720px);
width: fit-content;
opacity: 0;
pointer-events: none;
z-index: 6500;
transition: opacity 0.22s ease, transform 0.22s ease;
font-size: 0.92rem;
line-height: 1.25;
}
.toast.show {
opacity: 1;
transform: translateX(-50%) translateY(0);
}
.toast .toast-strong {
color: var(--text-gold);
font-weight: 700;
}

/* App modals (Stats / Replay / Install help) */
.modal-overlay.app-modal {
z-index: 6000;
}
.modal-content.stats-modal-content,
.modal-content.replay-modal-content,
.modal-content.install-modal-content {
max-width: 760px;
text-align: left;
}
.modal-content.stats-modal-content h3,
.modal-content.replay-modal-content h3,
.modal-content.install-modal-content h3 {
text-align: center;
}
.stats-grid {
display: grid;
grid-template-columns: repeat(2, minmax(0, 1fr));
gap: 10px;
margin: 10px 0 14px;
}
.stat-card {
background: rgba(0,0,0,0.30);
border: 1px solid rgba(240,200,80,0.22);
border-radius: 12px;
padding: 10px 12px;
}
.stat-card .k {
font-size: 0.78rem;
opacity: 0.85;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.stat-card .v {
font-size: 1.12rem;
font-weight: 800;
color: var(--text-gold);
margin-top: 4px;
}

/* Sections + historique (STATS v2) */
.stats-section-title {
  margin: 14px 0 8px;
  display: flex;
  align-items: center;
  gap: 10px;
  font-weight: 850;
  color: var(--modal-heading) !important;
  font-size: 0.92rem;
  letter-spacing: 0.4px;
  text-transform: uppercase;
}
.stats-section-title:after {
  content: "";
  flex: 1;
  height: 1px;
  background: linear-gradient(90deg, var(--stat-border-c), transparent);
}
.stats-rows {
  margin-top: 6px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.stats-row {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  gap: 10px;
  font-size: 0.92rem;
}
.stats-row .label {
  color: var(--modal-subtext) !important;
  font-weight: 650;
}
.stats-row .value {
  color: var(--modal-text) !important;
  font-weight: 850;
  font-variant-numeric: tabular-nums;
}
.history-list {
  margin-top: 8px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.history-item {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid var(--stat-border-c);
  background: var(--stat-surface) !important;
}
.history-item .h-left {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0;
}
.history-item .h-title {
  font-weight: 850;
  font-size: 0.94rem;
  color: var(--modal-text) !important;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.history-item .h-sub {
  font-size: 0.78rem;
  color: var(--modal-subtext) !important;
  font-weight: 650;
  line-height: 1.25;
}
.history-item .h-right {
  text-align: right;
  font-variant-numeric: tabular-nums;
  flex-shrink: 0;
}
.history-item .h-dur {
  font-weight: 850;
  font-size: 0.9rem;
  color: var(--modal-text) !important;
}
.history-item .h-mode {
  font-size: 0.76rem;
  color: var(--modal-subtext) !important;
  font-weight: 700;
}


.progress-bar {
height: 10px;
border-radius: 999px;
background: rgba(255,255,255,0.10);
overflow: hidden;
border: 1px solid rgba(240,200,80,0.20);
}
.progress-bar > div {
height: 100%;
width: 0%;
background: linear-gradient(90deg, rgba(240,200,80,0.35), rgba(0,255,255,0.35));
}

/* Replay controls */
.replay-controls {
display: flex;
gap: 8px;
justify-content: center;
align-items: center;
flex-wrap: wrap;
margin: 10px 0 8px;
}
.replay-controls button {
padding: 0.65rem 0.85rem;
border-radius: 999px;
border: 1px solid rgba(240,200,80,0.25);
background: rgba(0,0,0,0.30);
color: var(--text-main);
}
.replay-controls button:hover {
background: rgba(240,200,80,0.12);
}

.replay-range {
width: 100%;
margin: 8px 0 6px;
}
.replay-meta {
  display: none !important;
}
.replay-footer {
  display: flex !important;
  align-items: center !important;
  justify-content: flex-end !important;
  gap: 8px !important;
  flex-wrap: nowrap !important;
  margin: 0 !important;
  padding-top: 0.2rem !important;
  border-top: none !important;
}
.replay-footer label span { display: none !important; }

.replay-footer label {
font-size: 0.9rem;
opacity: 0.95;
}
.replay-footer select {
background: rgba(0,0,0,0.35);
border: 1px solid rgba(240,200,80,0.25);
color: var(--text-main);
border-radius: 9px;
padding: 6px 10px;
}

/* Winner overlay extra buttons */
.replay-button.secondary {
font-size: 0.55em;
padding: 0.5em 1.2em;
opacity: 0.92;
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce) {
.stone.hint-piece {
animation: none;
}
.toast {
transition: none;
}
}

/* =====================================================================
   LANGUAGE SPLASH SCREEN
   ===================================================================== */
#lang-splash {
position: fixed;
inset: 0;
z-index: 9999;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
background: linear-gradient(145deg, #1e1710, #2c2218, #1a140e);
padding: clamp(1.2rem, 5vw, 3rem);
animation: splashFadeIn 0.5s ease;
overflow: hidden;
}
#lang-splash::before {
content: '';
position: absolute;
inset: 0;
background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="none" stroke="%234a3d35" stroke-width="2" opacity="0.12"/></svg>');
background-size: 80px;
pointer-events: none;
}
#lang-splash.hidden {
animation: splashFadeOut 0.45s ease forwards;
pointer-events: none;
}
@keyframes splashFadeIn {
from {
opacity: 0;
transform: scale(1.04);
}
to {
opacity: 1;
transform: scale(1);
}
}
@keyframes splashFadeOut {
from {
opacity: 1;
transform: scale(1);
}
to {
opacity: 0;
transform: scale(0.97);
}
}
.splash-logo {
font-family: var(--font-title);
font-size: clamp(2.6rem, 9vw, 5rem);
font-weight: 800;
color: var(--text-gold);
letter-spacing: .22em;
text-shadow: 0 4px 20px rgba(240,200,80,.35), 3px 3px 8px rgba(0,0,0,.7);
text-transform: uppercase;
line-height: 1;
text-align: center;
}
.splash-tifinagh {
font-size: clamp(1rem, 3vw, 1.4rem);
letter-spacing: .5em;
color: var(--text-gold);
opacity: .55;
margin-top: .35em;
margin-bottom: 2.5rem;
text-align: center;
}
.splash-divider {
width: min(220px, 60vw);
height: 1px;
background: linear-gradient(90deg, transparent, rgba(240,200,80,.65), transparent);
margin-bottom: 1.8rem;
}
.splash-prompt {
font-size: clamp(.9rem, 2.5vw, 1.1rem);
color: rgba(245,245,245,.6);
margin-bottom: 1.8rem;
text-align: center;
letter-spacing: .05em;
}
.splash-langs {
display: flex;
gap: clamp(.8rem, 3vw, 2rem);
flex-wrap: wrap;
justify-content: center;
width: 100%;
max-width: 520px;
}
.splash-lang-btn {
flex: 1;
min-width: min(200px, 38vw);
max-width: 260px;
padding: clamp(1rem, 4vw, 1.8rem) clamp(.8rem, 3vw, 1.4rem);
background: rgba(0,0,0,.4);
border: 2px solid rgba(240,200,80,.35);
border-radius: 20px;
cursor: pointer;
transition: all .28s cubic-bezier(.2,.9,.2,1);
display: flex;
flex-direction: column;
align-items: center;
gap: .7rem;
backdrop-filter: blur(8px);
box-shadow: 0 8px 24px rgba(0,0,0,.4);
color: var(--text-main);
font-family: var(--font-ui);
text-align: center;
}
.splash-lang-btn:hover {
border-color: var(--text-gold);
background: rgba(240,200,80,.12);
transform: translateY(-6px) scale(1.03);
box-shadow: 0 16px 40px rgba(0,0,0,.5), 0 0 30px rgba(240,200,80,.35);
}
.splash-lang-btn:active {
transform: translateY(-2px) scale(1.01);
}
.splash-lang-flag {
display: inline-flex;
align-items: center;
justify-content: center;
width: clamp(3.1rem, 8vw, 3.6rem);
height: clamp(3.1rem, 8vw, 3.6rem);
border-radius: 999px;
border: 2px solid rgba(240,200,80,.35);
background: rgba(0,0,0,.22);
box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
font-size: clamp(1.55rem, 5vw, 2.35rem);
line-height: 1;
font-weight: 800;
letter-spacing: .08em;
}
.splash-lang-name {
font-size: clamp(1.1rem, 3.5vw, 1.5rem);
font-weight: 700;
color: var(--text-gold);
letter-spacing: .06em;
}
.splash-lang-sub {
font-size: clamp(.75rem, 2vw, .9rem);
color: rgba(245,245,245,.55);
line-height: 1.4;
}
.splash-footer {
position: absolute;
bottom: 1.2rem;
font-size: .75rem;
color: rgba(245,245,245,.22);
letter-spacing: .08em;
text-align: center;
}
</style>
<style nonce="tiddas">
/* =========================================================
   TIDDAS v9.2 – Cleanup patch (auto-generated)
   - Fix invalid min()/vh arithmetic
   - Improve mobile viewport handling (dvh)
   - Reduce theme conflicts by making components rely on CSS vars
   ========================================================= */

/* Make viewport height stable on mobile browsers */
:root {
--app-dvh: 100vh;
}
@supports (height: 100dvh) {
:root {
--app-dvh: 100dvh;
}
}

/* Normalize the main container sizing */
:root[data-theme] body {
min-height: var(--app-dvh);
}

/* Ensure board sizing stays valid everywhere (desktop + mobile) */
:root[data-theme] .game-board-container {
width: min(95vw, calc(95vh - 10rem), 600px);
width: min(95vw, calc(95dvh - 10rem), 600px);
}

/* Components should be driven by vars; give them a consistent baseline */
:root[data-theme] .selection-area,
:root[data-theme] .player-setup-area,
:root[data-theme] .game-play-area,
:root[data-theme] .move-history-panel,
:root[data-theme] .version-card,
:root[data-theme] .mode-card,
:root[data-theme] .difficulty-card {
background: var(--panel-bg, rgba(255,255,255,0.92));
border: 1px solid var(--panel-border, rgba(0,0,0,0.18));
}

/* Respect safe areas on modern phones */
:root[data-theme] .toolbar-buttons {
padding-bottom: env(safe-area-inset-bottom);
}
</style>
<style nonce="tiddas">
/* ═══════════════════════════════════════════════════════════════════
   TIDDAS — PATCH GLOBAL : REPLAY FLOTTANT + VISIBILITÉ THÈMES
   ═══════════════════════════════════════════════════════════════════ */

/* ────────────────────────────────────────────────────────────────
   1. TOKENS UNIVERSELS PAR THÈME (modale + stat-cards)
   ──────────────────────────────────────────────────────────────── */
:root {
/* Thème sombre par défaut */
--modal-surface: linear-gradient(160deg, #3a2d25 0%, #2a201a 100%);
--modal-text: rgba(245,245,245,0.94);
--modal-subtext: rgba(245,245,245,0.68);
--modal-heading: #f0c850;
--modal-border: rgba(240,200,80,0.45);

--stat-surface: rgba(255,255,255,0.07);
--stat-border-c: rgba(240,200,80,0.18);
--stat-label: rgba(245,235,200,0.70);
--stat-value: #f0c850;
--stat-misc-text: rgba(245,235,200,0.82);
}

[data-theme="nuit"] {
--modal-surface: linear-gradient(160deg, #0e0b22 0%, #08061a 100%);
--modal-text: rgba(240,234,255,0.94);
--modal-subtext: rgba(240,234,255,0.60);
--modal-heading: #bb86fc;
--modal-border: rgba(187,134,252,0.38);
--stat-surface: rgba(187,134,252,0.10);
--stat-border-c: rgba(187,134,252,0.20);
--stat-label: rgba(240,234,255,0.58);
--stat-value: #bb86fc;
--stat-misc-text: rgba(240,234,255,0.78);
}

[data-theme="glass"] {
--modal-surface: linear-gradient(160deg, rgba(30,15,60,0.88), rgba(15,8,40,0.92));
--modal-text: rgba(240,234,255,0.96);
--modal-subtext: rgba(240,234,255,0.62);
--modal-heading: #e8b4f8;
--modal-border: rgba(232,180,248,0.38);
--stat-surface: rgba(255,255,255,0.08);
--stat-border-c: rgba(232,180,248,0.20);
--stat-label: rgba(240,234,255,0.58);
--stat-value: #e8b4f8;
--stat-misc-text: rgba(240,234,255,0.78);
}

[data-theme="desert"] {
--modal-surface: linear-gradient(160deg, #fffbf0 0%, #fff3d8 100%);
--modal-text: #2a1e0a;
--modal-subtext: #6a5540;
--modal-heading: #8a4500;
--modal-border: rgba(122,58,10,0.28);
--stat-surface: rgba(122,58,10,0.07);
--stat-border-c: rgba(122,58,10,0.14);
--stat-label: #7a6050;
--stat-value: #8a4500;
--stat-misc-text: #5a4030;
}

[data-theme="kabylie"] {
--modal-surface: linear-gradient(160deg, #ffffff 0%, #f4f8ff 100%);
--modal-text: #1a1612;
--modal-subtext: #4a4a5a;
--modal-heading: #1565c0;
--modal-border: rgba(21,101,192,0.25);
--stat-surface: rgba(30,136,229,0.06);
--stat-border-c: rgba(30,136,229,0.14);
--stat-label: #5a5a6e;
--stat-value: #1565c0;
--stat-misc-text: #3a3a4a;
}

[data-theme="modern"] {
--modal-surface: #ffffff;
--modal-text: #0f172a;
--modal-subtext: #475569;
--modal-heading: #2563eb;
--modal-border: rgba(15,23,42,0.10);
--stat-surface: rgba(37,99,235,0.06);
--stat-border-c: rgba(37,99,235,0.13);
--stat-label: #64748b;
--stat-value: #2563eb;
--stat-misc-text: #334155;
}

[data-theme="modern-dark"] {
--modal-surface: #0d1526;
--modal-text: rgba(232,240,254,0.96);
--modal-subtext: rgba(229,231,235,0.64);
--modal-heading: #38bdf8;
--modal-border: rgba(148,163,184,0.18);
--stat-surface: rgba(14,165,233,0.10);
--stat-border-c: rgba(14,165,233,0.18);
--stat-label: rgba(229,231,235,0.58);
--stat-value: #38bdf8;
--stat-misc-text: rgba(229,231,235,0.78);
}

/* ────────────────────────────────────────────────────────────────
   2. MODALES — Fond, texte, titres universels
   ──────────────────────────────────────────────────────────────── */
.modal-content {
background: var(--modal-surface) !important;
color: var(--modal-text) !important;
border-color: var(--modal-border) !important;
}
.modal-content h3 {
color: var(--modal-heading) !important;
text-shadow: none !important;
}
.modal-content p,
.modal-content label,
.modal-content span:not(.icon):not([class*="lang"]) {
color: inherit;
}

/* ────────────────────────────────────────────────────────────────
   3. STATS — stat-card, .k, .v universellement lisibles
   ──────────────────────────────────────────────────────────────── */
.stat-card {
background: var(--stat-surface) !important;
border: 1px solid var(--stat-border-c) !important;
border-radius: 12px;
padding: 10px 14px;
color: var(--modal-text) !important;
}
.stat-card .k {
font-size: 0.76rem !important;
font-weight: 600 !important;
text-transform: uppercase !important;
letter-spacing: 0.55px !important;
color: var(--stat-label) !important;
opacity: 1 !important;
}
.stat-card .v {
font-size: 1.18rem !important;
font-weight: 800 !important;
color: var(--stat-value) !important;
margin-top: 5px;
}
/* Textes libres dans stat-card (dates, etc.) */
#stats-content div[style*="font-size"] {
color: var(--stat-misc-text) !important;
}
#stats-content strong {
color: var(--stat-value) !important;
}
/* Barre de progression */
.progress-bar {
background: var(--stat-border-c) !important;
border-color: transparent !important;
}
.progress-bar > div {
background: linear-gradient(90deg, var(--stat-value), var(--modal-heading)) !important;
}

/* Stats modal scroll */
.stats-modal-content {
overflow-y: auto;
max-height: 85vh;
}

/* ────────────────────────────────────────────────────────────────
   4. REPLAY — PANNEAU FLOTTANT (le plateau reste visible)
   ──────────────────────────────────────────────────────────────── */
#replay-modal {
/* Écrase le comportement overlay plein écran */
position: fixed !important;
top: auto !important;
left: 0 !important;
right: 0 !important;
bottom: 0 !important;
width: 100% !important;
height: auto !important;
/* Pas de fond sombre */
background: transparent !important;
backdrop-filter: none !important;
-webkit-backdrop-filter: none !important;
/* Centrage du panneau */
display: none;
flex-direction: column !important;
align-items: center !important;
justify-content: flex-end !important;
padding: 0 0.75rem 0.75rem !important;
z-index: 6000;
pointer-events: none;
}
#replay-modal.active {
display: flex !important;
pointer-events: auto;
}

/* Le panneau lui-même */
.replay-modal-content {
width: 100%;
max-width: 520px;
/* Fond opaque avec backdrop blur fort pour lisibilité */
background: var(--modal-surface) !important;
color: var(--modal-text) !important;
border: 1.5px solid var(--modal-border) !important;
border-radius: 18px 18px 14px 14px !important;
padding: 0.72rem 0.9rem 0.65rem !important;
box-shadow:
0 -6px 40px rgba(0,0,0,0.38),
0 -1px 12px rgba(0,0,0,0.20),
0 4px 16px rgba(0,0,0,0.18) !important;
backdrop-filter: blur(22px) saturate(1.4) !important;
-webkit-backdrop-filter: blur(22px) saturate(1.4) !important;
}

/* Titre du panneau replay */
.replay-modal-content h3 {
  display: none !important;
}

/* Méta (variante · mode · joueurs) */
.replay-meta {
  display: none !important;
}

/* Slider de timeline */
.replay-range {
-webkit-appearance: none;
appearance: none;
width: 100%;
height: 4px;
border-radius: 999px;
background: var(--stat-border-c) !important;
outline: none;
margin: 0 0 0.30rem !important;
cursor: pointer;
accent-color: var(--modal-heading);
}
.replay-range::-webkit-slider-thumb {
-webkit-appearance: none;
width: 14px;
height: 14px;
border-radius: 50%;
background: var(--modal-heading);
border: 2px solid rgba(255,255,255,0.65);
box-shadow: 0 1px 6px rgba(0,0,0,0.28);
cursor: pointer;
transition: transform 0.14s;
}
.replay-range::-webkit-slider-thumb:hover {
transform: scale(1.25);
}
.replay-range::-moz-range-thumb {
width: 14px;
height: 14px;
border-radius: 50%;
background: var(--modal-heading);
border: 2px solid rgba(255,255,255,0.65);
box-shadow: 0 1px 6px rgba(0,0,0,0.28);
}

/* Indicateur tour courant */
.replay-step-indicator {
text-align: center;
font-size: 0.66rem;
font-weight: 600;
color: var(--modal-subtext) !important;
margin: -1px 0 0.35rem;
font-variant-numeric: tabular-nums;
}

/* Boutons de contrôle */
.replay-controls {
display: flex !important;
gap: 5px !important;
justify-content: center !important;
align-items: stretch !important;
flex-wrap: nowrap !important;
margin: 0 0 0.35rem !important;
}
.replay-controls button {
all: unset;
flex: 1;
min-width: 34px;
max-width: 54px;
padding: 0.46rem 0.32rem;
border-radius: 9px;
border: 1.5px solid var(--modal-border) !important;
background: var(--stat-surface) !important;
color: var(--modal-text) !important;
font-size: 0.98rem;
line-height: 1;
cursor: pointer;
display: flex;
align-items: center;
justify-content: center;
transition: background 0.16s, transform 0.12s, box-shadow 0.12s;
box-shadow: none !important;
text-shadow: none !important;
}
.replay-controls button:hover {
background: var(--stat-border-c) !important;
transform: translateY(-2px);
box-shadow: 0 3px 10px rgba(0,0,0,0.18) !important;
}
.replay-controls button:active {
transform: translateY(0);
}

/* Bouton Play : mis en valeur */
#replay-play-btn {
background: color-mix(in srgb, var(--modal-heading) 20%, transparent) !important;
border-color: color-mix(in srgb, var(--modal-heading) 55%, transparent) !important;
flex: 1.5 !important;
max-width: 64px !important;
font-size: 1.05rem !important;
}
#replay-play-btn:hover {
background: color-mix(in srgb, var(--modal-heading) 35%, transparent) !important;
}

/* Fallback pour les navigateurs sans color-mix */
@supports not (color: color-mix(in srgb, red 50%, blue)) {
#replay-play-btn {
background: var(--stat-surface) !important;
border-color: var(--modal-heading) !important;
}
}

/* Footer : vitesse + fermer */
.replay-footer {
  display: flex !important;
  align-items: center !important;
  justify-content: flex-end !important;
  gap: 8px !important;
  flex-wrap: nowrap !important;
  margin: 0 !important;
  padding-top: 0.2rem !important;
  border-top: none !important;
}
.replay-footer label span { display: none !important; }

.replay-footer label {
display: flex;
align-items: center;
gap: 7px;
font-size: 0.82rem !important;
font-weight: 500;
color: var(--modal-subtext) !important;
opacity: 1 !important;
}
.replay-footer select {
all: unset;
background: var(--stat-surface) !important;
border: 1.5px solid var(--modal-border) !important;
color: var(--modal-text) !important;
border-radius: 9px;
padding: 4px 24px 4px 8px;
font-size: 0.78rem;
font-weight: 600;
cursor: pointer;
background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='7' viewBox='0 0 10 7'%3E%3Cpath d='M1 1l4 4 4-4' stroke='%23888' stroke-width='1.5' fill='none' stroke-linecap='round'/%3E%3C/svg%3E");
background-repeat: no-repeat;
background-position: right 8px center;
transition: border-color 0.15s;
-webkit-appearance: none;
appearance: none;
}
.replay-footer select option {
background: var(--modal-surface, #2a201a);
color: var(--modal-text, #f5f5f5);
}
.replay-footer select:hover {
border-color: var(--modal-heading) !important;
}

/* Bouton Fermer du replay */
#replay-exit-btn {
  all: unset;
  width: 34px !important;
  height: 34px !important;
  display: grid !important;
  place-items: center !important;
  border-radius: 999px !important;
  border: 1.5px solid var(--modal-border) !important;
  background: transparent !important;
  color: var(--modal-text) !important;
  font-size: 1rem !important;
  font-weight: 800 !important;
  cursor: pointer !important;
  transition: background 0.15s, transform 0.12s !important;
}
#replay-exit-btn:hover {
  background: color-mix(in srgb, var(--stat-surface) 85%, transparent) !important;
  transform: translateY(-1px);
}

#replay-exit-btn:hover {
background: var(--stat-border-c) !important;
transform: translateY(-1px);
}

/* Indicateur de lecture sur le plateau (bande translucide) */
.replay-board-indicator {
position: fixed;
top: 0;
left: 0;
right: 0;
height: 3px;
background: var(--modal-heading);
opacity: 0.7;
z-index: 5999;
display: none;
transform-origin: left;
animation: replayBarPulse 1.8s ease-in-out infinite;
}
#replay-modal.active ~ .replay-board-indicator,
body.replay-active .replay-board-indicator {
display: block;
}

@keyframes replayBarPulse {
0%, 100% {
opacity: 0.5;
}
50% {
opacity: 0.9;
}
}

/* Badge "REPLAY" flottant sur le plateau */
.replay-badge {
position: fixed;
top: 0.6rem;
left: 50%;
transform: translateX(-50%);
background: var(--modal-heading);
color: var(--modal-surface, #1a1a1a);
font-size: 0.7rem;
font-weight: 800;
letter-spacing: 0.12em;
padding: 3px 12px;
border-radius: 999px;
z-index: 5998;
display: none;
box-shadow: 0 2px 12px rgba(0,0,0,0.3);
text-transform: uppercase;
pointer-events: none;
}
body.replay-active .replay-badge {
display: block;
}

/* ────────────────────────────────────────────────────────────────
   5. WINNER OVERLAY — masqué pendant le replay
   ──────────────────────────────────────────────────────────────── */
body.replay-active .winner-overlay.active {
opacity: 0 !important;
pointer-events: none !important;
transition: opacity 0.3s ease !important;
}

/* ────────────────────────────────────────────────────────────────
   6. BOUTONS MODAL-ACTIONS — force lisibilité
   ──────────────────────────────────────────────────────────────── */
.modal-actions button {
background: var(--stat-surface) !important;
border: 1.5px solid var(--modal-border) !important;
color: var(--modal-text) !important;
border-radius: 12px !important;
padding: 0.6rem 1.4rem !important;
font-size: 0.9rem !important;
font-weight: 600 !important;
cursor: pointer !important;
transition: background 0.16s, transform 0.12s !important;
box-shadow: none !important;
text-shadow: none !important;
}
.modal-actions button:hover {
background: var(--stat-border-c) !important;
transform: translateY(-1px) !important;
}

/* ────────────────────────────────────────────────────────────────
   7. LABEL + SELECT DANS TOUTES MODALES
   ──────────────────────────────────────────────────────────────── */
.modal-content label {
color: var(--modal-subtext) !important;
font-size: 0.88rem;
}

/* ────────────────────────────────────────────────────────────────
   8. PION BLOQUÉ (même pion 3× de suite)
      Croix rouge en overlay + animation de pulsation
   ──────────────────────────────────────────────────────────────── */

/* La cellule hôte du pion bloqué */
.consecutive-blocked-cell {
cursor: not-allowed !important;
}

/* Le pion bloqué lui-même */
.stone.consecutive-blocked {
/* Filtre visuel : désaturé + teinte rouge */
filter: grayscale(55%) sepia(0.6) saturate(2.5) hue-rotate(300deg) brightness(0.82) !important;
/* Bordure rouge pulsée */
outline: 3px solid rgba(255, 60, 60, 0.90) !important;
outline-offset: 2px !important;
border-radius: 50% !important;
animation: blockedPulse 1.4s ease-in-out infinite !important;
cursor: not-allowed !important;
position: relative;
}

/* Pseudo-élément : croix ✕ en overlay sur le pion */
.consecutive-blocked-cell::after {
content: '✕';
position: absolute;
inset: 0;
display: flex;
align-items: center;
justify-content: center;
font-size: clamp(0.85rem, 2.8vw, 1.1rem);
font-weight: 900;
color: rgba(255, 60, 60, 0.92);
text-shadow: 0 0 6px rgba(0,0,0,0.7);
pointer-events: none;
z-index: 10;
line-height: 1;
}

/* Animation de pulsation rouge */
@keyframes blockedPulse {
0%, 100% {
outline-color: rgba(255, 60, 60, 0.85);
box-shadow: 0 0 0 0 rgba(255, 60, 60, 0);
}
50% {
outline-color: rgba(255, 60, 60, 1);
box-shadow: 0 0 0 5px rgba(255, 60, 60, 0.22);
}
}

/* Adaptation thème Kabylie / Desert / Modern (clairs) */
[data-theme="kabylie"] .stone.consecutive-blocked,
[data-theme="desert"] .stone.consecutive-blocked,
[data-theme="modern"] .stone.consecutive-blocked {
outline-color: rgba(200, 20, 20, 0.90) !important;
}
[data-theme="kabylie"] .consecutive-blocked-cell::after,
[data-theme="desert"] .consecutive-blocked-cell::after,
[data-theme="modern"] .consecutive-blocked-cell::after {
color: rgba(200, 20, 20, 0.95);
}

/* =====================================================================
   OPTIMISATION ERGONOMIE & LISIBILITÉ v5
   – Taille de caractères augmentée
   – Graisses améliorées
   – Responsive sans défilement horizontal
   – Graphisme renforcé
   ===================================================================== */

/* ── 1. Base typographique ── */
html {
font-size: clamp(15px, 2vw, 17px);
/* ↑ min 13→15, max 16→17 */
overflow-x: hidden;
}

body {
font-weight: 430;
letter-spacing: 0.18px;
overflow-x: hidden;
max-width: 100vw;
}

/* ── 2. Titres ── */
h1 {
font-size: clamp(2.6rem, 7vw, 3.8rem);
font-weight: 900;
letter-spacing: 0.22em;
}

h2, .selection-area h2 {
font-size: clamp(1.6rem, 4.5vw, 2.2rem) !important;
font-weight: 800 !important;
letter-spacing: 0.05em;
}

h3, .version-card h3, .mode-card h3, .difficulty-card h3 {
font-size: clamp(1.15rem, 3.5vw, 1.5rem) !important;
font-weight: 800 !important;
letter-spacing: 0.10em;
}

/* ── 3. Corps de texte dans les cartes ── */
.version-card p,
.mode-card p,
.difficulty-card p,
.option-btn p {
font-size: clamp(0.92rem, 2.5vw, 1.05rem) !important;
font-weight: 500 !important;
line-height: 1.65 !important;
letter-spacing: 0.08px;
}

/* ── 4. Boutons de contrôle (undo, surrender, new game…) ── */
.controls button {
font-size: clamp(0.92rem, 2.8vw, 1.05rem) !important;
font-weight: 700 !important;
padding: 0.85rem 1.4rem !important;
letter-spacing: 0.3px;
min-height: 44px;
/* zone tactile confortable */
}

/* ── 5. Boutons principaux (play, back, rules) ── */
.start-game-btn {
font-size: clamp(1.5rem, 5vw, 2rem) !important;
font-weight: 900 !important;
padding: 1.2rem 3.2rem !important;
letter-spacing: 4px;
}

.back-btn {
font-size: clamp(0.95rem, 2.8vw, 1.1rem) !important;
font-weight: 700 !important;
padding: 0.75rem 2rem !important;
min-height: 44px;
}

.rules-btn {
font-size: clamp(1rem, 3vw, 1.15rem) !important;
font-weight: 700 !important;
padding: 0.85rem 2rem !important;
min-height: 44px;
}

.option-btn {
font-size: clamp(1.05rem, 3.5vw, 1.25rem) !important;
font-weight: 700 !important;
padding: 1.6rem !important;
gap: 12px;
min-height: 44px;
}

.option-btn .icon {
font-size: 1.6em !important;
}

/* ── 6. Toolbar (boutons settings flottants) ── */
.toolbar-btn {
font-size: 0.95rem !important;
font-weight: 600 !important;
padding: 0.65rem 1.1rem !important;
min-height: 40px;
}

/* Override des spans inline font-size:0.78rem mis en dur dans le HTML */
.toolbar-btn span[data-i18n],
.toolbar-btn span[style] {
font-size: 0.9rem !important;
font-weight: 600 !important;
}

/* ── 7. Sélecteur de langue ── */
.language-selector select {
font-size: 0.95rem !important;
font-weight: 700 !important;
}

/* ── 8. Infos de jeu (panneau du bas pendant la partie) ── */
.game-info-display {
font-size: clamp(0.95rem, 2.8vw, 1.08rem) !important;
font-weight: 600 !important;
padding: 0.85rem 1.4rem !important;
}

.game-info-display strong {
font-weight: 800 !important;
font-size: 1.05em;
}

/* ── 9. Barre de statut ── */
.status {
font-size: clamp(1.05rem, 3.2vw, 1.25rem) !important;
font-weight: 600 !important;
min-height: 54px !important;
padding: 0.9rem 1.2rem !important;
}

/* ── 10. Panneaux joueurs ── */
.player-title {
font-size: clamp(1.05rem, 3.2vw, 1.3rem) !important;
font-weight: 800 !important;
letter-spacing: 0.05em;
}

.stat-value {
font-size: clamp(1.3rem, 4vw, 1.6rem) !important;
font-weight: 900 !important;
}

.player-stat i {
font-size: clamp(1.05rem, 2.8vw, 1.3rem) !important;
}

/* ── 11. Historique des coups ── */
.move-history-title {
font-size: 0.88rem !important;
font-weight: 800 !important;
letter-spacing: 1px;
}

.move-log-entry {
font-size: 0.9rem !important;
font-weight: 600 !important;
padding: 3px 8px !important;
}

/* ── 12. Footer ── */
footer {
font-size: clamp(0.85rem, 2.2vw, 0.98rem) !important;
font-weight: 600 !important;
opacity: 0.90 !important;
}

/* ── 13. Toasts ── */
.toast {
font-size: 1rem !important;
font-weight: 600 !important;
padding: 12px 18px !important;
}

/* ── 14. Modales ── */
.modal-content h3 {
font-size: clamp(1.3rem, 4vw, 1.65rem) !important;
font-weight: 800 !important;
}

.modal-actions button {
font-size: 1rem !important;
font-weight: 700 !important;
padding: 0.75rem 1.8rem !important;
min-height: 44px;
}

/* ── 15. Règles du jeu ── */
.rules-book {
font-size: clamp(1rem, 2.8vw, 1.12rem) !important;
font-weight: 500 !important;
line-height: 1.8 !important;
}

.rules-book h2 {
font-size: clamp(1.4rem, 4vw, 1.8rem) !important;
font-weight: 800 !important;
}

.rules-book h3 {
font-size: clamp(1.1rem, 3vw, 1.3rem) !important;
font-weight: 700 !important;
}

/* ── 16. Écran de démarrage (language splash) ── */
.splash-logo {
font-size: clamp(3rem, 10vw, 5.5rem) !important;
font-weight: 900 !important;
letter-spacing: 0.25em;
}

.splash-tifinagh {
font-size: clamp(1.1rem, 3.5vw, 1.6rem) !important;
font-weight: 600 !important;
}

.splash-prompt {
font-size: clamp(1rem, 2.8vw, 1.2rem) !important;
font-weight: 500 !important;
}

.splash-lang-btn {
font-size: clamp(1rem, 3vw, 1.15rem) !important;
min-height: 80px;
}

.splash-lang-name {
font-size: clamp(1.1rem, 3.5vw, 1.35rem) !important;
font-weight: 800 !important;
}

.splash-lang-sub {
font-size: clamp(0.88rem, 2.5vw, 1rem) !important;
font-weight: 500 !important;
}

.splash-footer {
font-size: clamp(0.82rem, 2.2vw, 0.95rem) !important;
font-weight: 600 !important;
}

/* ── 17. Stat cards (modal stats) ── */
.stat-card .k {
font-size: 0.85rem !important;
font-weight: 700 !important;
letter-spacing: 0.5px;
}

.stat-card .v {
font-size: 1.3rem !important;
font-weight: 900 !important;
}

/* ── 18. Responsive strict : zéro scroll horizontal ── */
*,
*::before,
*::after {
min-width: 0;
box-sizing: border-box;
}

.selection-area {
width: min(100%, 950px) !important;
max-width: 100vw !important;
overflow-x: hidden !important;
}

.version-grid {
grid-template-columns: repeat(auto-fit, minmax(min(240px, 85vw), 1fr)) !important;
width: 100% !important;
}

.options-group {
width: 100% !important;
}

.option-btn {
min-width: min(180px, 85vw) !important;
}

.game-board-container {
max-width: min(95vw, calc(95dvh - 9rem), 600px) !important;
}

/* Conteneur principal : jamais plus large que la fenêtre */
.game-container {
overflow-x: hidden !important;
width: 100% !important;
max-width: 100vw !important;
}

/* Toasts ne débordent pas */
.toast {
max-width: min(90vw, 720px) !important;
word-break: break-word !important;
}

/* ── 19. Mobile (< 480px) spécifique ── */
@media (max-width: 480px) {
html {
font-size: clamp(14px, 4vw, 16px);
}

h1 {
font-size: clamp(2.2rem, 9vw, 3rem) !important;
}
h2, .selection-area h2 {
font-size: clamp(1.35rem, 6vw, 1.7rem) !important;
}

.option-btn {
padding: 1.2rem 1rem !important;
font-size: 1rem !important;
min-width: min(160px, 80vw) !important;
}

.start-game-btn {
font-size: 1.3rem !important;
padding: 1rem 2rem !important;
letter-spacing: 2px;
}

.controls {
gap: 0.55rem !important;
}

.controls button {
font-size: 0.88rem !important;
padding: 0.75rem 1rem !important;
flex-basis: 100px !important;
}

.splash-langs {
gap: 0.75rem !important;
}

.splash-lang-btn {
min-width: min(140px, 42vw) !important;
padding: 1rem 0.6rem !important;
}

.game-info-display {
font-size: 0.88rem !important;
gap: 0.75rem !important;
}

.toolbar-buttons {
bottom: 0.75rem !important;
right: 0.75rem !important;
}

#settings-fab {
width: 48px !important;
height: 48px !important;
font-size: 1.2rem !important;
}
}

/* ── 20. Tablette portrait (481–768px) ── */
@media (min-width: 481px) and (max-width: 768px) {
.version-grid {
grid-template-columns: repeat(2, 1fr) !important;
}

.options-group {
gap: 1rem !important;
}

.option-btn {
min-width: min(160px, 42vw) !important;
max-width: 260px !important;
}
}

/* ── 21. Améliorations graphiques supplémentaires ── */

/* Ombre plus prononcée sur les panneaux de sélection */
.selection-area {
box-shadow:
0 30px 80px rgba(0,0,0,0.32),
0 0 0 1px rgba(255,255,255,0.04),
inset 0 1px 0 rgba(255,255,255,0.08) !important;
}

[data-theme="kabylie"] .selection-area {
box-shadow:
0 24px 64px rgba(31,26,18,0.16),
0 0 0 1px rgba(255,255,255,0.55),
inset 0 1px 0 rgba(255,255,255,0.8) !important;
}

/* Bordure top lumineuse sur les cartes */
.version-card,
.mode-card,
.difficulty-card {
position: relative;
}
.version-card::before,
.mode-card::before,
.difficulty-card::before {
content: '';
position: absolute;
top: 0;
left: 10%;
right: 10%;
height: 1px;
background: linear-gradient(90deg, transparent, rgba(255,255,255,0.35), transparent);
border-radius: 999px;
pointer-events: none;
z-index: 1;
}

/* Highlight lumieux au survol des cartes */
.version-card:hover,
.mode-card:hover,
.difficulty-card:hover {
box-shadow:
0 22px 55px rgba(0,0,0,0.38),
0 0 30px rgba(240,200,80,0.20),
inset 0 0 0 1px rgba(240,200,80,0.30) !important;
}

/* Séparateur horizontal renforcé dans le header */
header::before {
opacity: 0.7 !important;
}

/* Pion fantôme plus visible */
#drag-ghost {
width: 52px !important;
height: 52px !important;
}

/* Zone de jeu : meilleure ombre portée */
.game-board-container {
box-shadow:
0 20px 55px rgba(0,0,0,0.75),
0 0 0 1px rgba(255,255,255,0.05),
inset 0 0 25px rgba(0,0,0,0.45) !important;
}

/* Scrollbar plus fine et cohérente */
* {
scrollbar-width: thin;
scrollbar-color: rgba(240,200,80,0.4) transparent;
}
::-webkit-scrollbar {
width: 6px;
height: 6px;
}
::-webkit-scrollbar-thumb {
background: rgba(240,200,80,0.35);
border-radius: 999px;
}
::-webkit-scrollbar-track {
background: transparent;
}

/* Séparateur entre les champs info de jeu */
.game-info-display span + span {
padding-left: 0.5rem;
border-left: 1px solid rgba(255,255,255,0.12);
}
[data-theme="kabylie"] .game-info-display span + span {
border-left-color: rgba(31,26,18,0.12);
}

/* Meilleure transition des panels joueurs */
.player-info {
transition: all 0.35s cubic-bezier(0.25, 0.8, 0.25, 1) !important;
}

/* Overlay de victoire : titre encore plus imposant */
.winner-overlay .winner-name {
/* géré par le redesign — voir bloc WINNER OVERLAY */
}

.winner-overlay .winner-message {
/* géré par le redesign — voir bloc WINNER OVERLAY */
}

/* Bouton replay — géré par le redesign */
.winner-overlay .replay-button {
/* géré par le redesign — voir bloc WINNER OVERLAY */
}

/* ═══════════════════════════════════════════════════════════
   PATCH FINAL — v10
   1. Suppression historique des coups
   2. Correction bouton Paramètres petits écrans
   3. Hiérarchie visuelle des cartes (premium ergonomie)
   ═══════════════════════════════════════════════════════════ */

/* ── 1. SUPPRESSION HISTORIQUE DES COUPS ── */
.move-history-panel {
display: none !important;
}

/* ── 2. BOUTON PARAMÈTRES — PETITS ÉCRANS ── */
/* Le bouton est width:auto avec padding à partir de 640px,
   mais à <640px il doit rester un FAB circulaire sans label */
@media (max-width: 639px) {
#settings-fab {
width: 48px !important;
height: 48px !important;
min-width: 48px !important;
padding: 0 !important;
border-radius: 50% !important;
display: flex !important;
align-items: center !important;
justify-content: center !important;
gap: 0 !important;
}
#settings-fab .settings-label {
display: none !important;
}
/* Le tray s'ouvre quand même normalement */
.settings-tray.open {
max-height: min(380px, calc(100dvh - 5rem)) !important;
}
}

@media (min-width: 640px) {
#settings-fab {
width: auto !important;
min-width: 48px !important;
height: 48px !important;
padding: 0.65rem 1.15rem !important;
border-radius: 999px !important;
gap: 0.5rem !important;
}
.settings-label {
display: inline !important;
}
}

/* ── 3. HIÉRARCHIE VISUELLE CARTES — DESIGN TOKENS ── */

/* Bordures ultra-légères (1px translucide) */
.version-card,
.mode-card,
.difficulty-card {
border: 1px solid rgba(255,255,255,0.10) !important;
}
[data-theme="kabylie"] .version-card,
[data-theme="kabylie"] .mode-card,
[data-theme="kabylie"] .difficulty-card,
[data-theme="desert"] .version-card,
[data-theme="desert"] .mode-card,
[data-theme="desert"] .difficulty-card {
border: 1px solid rgba(31,26,18,0.12) !important;
}

/* ── 3a. OPTION-BTN : hiérarchie icône / titre / sous-titre ── */
.option-btn {
flex-direction: column !important;
align-items: center !important;
text-align: center !important;
padding: 1.6rem 1.2rem !important;
gap: 0 !important;
/* géré par les enfants */
min-height: 48px !important;
position: relative !important;
}

/* Icône : grande, dominante */
.option-btn > .icon:first-child,
.option-btn > span[aria-hidden="true"]:first-child {
font-size: 2.2rem !important;
line-height: 1 !important;
margin-bottom: 0.55rem !important;
display: block !important;
filter: drop-shadow(0 2px 6px rgba(0,0,0,0.30));
}

/* Titre principal (2e enfant = span texte principal) */
.option-btn > span:nth-child(2) {
font-size: clamp(1.05rem, 3.2vw, 1.2rem) !important;
font-weight: 800 !important;
letter-spacing: 0.04em !important;
line-height: 1.25 !important;
margin-bottom: 0.35rem !important;
color: var(--text-main) !important;
display: block !important;
}

/* Sous-titre (3e enfant = description) */
.option-btn > span:nth-child(3) {
font-size: clamp(0.78rem, 2vw, 0.9rem) !important;
font-weight: 500 !important;
line-height: 1.4 !important;
opacity: 0.68 !important;
color: var(--text-muted, var(--text-main)) !important;
display: block !important;
letter-spacing: 0.01em !important;
}

/* Accentuation : option principale active (hover) */
.option-btn:hover > span:nth-child(2) {
color: var(--text-gold, var(--text-main)) !important;
opacity: 1 !important;
}

/* ── 3b. VERSION-CARD : hiérarchie titre / description ── */
.version-card {
padding: 1.4rem 1.2rem 1.2rem !important;
gap: 0 !important;
}

/* Accroche colorée en haut de carte */
.version-card::before {
content: '';
position: absolute !important;
top: 0 !important;
left: 0 !important;
right: 0 !important;
height: 3px !important;
border-radius: 10px 10px 0 0 !important;
background: linear-gradient(90deg, transparent, var(--text-gold, #f0c850), transparent) !important;
opacity: 0.55 !important;
pointer-events: none !important;
}

/* Titre carte : dominant */
.version-card h3 {
font-size: clamp(1.15rem, 3.5vw, 1.45rem) !important;
font-weight: 900 !important;
letter-spacing: 0.08em !important;
margin-bottom: 0.5rem !important;
line-height: 1.2 !important;
}

/* Description carte : secondaire, lisible */
.version-card p {
font-size: clamp(0.82rem, 2.2vw, 0.95rem) !important;
font-weight: 450 !important;
line-height: 1.6 !important;
opacity: 0.80 !important;
letter-spacing: 0.01em !important;
}

/* Carte active : ôter l'opacité sur le texte */
.version-card.active p,
.version-card.active h3 {
opacity: 1 !important;
}

/* ── 3c. DIFFICULTY-CARD & MODE-CARD : même traitement ── */
.difficulty-card,
.mode-card {
border: 1px solid rgba(255,255,255,0.10) !important;
padding: 1.3rem 1rem !important;
}
.difficulty-card h3,
.mode-card h3 {
font-size: clamp(1.1rem, 3.2vw, 1.35rem) !important;
font-weight: 800 !important;
margin-bottom: 0.4rem !important;
}
.difficulty-card p,
.mode-card p {
font-size: clamp(0.8rem, 2vw, 0.92rem) !important;
font-weight: 450 !important;
opacity: 0.75 !important;
}

/* ── 3d. CTA PRINCIPAL vs SECONDAIRES ── */

/* Bouton "Jouer" = CTA principal : déjà imposant, on renforce */
.start-game-btn {
box-shadow:
0 12px 36px rgba(0,0,0,0.38),
0 0 0 0 rgba(240,200,80,0.5),
0 4px 0 rgba(0,0,0,0.25) !important;
min-height: 60px !important;
letter-spacing: 0.2em !important;
}

/* Boutons secondaires (Retour, Règles) : outline style */
.back-btn {
background: transparent !important;
border: 1px solid rgba(255,255,255,0.22) !important;
box-shadow: none !important;
color: var(--text-main) !important;
font-weight: 600 !important;
opacity: 0.85 !important;
}
.back-btn:hover {
background: rgba(255,255,255,0.06) !important;
opacity: 1 !important;
border-color: rgba(255,255,255,0.38) !important;
}
[data-theme="kabylie"] .back-btn,
[data-theme="desert"] .back-btn {
border-color: rgba(31,26,18,0.20) !important;
color: var(--text-main) !important;
}

.rules-btn {
background: transparent !important;
border: 1px solid var(--panel-border, rgba(240,200,80,0.35)) !important;
box-shadow: none !important;
font-weight: 600 !important;
opacity: 0.88 !important;
min-height: 48px !important;
}
.rules-btn:hover {
opacity: 1 !important;
background: rgba(240,200,80,0.08) !important;
}

/* ── 3e. ZONES TACTILES GARANTIES 48px ── */
.controls button,
.option-btn,
.back-btn,
.rules-btn,
.toolbar-btn,
.modal-actions button,
.start-game-btn,
#settings-fab {
min-height: 48px !important;
}

/* ── 3f. FEEDBACK IMMÉDIAT (active state) ── */
.option-btn:active,
.version-card:active,
.difficulty-card:active,
.mode-card:active {
transform: scale(0.975) !important;
transition: transform 0.08s ease !important;
}

.controls button:active:not(:disabled) {
transform: translateY(2px) scale(0.97) !important;
transition: transform 0.08s ease !important;
}

/* Flash de sélection rapide sur tap */
@keyframes tapFlash {
0% {
background-color: rgba(240,200,80,0.0);
}
30% {
background-color: rgba(240,200,80,0.18);
}
100% {
background-color: rgba(240,200,80,0.0);
}
}
.version-card:active::after,
.option-btn:active::after {
animation: tapFlash 0.25s ease forwards !important;
opacity: 1 !important;
pointer-events: none !important;
}

/* ── 3g. SELECTION-AREA header/subtitle ── */
.selection-area > h2 {
font-size: clamp(1.5rem, 4.5vw, 2.1rem) !important;
font-weight: 900 !important;
letter-spacing: 0.04em !important;
margin-bottom: 0.2rem !important;
line-height: 1.2 !important;
}

/* Sous-titre optionnel si présent */
.selection-area > p {
font-size: clamp(0.88rem, 2.4vw, 1rem) !important;
font-weight: 500 !important;
opacity: 0.72 !important;
margin-top: -0.5rem !important;
max-width: 55ch !important;
text-align: center !important;
line-height: 1.5 !important;
}

/* ═══════════════════════════════════════════════════════════
   PATCH v11 — Settings panel + Game Controls
   ═══════════════════════════════════════════════════════════ */

/* ── SETTINGS TRAY: Panel flottant sans défilement ── */
.settings-tray {
overflow: hidden !important;
overflow-y: visible !important;
}
.settings-tray.open {
overflow: visible !important;
overflow-y: visible !important;
max-height: none !important;
}
/* Masquer la scrollbar quoi qu'il arrive */
.settings-tray::-webkit-scrollbar {
display: none !important;
}
.settings-tray {
scrollbar-width: none !important;
}

/* Panel conteneur principal */
.stray-panel {
background: rgba(14, 10, 8, 0.92);
border: 1px solid rgba(240, 200, 80, 0.22);
border-radius: 18px;
padding: 0;
min-width: 240px;
max-width: 280px;
box-shadow:
0 24px 60px rgba(0,0,0,0.55),
0 0 0 1px rgba(255,255,255,0.04),
inset 0 1px 0 rgba(255,255,255,0.06);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
overflow: hidden;
animation: strayIn 0.22s cubic-bezier(0.2,0.9,0.2,1) both;
}
@keyframes strayIn {
from {
opacity: 0;
transform: translateY(10px) scale(0.96);
}
to {
opacity: 1;
transform: translateY(0) scale(1);
}
}

[data-theme="kabylie"] .stray-panel,
[data-theme="desert"] .stray-panel {
background: rgba(255, 253, 248, 0.95);
border-color: rgba(31,26,18,0.14);
box-shadow: 0 24px 60px rgba(0,0,0,0.18), 0 0 0 1px rgba(0,0,0,0.04);
}
[data-theme="nuit"] .stray-panel,
[data-theme="glass"] .stray-panel,
[data-theme="modern-dark"] .stray-panel {
background: rgba(8, 6, 20, 0.94);
}

/* Header du panel */
.stray-header {
display: flex;
align-items: center;
justify-content: space-between;
padding: 0.9rem 1rem 0.7rem;
border-bottom: 1px solid rgba(240,200,80,0.14);
}
[data-theme="kabylie"] .stray-header,
[data-theme="desert"] .stray-header {
border-bottom-color: rgba(31,26,18,0.10);
}

.stray-title {
font-size: 0.88rem;
font-weight: 800;
letter-spacing: 0.08em;
text-transform: uppercase;
color: var(--text-gold, #f0c850);
opacity: 0.9;
}
[data-theme="kabylie"] .stray-title {
color: var(--kab-blue);
}

.stray-close-btn {
background: none !important;
border: none !important;
box-shadow: none !important;
color: var(--text-muted) !important;
font-size: 0.95rem !important;
padding: 0.15rem 0.4rem !important;
min-height: unset !important;
width: 28px !important;
height: 28px !important;
border-radius: 8px !important;
cursor: pointer;
opacity: 0.6;
display: flex;
align-items: center;
justify-content: center;
transition: opacity 0.15s, background 0.15s;
}
.stray-close-btn:hover {
opacity: 1;
background: rgba(255,255,255,0.10) !important;
}

/* Sections */
.stray-section {
padding: 0.65rem 1rem;
border-bottom: 1px solid rgba(240,200,80,0.08);
}
.stray-section:last-child {
border-bottom: none;
}
[data-theme="kabylie"] .stray-section,
[data-theme="desert"] .stray-section {
border-bottom-color: rgba(31,26,18,0.07);
}

.stray-section-label {
display: block;
font-size: 0.68rem;
font-weight: 700;
text-transform: uppercase;
letter-spacing: 0.12em;
color: var(--text-muted);
opacity: 0.55;
margin-bottom: 0.5rem;
}

/* Grille de boutons dans le tray */
.stray-grid {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 0.4rem;
}

/* Boutons items */
.stray-item {
display: flex !important;
flex-direction: column !important;
align-items: center !important;
justify-content: center !important;
gap: 0.3rem !important;
padding: 0.7rem 0.4rem !important;
border-radius: 12px !important;
min-height: 64px !important;
border: 1px solid rgba(255,255,255,0.07) !important;
background: rgba(255,255,255,0.04) !important;
color: var(--text-main) !important;
box-shadow: none !important;
cursor: pointer;
transition: background 0.15s ease, border-color 0.15s ease, transform 0.12s ease;
white-space: nowrap;
font-family: var(--font-body);
}
.stray-item:hover {
background: rgba(240,200,80,0.12) !important;
border-color: rgba(240,200,80,0.30) !important;
transform: translateY(-1px) !important;
box-shadow: 0 4px 12px rgba(0,0,0,0.20) !important;
}
.stray-item:active {
transform: scale(0.95) !important;
}
.stray-item.active {
background: rgba(240,200,80,0.18) !important;
border-color: rgba(240,200,80,0.45) !important;
}

[data-theme="kabylie"] .stray-item,
[data-theme="desert"] .stray-item {
border-color: rgba(31,26,18,0.09) !important;
background: rgba(31,26,18,0.03) !important;
color: var(--text-main) !important;
}
[data-theme="kabylie"] .stray-item:hover,
[data-theme="desert"] .stray-item:hover {
background: rgba(30,136,229,0.08) !important;
border-color: rgba(30,136,229,0.22) !important;
}

.stray-icon {
font-size: 1.45rem;
line-height: 1;
display: block;
}
.stray-item-label {
font-size: 0.72rem !important;
font-weight: 700 !important;
letter-spacing: 0.02em;
color: inherit;
display: block;
}
/* Override global toolbar-btn styles for stray items */
.stray-item.toolbar-btn span {
display: block !important;
font-size: inherit !important;
}

/* Language selector inside stray */
.stray-section .language-selector {
min-height: 44px;
border-radius: 12px;
padding: 0.5rem 0.85rem;
background: rgba(255,255,255,0.04) !important;
border: 1px solid rgba(255,255,255,0.07) !important;
box-shadow: none !important;
width: 100%;
gap: 0.5rem;
display: flex;
align-items: center;
}
.stray-section .language-selector select {
flex: 1;
min-width: 0;
font-size: 0.9rem !important;
font-weight: 600 !important;
color: var(--text-main) !important;
}
[data-theme="kabylie"] .stray-section .language-selector,
[data-theme="desert"] .stray-section .language-selector {
background: rgba(31,26,18,0.04) !important;
border-color: rgba(31,26,18,0.10) !important;
}

/* Disabled stray item */
.stray-item:disabled,
.stray-item[disabled] {
opacity: 0.38 !important;
pointer-events: none !important;
}

/* ── GAME CONTROLS MODERNISÉS ── */

/* Conteneur : centré, pas de flex-wrap forcé */
.controls {
display: flex !important;
justify-content: center !important;
align-items: stretch !important;
gap: 0.55rem !important;
flex-wrap: nowrap !important;
width: 100% !important;
padding: 0.2rem 0 !important;
}

/* Bouton de contrôle : design SVG moderne */
.ctrl-btn {
display: flex !important;
flex-direction: column !important;
align-items: center !important;
justify-content: center !important;
gap: 0.32rem !important;
flex: 1 !important;
min-width: 0 !important;
max-width: 110px !important;
min-height: 60px !important;
padding: 0.6rem 0.5rem !important;
border-radius: 14px !important;
border: 1px solid rgba(255,255,255,0.10) !important;
background: rgba(255,255,255,0.05) !important;
color: var(--text-main) !important;
box-shadow: 0 2px 8px rgba(0,0,0,0.22), inset 0 1px 0 rgba(255,255,255,0.06) !important;
cursor: pointer;
transition: background 0.16s ease, transform 0.12s ease, box-shadow 0.16s ease, border-color 0.16s ease !important;
letter-spacing: 0 !important;
text-shadow: none !important;
position: relative !important;
overflow: hidden !important;
backdrop-filter: blur(8px);
-webkit-backdrop-filter: blur(8px);
}
/* Shine on hover */
.ctrl-btn::before {
content: '';
position: absolute;
inset: 0;
border-radius: inherit;
background: linear-gradient(135deg, rgba(255,255,255,0.08) 0%, transparent 60%);
opacity: 0;
transition: opacity 0.18s ease;
pointer-events: none;
}
.ctrl-btn:hover::before {
opacity: 1;
}

.ctrl-btn:hover:not(:disabled) {
transform: translateY(-2px) !important;
box-shadow: 0 8px 22px rgba(0,0,0,0.30), inset 0 1px 0 rgba(255,255,255,0.10) !important;
border-color: rgba(255,255,255,0.20) !important;
}
.ctrl-btn:active:not(:disabled) {
transform: translateY(0) scale(0.96) !important;
box-shadow: 0 2px 6px rgba(0,0,0,0.20) !important;
}
.ctrl-btn:disabled {
opacity: 0.38 !important;
cursor: not-allowed !important;
filter: none !important;
}

/* Icône SVG */
.ctrl-icon {
width: 22px !important;
height: 22px !important;
flex-shrink: 0;
stroke: currentColor;
fill: none;
display: block;
}

/* Label */
.ctrl-label {
font-size: 0.68rem !important;
font-weight: 700 !important;
letter-spacing: 0.04em !important;
line-height: 1 !important;
white-space: nowrap !important;
display: block !important;
opacity: 0.85;
text-transform: uppercase;
}

/* Bouton Home : neutre */
.ctrl-home {
color: rgba(200,200,200,0.95) !important;
}
.ctrl-home:hover:not(:disabled) {
background: rgba(255,255,255,0.10) !important;
color: #fff !important;
}

/* Bouton Undo : bleu */
.ctrl-undo {
color: rgba(100, 180, 255, 0.95) !important;
border-color: rgba(100,180,255,0.18) !important;
}
.ctrl-undo:hover:not(:disabled) {
background: rgba(100,180,255,0.12) !important;
border-color: rgba(100,180,255,0.35) !important;
color: #7dd3fa !important;
}

/* Bouton Restart : vert/ambre */
.ctrl-restart {
color: rgba(240,200,80,0.95) !important;
border-color: rgba(240,200,80,0.18) !important;
}
.ctrl-restart:hover:not(:disabled) {
background: rgba(240,200,80,0.10) !important;
border-color: rgba(240,200,80,0.35) !important;
}

/* Bouton Surrender : rouge */
.ctrl-surrender {
color: rgba(255,100,100,0.92) !important;
border-color: rgba(255,100,100,0.16) !important;
}
.ctrl-surrender:hover:not(:disabled) {
background: rgba(255,100,100,0.10) !important;
border-color: rgba(255,100,100,0.32) !important;
color: #ff8080 !important;
}

/* Thèmes clairs (kabylie, desert, modern) */
[data-theme="kabylie"] .ctrl-btn,
[data-theme="desert"] .ctrl-btn,
[data-theme="modern"] .ctrl-btn {
background: rgba(255,255,255,0.82) !important;
border-color: rgba(31,26,18,0.10) !important;
box-shadow: 0 2px 8px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.9) !important;
}
[data-theme="kabylie"] .ctrl-home,
[data-theme="desert"] .ctrl-home,
[data-theme="modern"] .ctrl-home {
color: #555 !important;
}
[data-theme="kabylie"] .ctrl-undo,
[data-theme="desert"] .ctrl-undo,
[data-theme="modern"] .ctrl-undo {
color: #1565c0 !important;
}
[data-theme="kabylie"] .ctrl-restart,
[data-theme="desert"] .ctrl-restart,
[data-theme="modern"] .ctrl-restart {
color: #2e7d32 !important;
}
[data-theme="kabylie"] .ctrl-surrender,
[data-theme="desert"] .ctrl-surrender,
[data-theme="modern"] .ctrl-surrender {
color: #c62828 !important;
}
[data-theme="kabylie"] .ctrl-btn:hover:not(:disabled),
[data-theme="desert"] .ctrl-btn:hover:not(:disabled),
[data-theme="modern"] .ctrl-btn:hover:not(:disabled) {
background: rgba(255,255,255,0.96) !important;
box-shadow: 0 6px 18px rgba(0,0,0,0.12) !important;
}

/* Mobile compact */
@media (max-width: 480px) {
.controls {
gap: 0.4rem !important;
}
.ctrl-btn {
min-height: 54px !important;
border-radius: 12px !important;
padding: 0.5rem 0.35rem !important;
}
.ctrl-icon {
width: 18px !important;
height: 18px !important;
}
.ctrl-label {
font-size: 0.62rem !important;
}
}

/* Close btn wiring (JS) */

/* ═══════════════════════════════════════════════════════════
   PATCH v12 — Player Setup Area — Full Redesign
   ═══════════════════════════════════════════════════════════ */

/* ── Reset old player-setup styles ── */
.player-setup-area {
gap: 1.6rem !important;
padding: clamp(1.6rem, 5vw, 2.8rem) clamp(1.4rem, 4vw, 2.4rem) !important;
background: var(--panel-bg, rgba(0,0,0,0.42)) !important;
border: 1px solid rgba(255,255,255,0.10) !important;
box-shadow: 0 32px 80px rgba(0,0,0,0.36), inset 0 1px 0 rgba(255,255,255,0.06) !important;
border-radius: 24px !important;
backdrop-filter: blur(18px) !important;
-webkit-backdrop-filter: blur(18px) !important;
max-width: 700px !important;
align-items: stretch !important;
}
[data-theme="kabylie"] .player-setup-area,
[data-theme="desert"] .player-setup-area,
[data-theme="modern"] .player-setup-area {
border-color: rgba(31,26,18,0.10) !important;
box-shadow: 0 24px 60px rgba(0,0,0,0.12), 0 0 0 1px rgba(255,255,255,0.55), inset 0 1px 0 rgba(255,255,255,0.8) !important;
}

/* ── Header ── */
.psu-header {
text-align: center;
padding-bottom: 0.5rem;
border-bottom: 1px solid rgba(255,255,255,0.08);
}
[data-theme="kabylie"] .psu-header,
[data-theme="desert"] .psu-header,
[data-theme="modern"] .psu-header {
border-bottom-color: rgba(31,26,18,0.08);
}

.psu-eyebrow {
font-size: 0.78rem;
font-weight: 700;
letter-spacing: 0.28em;
text-transform: uppercase;
color: var(--text-gold);
opacity: 0.65;
margin-bottom: 0.3rem;
}

.psu-title {
font-size: clamp(1.6rem, 4.5vw, 2.2rem) !important;
font-weight: 900 !important;
letter-spacing: 0.04em !important;
color: var(--text-main) !important;
text-shadow: none !important;
margin-bottom: 0.2rem !important;
line-height: 1.15 !important;
}

.psu-subtitle {
font-size: clamp(0.82rem, 2.2vw, 0.95rem) !important;
font-weight: 500 !important;
opacity: 0.55 !important;
margin: 0 !important;
color: var(--text-muted) !important;
}

/* ── Players row ── */
.psu-players-row {
display: flex;
align-items: center;
gap: 1rem;
width: 100%;
}

/* ── Player card ── */
.psu-player-card {
flex: 1;
display: flex;
flex-direction: column;
align-items: center;
gap: 1rem;
padding: 1.4rem 1rem 1.2rem;
border-radius: 18px;
border: 1px solid rgba(255,255,255,0.08);
background: rgba(255,255,255,0.03);
transition: border-color 0.2s ease, box-shadow 0.2s ease;
position: relative;
overflow: hidden;
}
.psu-player-card::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
height: 2px;
border-radius: 18px 18px 0 0;
opacity: 0.55;
}
.psu-p1::before {
background: linear-gradient(90deg, transparent, #555, transparent);
}
.psu-p2::before {
background: linear-gradient(90deg, transparent, #e0e0e0, transparent);
}

[data-theme="kabylie"] .psu-player-card,
[data-theme="desert"] .psu-player-card,
[data-theme="modern"] .psu-player-card {
border-color: rgba(31,26,18,0.09);
background: rgba(255,255,255,0.55);
}

/* ── Stone visuals ── */
.psu-stone-wrap {
position: relative;
display: flex;
align-items: center;
justify-content: center;
width: 72px;
height: 72px;
}

.psu-stone {
width: 60px !important;
height: 60px !important;
border-radius: 50% !important;
position: relative;
z-index: 1;
flex-shrink: 0;
box-shadow: 0 8px 24px rgba(0,0,0,0.45), inset 0 -6px 14px rgba(0,0,0,0.4), inset 0 6px 10px rgba(255,255,255,0.35) !important;
transition: transform 0.3s ease, box-shadow 0.3s ease;
}
.psu-stone::after {
display: none !important;
}

.psu-stone-ring {
position: absolute;
inset: -4px;
border-radius: 50%;
border: 2px solid transparent;
transition: border-color 0.3s ease, box-shadow 0.3s ease;
}
.psu-p1:focus-within .psu-stone-ring-p1,
.psu-p1:hover .psu-stone-ring-p1 {
border-color: rgba(150,150,150,0.45);
box-shadow: 0 0 18px rgba(100,100,100,0.25);
}
.psu-p2:focus-within .psu-stone-ring-p2,
.psu-p2:hover .psu-stone-ring-p2 {
border-color: rgba(240,200,80,0.45);
box-shadow: 0 0 18px rgba(240,200,80,0.20);
}

/* ── Player info block ── */
.psu-player-info {
display: flex;
flex-direction: column;
align-items: center;
gap: 0.5rem;
width: 100%;
}

.psu-player-tag {
font-size: 0.72rem !important;
font-weight: 700 !important;
text-transform: uppercase !important;
letter-spacing: 0.12em !important;
color: var(--text-muted) !important;
opacity: 0.7 !important;
cursor: default;
}

.psu-input-wrap {
width: 100%;
max-width: 100%;
}

.psu-name-input {
width: 100% !important;
padding: 0.65rem 0.9rem !important;
font-size: 1rem !important;
font-weight: 600 !important;
font-family: var(--font-body) !important;
border-radius: 10px !important;
border: 1px solid rgba(255,255,255,0.14) !important;
background: rgba(255,255,255,0.06) !important;
color: var(--text-main) !important;
outline: none !important;
box-shadow: inset 0 2px 6px rgba(0,0,0,0.18) !important;
transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease !important;
text-align: center !important;
min-height: 48px !important;
}
.psu-name-input::placeholder {
color: var(--text-muted, rgba(255,255,255,0.38)) !important;
font-weight: 500 !important;
opacity: 0.55 !important;
}
.psu-name-input:focus {
border-color: var(--text-gold, rgba(240,200,80,0.7)) !important;
background: rgba(255,255,255,0.09) !important;
box-shadow: inset 0 2px 6px rgba(0,0,0,0.12), 0 0 0 3px rgba(240,200,80,0.18) !important;
}

[data-theme="kabylie"] .psu-name-input,
[data-theme="desert"] .psu-name-input,
[data-theme="modern"] .psu-name-input {
background: rgba(255,255,255,0.85) !important;
border-color: rgba(31,26,18,0.16) !important;
color: var(--text-main) !important;
box-shadow: inset 0 1px 4px rgba(0,0,0,0.07) !important;
}
[data-theme="kabylie"] .psu-name-input::placeholder,
[data-theme="desert"] .psu-name-input::placeholder,
[data-theme="modern"] .psu-name-input::placeholder {
color: rgba(31,26,18,0.35) !important;
opacity: 1 !important;
}
[data-theme="kabylie"] .psu-name-input:focus,
[data-theme="desert"] .psu-name-input:focus {
border-color: var(--kab-blue, var(--text-gold)) !important;
box-shadow: inset 0 1px 4px rgba(0,0,0,0.06), 0 0 0 3px rgba(30,136,229,0.16) !important;
}

/* ── VS divider ── */
.psu-vs {
display: flex;
flex-direction: column;
align-items: center;
flex-shrink: 0;
gap: 0;
}
.psu-vs-text {
font-size: clamp(1.1rem, 3vw, 1.5rem);
font-weight: 900;
letter-spacing: 0.08em;
color: var(--text-gold);
opacity: 0.45;
line-height: 1;
}

/* ── Color section ── */
.psu-color-section {
border: 1px solid rgba(255,255,255,0.07) !important;
background: rgba(255,255,255,0.025) !important;
border-radius: 16px !important;
padding: 1.1rem 1.2rem !important;
gap: 0.8rem !important;
box-shadow: none !important;
width: 100% !important;
align-items: stretch !important;
}
[data-theme="kabylie"] .psu-color-section,
[data-theme="desert"] .psu-color-section,
[data-theme="modern"] .psu-color-section {
border-color: rgba(31,26,18,0.08) !important;
background: rgba(31,26,18,0.025) !important;
}

.psu-color-label {
font-size: 0.75rem !important;
font-weight: 700 !important;
text-transform: uppercase !important;
letter-spacing: 0.14em !important;
color: var(--text-muted) !important;
opacity: 0.65 !important;
margin: 0 !important;
display: block;
}

.psu-color-group {
display: flex !important;
gap: 0.7rem !important;
margin: 0 !important;
flex-wrap: nowrap !important;
}

/* ── Color option cards ── */
.psu-color-opt {
flex: 1 !important;
min-width: 0 !important;
max-width: 100% !important;
border-radius: 14px !important;
padding: 0 !important;
background: rgba(255,255,255,0.04) !important;
border: 1.5px solid rgba(255,255,255,0.10) !important;
box-shadow: none !important;
cursor: pointer !important;
transition: border-color 0.18s ease, box-shadow 0.18s ease, background 0.18s ease !important;
overflow: hidden !important;
transform: none !important;
}
.psu-color-opt:hover {
transform: none !important;
box-shadow: 0 4px 16px rgba(0,0,0,0.18) !important;
border-color: rgba(255,255,255,0.22) !important;
}
.psu-color-opt.selected,
.psu-color-opt:has(input:checked) {
background: rgba(240,200,80,0.10) !important;
border-color: var(--text-gold, rgba(240,200,80,0.7)) !important;
box-shadow: 0 0 0 3px rgba(240,200,80,0.18), 0 6px 20px rgba(0,0,0,0.18) !important;
transform: none !important;
}

[data-theme="kabylie"] .psu-color-opt,
[data-theme="desert"] .psu-color-opt,
[data-theme="modern"] .psu-color-opt {
background: rgba(255,255,255,0.75) !important;
border-color: rgba(31,26,18,0.10) !important;
}
[data-theme="kabylie"] .psu-color-opt.selected,
[data-theme="kabylie"] .psu-color-opt:has(input:checked),
[data-theme="desert"] .psu-color-opt.selected,
[data-theme="desert"] .psu-color-opt:has(input:checked) {
background: rgba(30,136,229,0.07) !important;
border-color: rgba(30,136,229,0.55) !important;
box-shadow: 0 0 0 3px rgba(30,136,229,0.14), 0 4px 16px rgba(0,0,0,0.10) !important;
}

/* Inner layout */
.psu-opt-inner {
display: flex;
align-items: center;
gap: 0.8rem;
padding: 0.75rem 0.9rem;
width: 100%;
}

.psu-opt-stone {
width: 38px !important;
height: 38px !important;
border-radius: 50% !important;
flex-shrink: 0 !important;
box-shadow: 0 4px 10px rgba(0,0,0,0.35), inset 0 -4px 8px rgba(0,0,0,0.3), inset 0 3px 6px rgba(255,255,255,0.3) !important;
transition: transform 0.2s ease, box-shadow 0.2s ease !important;
}
.psu-opt-stone::after {
display: none !important;
}
.psu-color-opt.selected .psu-opt-stone,
.psu-color-opt:has(input:checked) .psu-opt-stone {
transform: scale(1.12) !important;
box-shadow: 0 6px 16px rgba(0,0,0,0.45), inset 0 -4px 8px rgba(0,0,0,0.3), inset 0 4px 8px rgba(255,255,255,0.35) !important;
}

.psu-opt-text {
flex: 1;
min-width: 0;
display: flex;
flex-direction: column;
gap: 0.1rem;
}

.psu-opt-name {
font-size: clamp(0.82rem, 2.5vw, 0.95rem) !important;
font-weight: 800 !important;
letter-spacing: 0.02em !important;
color: var(--text-main) !important;
line-height: 1.2 !important;
display: block !important;
}

.psu-opt-desc {
font-size: 0.68rem !important;
font-weight: 500 !important;
opacity: 0.52 !important;
color: var(--text-muted) !important;
display: block !important;
line-height: 1.3 !important;
}

/* Checkmark SVG */
.psu-opt-check {
width: 22px;
height: 22px;
border-radius: 50%;
border: 1.5px solid rgba(255,255,255,0.22);
display: flex;
align-items: center;
justify-content: center;
flex-shrink: 0;
transition: background 0.18s ease, border-color 0.18s ease;
color: transparent;
}
.psu-color-opt.selected .psu-opt-check,
.psu-color-opt:has(input:checked) .psu-opt-check {
background: var(--text-gold, #f0c850);
border-color: var(--text-gold, #f0c850);
color: #1a1206;
}
[data-theme="kabylie"] .psu-opt-check,
[data-theme="desert"] .psu-opt-check,
[data-theme="modern"] .psu-opt-check {
border-color: rgba(31,26,18,0.18);
}
[data-theme="kabylie"] .psu-color-opt.selected .psu-opt-check,
[data-theme="kabylie"] .psu-color-opt:has(input:checked) .psu-opt-check {
background: var(--kab-blue, #1e88e5);
border-color: var(--kab-blue, #1e88e5);
color: #fff;
}
.psu-opt-check svg {
width: 12px;
height: 12px;
stroke: currentColor;
display: block;
}

/* Hide the old emoji checkmark (JS uses .selected class) */
.psu-color-opt .checkmark {
display: none !important;
}

/* ── start-game-btn tweaks for this screen ── */
.player-setup-area .start-game-btn {
width: 100% !important;
max-width: 400px !important;
margin: 0.2rem auto 0 !important;
align-self: center !important;
justify-content: center !important;
gap: 0.7rem !important;
font-size: clamp(1.1rem, 3.5vw, 1.4rem) !important;
letter-spacing: 0.08em !important;
padding: 1.05rem 2rem !important;
}
.player-setup-area .start-game-btn svg {
width: 20px;
height: 20px;
flex-shrink: 0;
}
/* Remove emoji icon inside btn (replaced by SVG) */
.player-setup-area .start-game-btn .icon {
display: none !important;
}

/* ── back-btn centré ── */
.player-setup-area .back-btn {
align-self: center !important;
margin-top: 0 !important;
position: static !important;
}

/* ── Mobile stacking ── */
@media (max-width: 500px) {
.psu-players-row {
flex-direction: column !important;
gap: 0.6rem !important;
}
.psu-vs {
flex-direction: row !important;
}
.psu-vs-text {
font-size: 1rem !important;
opacity: 0.35 !important;
}
.psu-player-card {
flex-direction: row !important;
padding: 0.9rem 1rem !important;
gap: 0.9rem !important;
align-items: center !important;
}
.psu-stone-wrap {
width: 52px;
height: 52px;
}
.psu-stone {
width: 44px !important;
height: 44px !important;
}
.psu-player-info {
align-items: flex-start !important;
}
.psu-name-input {
text-align: left !important;
}
.psu-color-group {
flex-direction: column !important;
gap: 0.5rem !important;
}
}

/* ── CSP-safe utility classes (replaces inline style="…" attrs) ── */
.stat-mt {
margin-top: 10px;
}
.stat-detail {
margin-top: 4px;
font-size: 0.95rem;
}
.stat-detail-b {
margin-top: 8px;
font-size: 0.95rem;
}
.xp-sub {
font-size: 0.85rem;
opacity: 0.9;
display: inline;
}
.xp-footer {
margin-top: 6px;
font-size: 0.86rem;
opacity: 0.9;
}
.btn-label {
font-size: 0.92rem;
font-weight: 600;
}
.guided-btn-hidden {
display: none !important;
position: absolute;
pointer-events: none;
}
.checkmark-hidden {
display: none;
}

/* ── Pions des cartes joueur : couleur selon player1/player2 ── */
.psu-player-card .stone-preview.player1,
.psu-color-opt .stone-preview.player1 {
background: radial-gradient(circle at 35% 35%, var(--player1-stone-color-light), var(--player1-stone-color-dark) 60%, #000 90%);
transition: background 0.3s ease, transform 0.25s ease;
}
.psu-player-card .stone-preview.player2,
.psu-color-opt .stone-preview.player2 {
background: radial-gradient(circle at 35% 35%, var(--player2-stone-color-light), var(--player2-stone-color-dark) 60%, #e0e0e0 90%);
transition: background 0.3s ease, transform 0.25s ease;
}

/* ═══════════════════════════════════════════════════════════
   PATCH FINAL — Ergonomie, no-scroll, refonte layout jeu
   ═══════════════════════════════════════════════════════════ */

/* ── Zone de jeu : disposition ultra-compacte ── */
.game-play-area.active {
  gap: 0.45rem !important;
  padding: 0.4rem 0.5rem !important;
}

/* ── Panneau joueur : hauteur réduite ── */
.player-info {
  padding: 0.55rem 0.75rem !important;
}
.player-title {
  font-size: clamp(0.85rem, 2.5vw, 1rem) !important;
  margin-bottom: 0.35rem !important;
}
.player-stats {
  gap: 0.6rem !important;
}
.stat-value {
  font-size: clamp(1rem, 3vw, 1.2rem) !important;
}

/* ── Barre d'info : plus fine ── */
.game-info-display {
  padding: 0.4rem 0.8rem !important;
  gap: 0.75rem !important;
  font-size: clamp(0.78rem, 2vw, 0.88rem) !important;
  border-radius: 8px !important;
}

/* ── Bandeau de statut : plus compact ── */
.status {
  padding: 0.45rem 0.75rem !important;
  min-height: 38px !important;
  font-size: clamp(0.88rem, 2.5vw, 1rem) !important;
  border-radius: 8px !important;
}

/* ── Contrôles : hauteur minimale ── */
.controls {
  padding-top: 0.2rem !important;
  gap: 0.5rem !important;
}
.controls button,
.ctrl-btn {
  padding: 0.5rem 0.8rem !important;
  min-height: 40px !important;
  font-size: clamp(0.75rem, 2.2vw, 0.82rem) !important;
}

/* ── Colonne centrale : gap serré ── */
.center-column {
  gap: 0.4rem !important;
}

/* ── Plateau : taille adaptée pour tenir sur écran ── */
.game-board-container {
  width: min(90vw, calc(100dvh - 16rem), 520px) !important;
}

/* Desktop wide : rétablir une taille généreuse ── */
@media (min-width: 1200px) {
  .game-board-container {
    width: clamp(380px, 60vh, 600px) !important;
  }
  .game-play-area.active {
    gap: 1rem !important;
    padding: 0.5rem 1.5rem !important;
  }
}

/* Paysage mobile : plateau plus petit ── */
@media (max-height: 600px) {
  .game-board-container {
    width: min(88vw, 55vh, 380px) !important;
  }
  .game-info-display { display: none !important; }
  header { display: none !important; }
}

/* ── Header masqué pendant la partie ── */
.game-play-area.active ~ header,
body:has(.game-play-area.active) header {
  height: 0 !important;
  padding: 0 !important;
  overflow: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* ── Footer : invisible pendant la partie ── */
body:has(.game-play-area.active) footer {
  display: none !important;
}

/* ── Panneau latéral desktop : centrage vertical ── */
@media (min-width: 1200px) {
  .player-panel-container {
    max-height: 100%;
    justify-content: center !important;
  }
  .player-panel {
    max-width: 260px !important;
  }
}

/* ── Padding bas réduit (FAB) ── */
@media (max-width: 720px) {
  .game-play-area.active {
    padding-bottom: 4rem !important;
  }
}

/* ── Bouton Paramètres : modernisé, sans vert ── */
#settings-fab {
  background: rgba(22, 16, 10, 0.88) !important;
  border: 1.5px solid rgba(240,200,80,0.38) !important;
  color: var(--text-gold, #f0c850) !important;
  box-shadow: 0 4px 16px rgba(0,0,0,0.40), inset 0 1px 0 rgba(255,255,255,0.05) !important;
  backdrop-filter: blur(10px) !important;
  -webkit-backdrop-filter: blur(10px) !important;
}
#settings-fab:hover {
  background: rgba(40, 28, 14, 0.95) !important;
  border-color: rgba(240,200,80,0.60) !important;
  box-shadow: 0 6px 22px rgba(0,0,0,0.50), 0 0 12px rgba(240,200,80,0.16) !important;
  transform: translateY(-2px) !important;
}
#settings-fab.open {
  transform: none !important;
  border-color: rgba(240,200,80,0.55) !important;
}

/* Supprimer le pulse vert résiduel */
#settings-fab::before { content: none !important; animation: none !important; }

</style>

    <!-- Parse JS SDK (Back4App) -->
    <script src="https://unpkg.com/parse/dist/parse.min.js"></script>
</head>
<body>
<!-- ===== LANGUAGE SPLASH SCREEN ===== -->
<div aria-label="Choix de la langue / Tifert n tutlayt" aria-modal="true" id="lang-splash" role="dialog">
<div class="splash-logo">
TIDDAS
</div>
<div class="splash-tifinagh">
ⵜⵉⴷⴷⴰⵙ
</div>
<div class="splash-divider"></div>
<p class="splash-prompt">
Choisissez votre langue  /  Fren tutlayt-ik
</p>
<div class="splash-langs">
<button aria-label="Français" class="splash-lang-btn" data-lang="fr">
<span class="splash-lang-flag">FR</span>
<span class="splash-lang-name">Français</span>
<span class="splash-lang-sub">Jouer en français</span>
</button>
<button aria-label="Taqbaylit" class="splash-lang-btn" data-lang="kab">
<span class="splash-lang-flag">ⵣ</span>
<span class="splash-lang-name">Taqbaylit</span>
<span class="splash-lang-sub">Urar s taqbaylit</span>
</button>
<button aria-label="English" class="splash-lang-btn" data-lang="en">
<span class="splash-lang-flag">EN</span>
<span class="splash-lang-name">English</span>
<span class="splash-lang-sub">Play in English</span>
</button>
</div>
<p class="splash-footer">
Patrimoine Amazigh • Idles Amaziɣ
</p>
</div>
<div class="toolbar-buttons" id="toolbar-buttons">
<!-- Hidden guided btn (JS refs preserved) -->
<button aria-label="Mode guidé" aria-pressed="true" id="guided-btn" class="guided-btn-hidden" title="Mode guidé"></button>
<div class="settings-tray" id="settings-tray">
<div class="stray-panel">
<div class="stray-header">
<span class="stray-title">⚙️ Paramètres</span>
<button aria-label="Fermer" class="stray-close-btn" id="stray-close-btn" type="button">✕</button>
</div>
<div class="stray-section">
<span class="stray-section-label">Apparence</span>
<div class="stray-grid">
<button aria-label="Thème" class="toolbar-btn stray-item" id="theme-btn" title="Changer de thème">
<span class="stray-icon">🎨</span>
<span class="stray-item-label" data-i18n="btnTheme">Thème</span>
</button>
<button aria-label="Son" class="toolbar-btn stray-item" id="sound-btn" title="Son On/Off">
<span class="stray-icon">🔊</span>
<span class="stray-item-label" data-i18n="btnSound">Son</span>
</button>
</div>
</div>
<div class="stray-section">
<span class="stray-section-label">Langue</span>
<div class="language-selector">
<span aria-hidden="true" class="icon">🗣️</span>
<select aria-label="Langue / Tutlayt" id="language-select">
<option value="fr">Français</option>
<option value="kab">ⵣ Taqbaylit</option>
<option value="en">English</option>
</select>
</div>
</div>
<div class="stray-section">
<span class="stray-section-label">Jeu</span>
<div class="stray-grid">
<button aria-label="Glisser" aria-pressed="false" class="toolbar-btn stray-item" id="drag-btn" title="Déplacer les pions par glissement">
<span class="stray-icon">🤚</span>
<span class="stray-item-label" data-i18n="btnDragMode">Glisser</span>
</button>
<button aria-label="Replay" class="toolbar-btn stray-item" disabled="" id="replay-btn" title="Revoir la dernière partie">
<span class="stray-icon">⏯️</span>
<span class="stray-item-label" data-i18n="replayLast">Replay</span>
</button>
<button aria-label="Stats" class="toolbar-btn stray-item" id="stats-btn" title="Statistiques">
<span class="stray-icon">📈</span>
<span class="stray-item-label" data-i18n="stats">Stats</span>
</button>
<button aria-label="Installer" class="toolbar-btn stray-item" id="install-btn" title="Installer l'application">
<span class="stray-icon">⬇️</span>
<span class="stray-item-label" data-i18n="installApp">Installer</span>
</button>
</div>
</div>
</div>
</div>
<button aria-label="Paramètres" id="settings-fab" title="Paramètres"><span aria-hidden="true" class="settings-icon">⚙️</span><span class="settings-label" data-i18n="btnSettings">Paramètres</span></button>
</div>
<div class="stone-decoration stone-1">
ⵣ
</div>
<div class="stone-decoration stone-2">
ⵣ
</div>
<div class="stone-decoration stone-3">
ⵣ
</div>
<div class="stone-decoration stone-4">
ⵣ
</div>
<header id="main-header">
<h1 data-i18n="appTitle">TIDDAS</h1>
</header>
<div class="game-container">
<div class="selection-area active" id="version-selection-area">
<h2 data-i18n="chooseVersion">Choisir la version du jeu :</h2>
<div class="version-grid">
<div class="version-card" data-variant="TIDDEST-no-diag">
<h3 data-i18n="TIDDESTTitle">TIDDEST</h3>
<p data-i18n="TIDDESTDesc">
Pas de capture pendant le placement. Interdiction d'aligner 3 pions pendant le placement. Déplacements et captures uniquement horizontaux/verticaux. Victoire normale.
</p>
</div>
<div class="version-card" data-variant="bessif-TIDDEST">
<h3 data-i18n="bessifTitle">Učči bessif TIDDEST</h3>
<p data-i18n="bessifDesc">
Mêmes règles que TIDDEST. Victoire inversée: gagnez en perdant tous vos pions. Quand vous formez un moulin, votre adversaire choisit un de ses pions à capturer.
</p>
</div>
</div>
<div class="version-btns-row">
<button class="rules-btn" id="show-rules-btn">
<span aria-hidden="true" class="icon">📖</span>
<span data-i18n="gameRulesTitle">Règles du jeu</span>
</button>
<button class="rules-btn about-btn" id="show-about-btn">
<span aria-hidden="true" class="icon">
<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" /><line x1="12" y1="16" x2="12" y2="12" /><line x1="12" y1="8" x2="12.01" y2="8" /></svg>
</span>
<span data-i18n="aboutBtnLabel">À propos</span>
</button>
</div>
</div>
<div class="selection-area" id="mode-selection-area">
<h2 data-i18n="howToPlay">Comment souhaitez-vous jouer ?</h2>
<div class="options-group">
<button class="option-btn" id="play-online-btn">
<span aria-hidden="true" class="icon">🌐</span>
<span data-i18n="playOnline">Jouer en ligne</span>
<span data-i18n="playOnlineDesc">Créer ou rejoindre une partie</span>
</button>
<button class="option-btn" id="play-ai-btn">
<span aria-hidden="true" class="icon">🤖</span>
<span data-i18n="playAI">Jouer contre l'ordinateur</span>
<span data-i18n="playAIDesc">Affrontez une intelligence artificielle</span>
</button>
<button class="option-btn" id="play-offline-btn">
<span aria-hidden="true" class="icon">👥</span>
<span data-i18n="playOffline">Jouer hors-ligne</span>
<span data-i18n="playOfflineDesc">Partie locale sur votre appareil</span>
</button>
<button class="option-btn" id="play-spectator-btn">
<span aria-hidden="true" class="icon">👁️</span>
<span data-i18n="playSpectator">Mode Spectateur</span>
<span data-i18n="playSpectatorDesc">Regardez deux IA s'affronter</span>
</button>
</div>
<button class="back-btn" data-i18n="backToVersions" id="back-to-versions-btn">Retour aux versions</button>
</div>
<div class="selection-area online-lobby" id="online-lobby-area">

  <!-- En-tête -->
  <div class="ol-header">
    <div class="ol-header-icon" aria-hidden="true">
      <svg viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="20" cy="20" r="19" stroke="currentColor" stroke-width="1.5" opacity=".35"/>
        <circle cx="20" cy="20" r="13" stroke="currentColor" stroke-width="1.5" opacity=".55"/>
        <circle cx="20" cy="20" r="3.5" fill="currentColor"/>
        <line x1="20" y1="1" x2="20" y2="8"  stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        <line x1="20" y1="32" x2="20" y2="39" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        <line x1="1"  y1="20" x2="8"  y2="20" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        <line x1="32" y1="20" x2="39" y2="20" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
      </svg>
    </div>
    <h2 class="ol-title" data-i18n="onlineTitle">Multijoueur en ligne</h2>
    <p class="ol-subtitle" data-i18n="onlineSubtitle">Jouez avec n'importe qui, partout dans le monde</p>
    <p id="online-status-global" class="ol-global-msg" aria-live="polite"></p>
  </div>

  <div class="ol-body">

    <!-- ─── Colonne gauche : configuration ─────────────────── -->
    <div class="ol-col-setup">

      <!-- Bloc Pseudo -->
      <section class="ol-section" aria-label="Votre pseudo">
        <label class="ol-section-label" for="online-your-name">
          <span class="ol-section-num">01</span>Votre pseudo
        </label>
        <div class="ol-input-wrap">
          <span class="ol-input-icon" aria-hidden="true">
            <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="10" cy="7" r="3.5"/><path d="M2.5 17c0-3.314 3.358-6 7.5-6s7.5 2.686 7.5 6"/>
            </svg>
          </span>
          <input class="ol-input" id="online-your-name" maxlength="24"
                 autocomplete="nickname" inputmode="text"
                 data-i18n-placeholder="onlineNamePlaceholder" placeholder="Ex: Boussad" />
        </div>
        <p class="ol-hint" data-i18n="onlineNameHint">Mémorisé localement sur cet appareil</p>
      </section>

      <!-- Bloc Salon -->
      <section class="ol-section" aria-label="Rejoindre ou créer un salon">
        <div class="ol-section-label">
          <span class="ol-section-num">02</span>Salon de jeu
        </div>

        <div class="ol-actions">
          <button class="ol-action-btn ol-action-create" id="online-create-room" type="button">
            <span class="ol-action-icon" aria-hidden="true">
              <svg viewBox="0 0 22 22" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="16" height="16" rx="4"/>
                <line x1="11" y1="7.5" x2="11" y2="14.5"/>
                <line x1="7.5" y1="11" x2="14.5" y2="11"/>
              </svg>
            </span>
            <span class="ol-action-main" data-i18n="onlineCreate">Créer un salon</span>
            <span class="ol-action-sub" data-i18n="onlineCreateDesc">Générer un code unique</span>
          </button>

          <button class="ol-action-btn ol-action-join" id="online-join-room" type="button">
            <span class="ol-action-icon" aria-hidden="true">
              <svg viewBox="0 0 22 22" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 3h5v5"/><path d="M19 3l-8 8"/><path d="M9 5H5a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4"/>
              </svg>
            </span>
            <span class="ol-action-main" data-i18n="onlineJoin">Rejoindre</span>
            <span class="ol-action-sub" data-i18n="onlineJoinDesc">Entrer un code ami</span>
          </button>

          <button class="ol-action-btn ol-action-recent" id="online-recent-toggle" type="button" style="display:none;">
            <span class="ol-action-icon" aria-hidden="true">
              <svg viewBox="0 0 22 22" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"/><polyline points="11 7 11 11 14 13"/>
              </svg>
            </span>
            <span class="ol-action-main" data-i18n="onlineRecentRooms">Récents</span>
            <span class="ol-action-sub" data-i18n="onlineRejoinLastDesc">Reprendre une partie</span>
          </button>
        </div>

        <!-- Panneau accordéon : Créer -->
        <div class="ol-panel" id="online-create-panel">
          <div class="ol-preview-box" id="online-code-preview-box" style="display:none;">
            <div class="ol-preview-label" data-i18n="onlineCodePreview">Votre code de salon</div>
            <div class="ol-preview-code-wrap">
              <strong class="ol-preview-code" id="online-preview-code">——</strong>
              <div class="ol-preview-dots">
                <span></span><span></span><span></span><span></span>
              </div>
            </div>
            <button class="ol-confirm-btn" id="online-preview-confirm" type="button">
              <span data-i18n="onlineCodeConfirm">Créer ce salon</span>
              <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 8 7 12 13 4"/>
              </svg>
            </button>
          </div>
        </div>

        <!-- Panneau accordéon : Rejoindre -->
        <div class="ol-panel" id="online-join-panel">
          <div class="ol-join-wrap">
            <div class="ol-join-label" data-i18n="onlineJoin">Code du salon</div>
            <div class="ol-code-row">
              <input class="online-code-input ol-code-input" id="online-room-code"
                     inputmode="latin" autocomplete="off" spellcheck="false"
                     maxlength="6" placeholder="· · · ·"
                     style="text-transform:uppercase" aria-label="Code du salon" />
              <button class="ol-connect-btn" id="online-connect" type="button" disabled>
                <svg viewBox="0 0 18 18" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
                  <polyline points="4 9 14 9"/><polyline points="9 4 14 9 9 14"/>
                </svg>
              </button>
            </div>
          </div>
        </div>

        <!-- Panneau accordéon : Salons récents -->
        <div class="ol-panel" id="online-recent-wrap">
          <div class="ol-recent-header" data-i18n="onlineRecentRooms">Parties récentes</div>
          <div class="online-recent-list" id="online-recent-list"></div>
        </div>

      </section>
    </div><!-- /ol-col-setup -->

    <!-- ─── Colonne droite : statut (hidden until connected) ── -->
    <div class="ol-col-status" id="online-status" style="display:none;">

      <!-- Statut texte -->
      <div class="ol-status-banner">
        <span class="ol-status-dot" id="ol-status-dot" aria-hidden="true"></span>
        <span id="online-status-text" class="ol-status-text">—</span>
      </div>

      <!-- Joueurs -->
      <div class="ol-players">
        <div class="ol-player" id="ol-p1-slot">
          <div class="ol-player-avatar">
            <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="10" cy="7" r="3"/><path d="M3 17c0-3 3.134-5 7-5s7 2 7 5"/>
            </svg>
          </div>
          <div class="ol-player-info">
            <span class="ol-player-tag">J1</span>
            <span class="ol-player-name" id="online-p1-name">En attente…</span>
          </div>
          <span class="ol-player-status-dot"></span>
        </div>
        <div class="ol-versus" aria-hidden="true">VS</div>
        <div class="ol-player" id="ol-p2-slot">
          <div class="ol-player-avatar">
            <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="10" cy="7" r="3"/><path d="M3 17c0-3 3.134-5 7-5s7 2 7 5"/>
            </svg>
          </div>
          <div class="ol-player-info">
            <span class="ol-player-tag">J2</span>
            <span class="ol-player-name" id="online-p2-name">En attente…</span>
          </div>
          <span class="ol-player-status-dot"></span>
        </div>
      </div>

      <!-- Code de room + partage -->
      <div class="ol-share-block" id="online-roomcode-row" style="display:none;">
        <div class="ol-share-label" data-i18n="onlineShare">Invitez un ami</div>
        <div class="ol-share-code-row">
          <span class="ol-share-code" id="online-roomcode">—</span>
          <button class="ol-icon-btn" id="online-copy-code" type="button"
                  aria-label="Copier le code" data-i18n-aria-label="onlineCopyCodeAria" title="Copier le code">
            <svg viewBox="0 0 18 18" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <rect x="6" y="6" width="9" height="9" rx="2"/><path d="M3 12V3h9"/>
            </svg>
          </button>
        </div>

        <!-- Panneau inviter -->
        <button class="ol-invite-toggle" id="online-invite-toggle" type="button" aria-expanded="false">
          <svg viewBox="0 0 18 18" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
            <path d="M16 12.5c0 .83-.18 1.62-.5 2.33L12 12.5l-.5-4.5 4.5-.5c.32.71.5 1.5.5 2.5z" opacity=".0"/>
            <path d="M2 9l7-7 2 2-5 5 3 3-2 2-5-5z"/><path d="M12 2l4 4-6 6"/>
          </svg>
          <span data-i18n="onlineInviteBtn">Partager l'invitation</span>
          <svg class="ol-chevron" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <polyline points="2 4 6 8 10 4"/>
          </svg>
        </button>

        <div class="ol-invite-panel" id="online-invite-panel" role="region">
          <div class="ol-invite-row">
            <span class="ol-inv-label" data-i18n="onlinePanelCode">Code</span>
            <span class="ol-inv-value" id="inv-code-val">—</span>
            <button class="ol-inv-btn" id="inv-copy-code-btn" type="button">Copier</button>
          </div>
          <div class="ol-invite-row">
            <span class="ol-inv-label" data-i18n="onlinePanelLink">Lien</span>
            <span class="ol-inv-value" id="inv-link-val">…</span>
            <button class="ol-inv-btn" id="inv-copy-link-btn" type="button">Copier</button>
          </div>
          <div class="ol-invite-row" id="inv-share-row" style="display:none;">
            <span class="ol-inv-label" data-i18n="onlinePanelShare">Partager</span>
            <span class="ol-inv-value"></span>
            <button class="ol-inv-btn" id="inv-share-btn" type="button" data-i18n="onlinePanelShare">Partager</button>
          </div>
        </div>
      </div>

      <!-- Revanche -->
      <div class="ol-rematch" id="online-rematch" style="display:none;">
        <div class="ol-rematch-title" data-i18n="onlineRematchHint">Proposer une revanche</div>
        <div class="ol-rematch-row" aria-label="Rematch readiness">
          <span class="ol-rematch-chip" id="online-rm1-chip">J1</span>
          <span class="ol-rematch-divider" aria-hidden="true">·</span>
          <span class="ol-rematch-chip" id="online-rm2-chip">J2</span>
        </div>
        <button class="ol-rematch-btn" id="online-rematch-ready-btn" type="button" data-i18n="onlineReadyRematch">Je suis prêt</button>
        <p class="ol-rematch-note" data-i18n="onlineRematchNote">Les couleurs alternent à chaque revanche.</p>
      </div>

      <!-- Lancer -->
      <button class="ol-start-btn" id="online-start" style="display:flex;" type="button">
        <span class="ol-start-icon" aria-hidden="true">
          <svg viewBox="0 0 20 20" fill="currentColor"><path d="M5 4l12 6-12 6V4z"/></svg>
        </span>
        <span class="ol-start-text">
          <span id="online-start-label" data-i18n="onlineStart">Lancer la partie</span>
          <span class="ol-start-sub" id="online-start-desc" data-i18n="onlineStartDesc">Quand 2 joueurs sont connectés</span>
        </span>
      </button>

    </div><!-- /ol-col-status -->

  </div><!-- /ol-body -->

  <button class="back-btn" data-i18n="backToModes" id="back-to-modes-from-online-btn" type="button">Retour aux modes</button>
</div>
<div class="selection-area" id="ai-difficulty-selection-area">
<h2 data-i18n="chooseAIDifficulty">Choisir la difficulté de l'ordinateur</h2>
<div class="options-group">
<button class="option-btn difficulty-btn" data-level="1">
<span aria-hidden="true" class="icon">🙂</span>
<span data-i18n="difficultyEasy">Facile</span>
<span data-i18n="difficultyEasyDesc">L'ordinateur joue au hasard</span>
</button>
<button class="option-btn difficulty-btn" data-level="2">
<span aria-hidden="true" class="icon">😐</span>
<span data-i18n="difficultyMedium">Moyen</span>
<span data-i18n="difficultyMediumDesc">L'ordinateur est un adversaire correct</span>
</button>
<button class="option-btn difficulty-btn" data-level="3">
<span aria-hidden="true" class="icon">😬</span>
<span data-i18n="difficultyHard">Difficile</span>
<span data-i18n="difficultyHardDesc">L'ordinateur est un vrai stratège</span>
</button>
<button class="option-btn difficulty-btn" data-level="4">
<span aria-hidden="true" class="icon">☠️</span>
<span data-i18n="difficultyImpossible">Expert</span>
<span data-i18n="difficultyImpossibleDesc">L'IA anticipe vos moindres faits et gestes</span>
</button>
</div>
<button class="back-btn" data-i18n="backToModes" id="back-to-modes-btn">Retour aux modes</button>
</div>
<div class="selection-area player-setup-area" id="player-setup-area">

<!-- En-tête -->
<div class="psu-header">
<p class="psu-eyebrow">
ⵜⵉⴷⴷⴰⵙ
</p>
<h2 class="psu-title" data-i18n="playerSetup">Configuration</h2>
<p class="psu-subtitle" data-i18n="psuSubtitle">
Renseignez vos noms et choisissez votre camp
</p>
</div>

<!-- Section noms (conservée pour le JS) -->
<div class="psu-players-row" id="player-naming-section">

<!-- Joueur 1 -->
<div class="psu-player-card psu-p1" id="player2-name-group-wrapper">
<div class="psu-stone-wrap">
<div class="stone-preview player1 psu-stone" id="card1-stone"></div>
<div class="psu-stone-ring psu-stone-ring-p1"></div>
</div>
<div class="psu-player-info">
<label class="psu-player-tag" data-i18n="player1NameLabel" for="player1-name-input" id="player1-name-label">Joueur 1 · Noir</label>
<div class="input-group psu-input-wrap">
<input class="psu-name-input" data-i18n-placeholder="yourNamePlaceholder" id="player1-name-input" maxlength="20" placeholder="Votre nom" type="text" />
</div>
</div>
</div>

<!-- VS divider -->
<div class="psu-vs" aria-hidden="true">
<span class="psu-vs-text">VS</span>
</div>

<!-- Joueur 2 -->
<div class="psu-player-card psu-p2" id="player2-name-group">
<div class="psu-stone-wrap">
<div class="stone-preview player2 psu-stone" id="card2-stone"></div>
<div class="psu-stone-ring psu-stone-ring-p2"></div>
</div>
<div class="psu-player-info">
<label class="psu-player-tag" data-i18n="player2NameLabel" for="player2-name-input" id="player2-name-label">Joueur 2 · Blanc</label>
<div class="input-group psu-input-wrap">
<input class="psu-name-input" data-i18n-placeholder="player2Placeholder" id="player2-name-input" maxlength="20" placeholder="Joueur 2" type="text" />
</div>
</div>
</div>
</div>

<!-- Section couleur (conservée pour le JS) -->
<div class="setup-section psu-color-section" id="color-choice-section">
<p class="psu-color-label" id="color-section-label" data-i18n="chooseYourColorTitle">
Vous jouez avec les&nbsp;:
</p>
<div class="color-choice-group psu-color-group">
<label class="color-option psu-color-opt" data-player="1">
<input checked="" name="human-color" type="radio" value="1" />
<div class="psu-opt-inner">
<div class="stone-preview player1 psu-opt-stone"></div>
<div class="psu-opt-text">
<span class="psu-opt-name" data-i18n="player1Color" id="color-option-1-text">Pions Noirs</span>
<span class="psu-opt-desc" data-i18n="colorDescBlack">Joue en second</span>
</div>
<div class="psu-opt-check" aria-hidden="true">
<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 8 6.5 12 13 4" /></svg>
</div>
</div>
<div class="checkmark checkmark-hidden">
<span aria-hidden="true" class="icon">✅</span>
</div>
</label>
<label class="color-option psu-color-opt" data-player="2">
<input name="human-color" type="radio" value="2" />
<div class="psu-opt-inner">
<div class="stone-preview player2 psu-opt-stone"></div>
<div class="psu-opt-text">
<span class="psu-opt-name" data-i18n="player2Color" id="color-option-2-text">Pions Blancs</span>
<span class="psu-opt-desc" data-i18n="colorDescWhite">Commence en premier</span>
</div>
<div class="psu-opt-check" aria-hidden="true">
<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 8 6.5 12 13 4" /></svg>
</div>
</div>
<div class="checkmark checkmark-hidden">
<span aria-hidden="true" class="icon">✅</span>
</div>
</label>
</div>
</div>

<!-- CTA -->
<button class="start-game-btn" id="start-game-from-setup">
<svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><polygon points="5 3 19 12 5 21 5 3" /></svg>
<span data-i18n="playButton">Lancer la partie</span>
</button>

<button class="back-btn" data-i18n="backToModes" id="back-to-modes-from-setup-btn">Retour</button>

</div>
<div class="game-play-area" id="game-play-area">
<div class="player-panel-container player-panel-left">
<div class="player-panel">
<div class="player-info player1-info">
<div class="player-title" id="p1-display-name"></div>
<div class="player-stats">
<div class="player-stat" title="Pions restants">
<span aria-hidden="true" class="icon">💿</span>
<span class="stat-value" id="p1-count">10</span>
</div>
<div class="player-stat" title="Pions capturés">
<span aria-hidden="true" class="icon">👻</span>
<span class="stat-value" id="p1-capt">0</span>
</div>
</div>
<div class="player-badge" id="p1-badge" aria-live="polite" role="status"></div>
</div>
</div>
</div>
<div class="center-column">
<div class="game-info-display">
<span id="game-variant-info"></span>
<span id="game-difficulty-info"></span>
</div>
<div aria-live="polite" class="status" id="status" role="alert"></div>
<div class="game-board-container">
<div class="game-board" id="board"></div>
</div>
<div class="controls">
<button class="ctrl-btn ctrl-home" id="new-game" title="Retour à l'accueil">
<svg class="ctrl-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" /><polyline points="9 22 9 12 15 12 15 22" /></svg>
<span class="ctrl-label" data-i18n="newGame">Accueil</span>
</button>
<button class="ctrl-btn ctrl-undo" id="undo-btn" title="Annuler le dernier coup">
<svg class="ctrl-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14L4 9l5-5" /><path d="M4 9h10.5a5.5 5.5 0 0 1 0 11H11" /></svg>
<span class="ctrl-label" data-i18n="undoMove">Annuler</span>
</button>
<button class="ctrl-btn ctrl-restart" id="restart" title="Recommencer la partie">
<svg class="ctrl-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6" /><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10" /></svg>
<span class="ctrl-label" data-i18n="restartGame">Rejouer</span>
</button>
<button class="ctrl-btn ctrl-surrender surrender-btn" id="surrender" title="Abandonner la partie">
<svg class="ctrl-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z" /><line x1="4" y1="22" x2="4" y2="15" /></svg>
<span class="ctrl-label" data-i18n="surrender">Rendre</span>
</button>
</div>
<div class="spectator-controls" id="spectator-controls">
<span aria-hidden="true" class="icon">👁️</span>
<span data-i18n="spectatorSpeed">Vitesse :</span>
<select id="spectator-speed">
<option data-i18n="speedSlow" value="1200">Lente</option>
<option data-i18n="speedNormal" selected="" value="700">Normale</option>
<option data-i18n="speedFast" value="300">Rapide</option>
</select>
</div>
<div class="move-history-panel" id="move-history-panel">
<div class="move-history-title">
<span aria-hidden="true" class="icon">•</span> <span data-i18n="moveHistoryTitle">Historique des coups</span>
</div>
<div class="move-log-list" id="move-log-list"></div>
</div>
</div>
<div class="player-panel-container player-panel-right">
<div class="player-panel">
<div class="player-info player2-info">
<div class="player-title" id="p2-display-name"></div>
<div class="player-stats">
<div class="player-stat" title="Pions restants">
<span aria-hidden="true" class="icon">💿</span>
<span class="stat-value" id="p2-count">10</span>
</div>
<div class="player-stat" title="Pions capturés">
<span aria-hidden="true" class="icon">👻</span>
<span class="stat-value" id="p2-capt">0</span>
</div>
</div>
<div class="player-badge" id="p2-badge" aria-live="polite" role="status"></div>
</div>
</div>
</div>
</div>
</div>
<footer>
<div data-i18n="footerHeritage">
Patrimoine Culturel Amazigh • Jeu Traditionnel Kabyle
</div>
<div class="creator">
<span data-i18n="footerCreator">Créé par</span> Boussad TAMAZIRT
</div>
</footer>
<div class="winner-overlay" id="winner-overlay">
<!-- Fond animé -->
<div class="wo-bg"></div>
<div class="wo-particles" id="wo-particles"></div>
<!-- Carte -->
<div class="wo-card">
<div class="wo-trophy" id="wo-trophy">
🏆
</div>
<div class="wo-result">
<div class="winner-message" data-i18n="congratulations">
Félicitations !
</div>
<div class="wo-result-sub" id="wo-result-sub"></div>
</div>
<div class="winner-name"></div>
<div class="wo-divider">
<span></span><div class="wo-gem"></div>
<span></span>
</div>
<div class="wo-actions">
<button class="replay-button" data-i18n="replay" id="winner-replay-button">🔄 Rejouer</button>
<div class="wo-row">
<button class="replay-button secondary" disabled="" id="winner-replay-last-btn">⏯️ <span data-i18n="replayLast">Replay</span></button>
<button class="replay-button secondary" id="winner-stats-btn">📈 <span data-i18n="stats">Stats</span></button>
<button class="replay-button secondary" id="winner-menu-btn">🏠 <span data-i18n="backToMenu">Menu</span></button>
</div>
</div>
</div>
</div>
<!-- ═══════════════════════ MODALE À PROPOS ═══════════════════════ -->
<div class="about-modal-overlay" id="about-modal">
<div class="about-book">
<button class="about-close-btn" id="about-close-btn" title="Fermer" aria-label="Fermer" data-i18n-aria-label="ariaRulesClose">
<svg viewBox="0 0 24 24" width="22" height="22"><line x1="18" y1="6" x2="6" y2="18" /><line x1="6" y1="6" x2="18" y2="18" /></svg>
</button>

<!-- En-tête -->
<div class="about-header">
<div class="about-tifinagh">
ⵜⵉⴷⴷⴰⵙ
</div>
<h2 class="about-title" data-i18n="aboutTitle">À propos de l'application</h2>
<div class="about-sep">
<span></span><div class="about-gem">
◆
</div>
<span></span>
</div>
</div>

<!-- Corps -->
<div class="about-body">
<p class="about-intro" data-i18n="aboutIntro">
Cette application est née d'un désir simple : <strong>préserver et transmettre</strong> un trésor de notre patrimoine kabyle.
</p>

<p data-i18n="aboutP1">
<em>Tiddas</em>, pluriel de <em>Tiddest</em>, est bien plus qu'un jeu. C'est un art du raisonnement, un exercice de stratégie, un espace de réflexion où chaque mouvement compte. Autrefois gravé sur les bancs en béton des <em>taɛessast</em> de nos villages, il réunissait enfants, adultes et anciens autour d'un quadrillage de 25 cases et de simples cailloux appelés <em>ileqqafen</em>.
</p>

<p data-i18n="aboutP2">
Ma génération fait sans doute partie des dernières à avoir connu ce jeu dans sa forme traditionnelle&nbsp;: tracé à la craie, gravé dans la pierre ou esquissé au silex. Aujourd'hui, cette application lui offre une nouvelle vie, sans en trahir l'esprit.
</p>

<div class="about-rule-line"></div>

<p data-i18n="aboutP3">
Tiddas est un jeu de stratégie combinatoire abstrait, proche du jeu de dames et du morpion romain. <strong>Deux joueurs, dix pions chacun.</strong> L'objectif&nbsp;: former un alignement de trois pions pour capturer ceux de l'adversaire, tout en évitant ses pièges.<br>
Toute la profondeur du jeu réside dans le placement initial, l'anticipation et la maîtrise des configurations stratégiques comme <em>aseqqi</em>, <em>imenniqel</em>, <em>aɛzal</em> ou <em>lɣuṭ</em>.
</p>

<div class="about-variants">
<div class="about-variant-card">
<div class="about-variant-icon">
♟
</div>
<div>
<strong>TIDDEST</strong>
<span data-i18n="aboutVariantClassic">La version classique.</span>
</div>
</div>
<div class="about-variant-card">
<div class="about-variant-icon">
🔄
</div>
<div>
<strong>Učči Bessif</strong>
<span data-i18n="aboutVariantBessif">Perdre tous ses pions devient… la clé de la victoire.</span>
</div>
</div>
</div>

<p data-i18n="aboutP4">
À travers cette application, nous souhaitons permettre à chacun de redécouvrir ce jeu ancestral, de le transmettre aux nouvelles générations et de perpétuer cet héritage stratégique.
</p>

<div class="about-quote">
<div class="about-quote-mark">
❝
</div>
<blockquote>
Ddunit am Tiddest, mi k-seqqan xas kker
</blockquote>
<cite data-i18n="aboutQuoteTrans">La vie est comme Tiddest&nbsp;: si tu es pigé, lève-toi.</cite>
</div>
</div>

<!-- Pied -->
<div class="about-footer">
<div class="about-tifinagh-small">
ⵣ ⵎ ⵣ
</div>
<div class="about-author">
<svg class="about-author-icon" viewBox="0 0 24 24" width="16" height="16"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2" /><circle cx="12" cy="7" r="4" /></svg>
<span data-i18n="footerCreator">Par</span> <strong>Boussad TAMAZIRT</strong>
</div>
<div class="about-heritage" data-i18n="footerHeritage">
Patrimoine Culturel Amazigh • Jeu Traditionnel Kabyle
</div>
</div>
</div>
</div>
<!-- ═══════════════════════════════════════════════════════════════ -->
<div class="spectator-badge" data-i18n="spectatorBadgeTxt" id="spectator-badge">
👁 Mode Spectateur
</div>
<div id="drag-ghost"></div>
<div class="save-notification" id="save-notification">
<span data-i18n="savedGameFound" id="save-notification-text">Partie sauvegardée trouvée. Reprendre ?</span>
<div class="save-btns">
<button class="btn-resume" id="btn-resume">Reprendre</button>
<button class="btn-discard" id="btn-discard">Non</button>
</div>
</div>
<div class="modal-overlay" id="confirmation-modal">
<div class="modal-content">
<h3 id="modal-title"></h3>
<p id="modal-message"></p>
<div class="modal-actions">
<button class="modal-cancel-btn" id="modal-cancel-btn"></button>
<button class="modal-confirm-btn" id="modal-confirm-btn"></button>
</div>
</div>
</div>
<div class="rules-modal-overlay" id="rules-modal">
<div class="rules-book">
<button class="rules-close-btn" id="rules-close-btn" title="Fermer">×</button>
<div class="rules-content" lang="fr">
<h3 data-i18n="gameRulesTitle">Règles du Jeu</h3>
<h4 data-i18n="rulesGeneral">Règles Générales de Tiddas (Communes à toutes les variantes) :</h4>
<div class="rules-section">
<p>
<strong data-i18n="rulesObjectiveStrong">Objectif :</strong> <span data-i18n="rulesObjective">Le but principal est de réduire le nombre de pions de votre adversaire à moins de trois, ou de le bloquer de manière à ce qu'il ne puisse plus effectuer de mouvements valides. Pour la variante Učči bessif TIDDEST, l'objectif est inversé : le joueur gagne s'il réduit son propre nombre de pions à moins de trois, ou s'il est bloqué et ne peut plus effectuer de mouvements valides.</span>
</p>
<p>
<strong data-i18n="rulesPiecesStrong">Pions :</strong> <span data-i18n="rulesPieces">Chaque joueur dispose de 10 pions (appelés "cailloux"). Le Joueur 2 (Blanc) commence toujours.</span>
</p>
<p>
<strong data-i18n="rulesPhasesStrong">Phases de Jeu :</strong>
</p>
<ul>
<li><strong data-i18n="rulesPlacementPhaseStrong">Phase de Placement :</strong> <span data-i18n="rulesPlacementPhase">Les joueurs placent à tour de rôle un de leurs pions sur n'importe quelle case vide du plateau. Cette phase continue jusqu'à ce que les 20 pions (10 pour chaque joueur) soient placés.</span></li>
<li><strong data-i18n="rulesMovePhaseStrong">Phase de Déplacement :</strong> <span data-i18n="rulesMovePhase">Une fois tous les pions placés, les joueurs déplacent à tour de rôle l'un de leurs pions d'une case à la fois vers une case adjacente (horizontalement ou verticalement) qui est vide.</span></li>
</ul>
<p>
<strong data-i18n="rulesMillStrong">Moulin (Alignement) :</strong> <span data-i18n="rulesMill">Former un alignement de <strong>strictement 3 pions</strong> de sa couleur (horizontalement ou verticalement). <strong>Les alignements en diagonale ne sont pas considérés comme des moulins valides.</strong></span>
</p>
<p>
<strong data-i18n="rulesCaptureStrong">Capture :</strong> <span data-i18n="rulesCapture">Lorsqu'un joueur forme un moulin (horizontal ou vertical de 3 pions), il a le droit de "manger" (capturer) un pion adverse.</span>
</p>
<p>
<strong data-i18n="rulesCapturePlacementRestrictionStrong">Alignement de 3 interdit pendant le placement :</strong> <span data-i18n="rulesCapturePlacementRestriction">Il est interdit de placer un pion de manière à former un moulin de 3 pions ou plus. Par conséquent, <strong>aucune capture n'est possible pendant la phase de placement</strong>. Les captures sont uniquement possibles en phase de déplacement.</span>
</p>
<p>
<strong data-i18n="rulesCaptureAllPiecesStrong">Tous les pions sont capturables :</strong> <span data-i18n="rulesCaptureAllPieces">Dans toutes les variantes de ce jeu, <strong>tous les pions peuvent être capturés</strong>, même s'ils font partie d'un moulin. Il n'y a pas de pions "protégés".</span>
</p>
<p>
<strong data-i18n="rulesForcedMoveStrong">Règle de déplacement forcé de moulin :</strong> <span data-i18n="rulesForcedMove">En phase de déplacement, si un joueur a la possibilité de former un moulin avec un de ses pions, il est <strong>obligé</strong> de le faire. Si plusieurs mouvements permettent de former un moulin, le joueur peut choisir l'un d'entre eux.</span>
</p>
</div>
<h4 data-i18n="rulesDifferences">Différences entre les variantes :</h4>
<div class="rules-section">
<p data-i18n="rulesDifferencesIntro">
Les règles de base s'appliquent, mais chaque variante introduit des spécificités importantes :
</p>
<p>
<strong data-i18n="rulesTIDDEST">TIDDEST :</strong>
</p>
<ul>
<li><strong data-i18n="rulesTIDDESTMovesStrong">Déplacements :</strong> <span data-i18n="rulesTIDDESTMoves">Uniquement horizontaux/verticaux. Les déplacements en diagonale sont interdits.</span></li>
<li><strong data-i18n="rulesTIDDESTCapturesStrong">Captures :</strong> <span data-i18n="rulesTIDDESTCaptures">Le joueur qui forme le moulin choisit quel pion adverse capturer.</span></li>
<li><strong data-i18n="rulesTIDDESTWinStrong">Victoire :</strong> <span data-i18n="rulesTIDDESTWin">Normale.</span></li>
<li><strong data-i18n="rulesTIDDESTNoForcedMoveStrong">Pas de déplacement forcé de moulin :</strong> <span data-i18n="rulesTIDDESTNoForcedMove">La règle du déplacement forcé de moulin ne s'applique pas.</span></li>
</ul>
<p>
<strong data-i18n="rulesBessif">Učči Bessif :</strong>
</p>
<ul>
<li><span data-i18n="rulesBessifCombines">Combine les règles de <strong>TIDDEST</strong> avec le principe de <strong>victoire inversée</strong>.</span></li>
<li><strong data-i18n="rulesBessifMovesStrong">Déplacements :</strong> <span data-i18n="rulesBessifMoves">Uniquement horizontaux/verticaux.</span></li>
<li><strong data-i18n="rulesBessifInverseWinStrong">Victoire Inversée :</strong> <span data-i18n="rulesBessifInverseWin">Le joueur gagne si son propre nombre de pions est réduit à moins de trois (c'est-à-dire 0, 1 ou 2 pions), OU si son adversaire est bloqué et qu'il (le joueur qui vient de jouer) a moins de pions sur le plateau que son adversaire.</span></li>
<li><strong data-i18n="rulesBessifOpponentChoosesStrong">Choix du pion à capturer :</strong> <span data-i18n="rulesBessifOpponentChooses">Lorsque vous formez un moulin, c'est votre <strong>adversaire</strong> qui doit choisir l'un de ses propres pions que vous allez capturer.</span></li>
<li><strong data-i18n="rulesBessifForcedMoveStrong">Déplacement forcé pour former un moulin :</strong> <span data-i18n="rulesBessifForcedMove">La règle du déplacement forcé de moulin s'applique.</span></li>
</ul>
</div>
</div>
<div class="rules-content" lang="kab">
<h3 data-i18n="gameRulesTitle">Ilugan n wurar</h3>
<h4 data-i18n="rulesGeneral">Ilugan s umata n Tiddas :</h4>
<div class="rules-section">
<p>
<strong data-i18n="rulesObjectiveStrong">Iswi :</strong> <span data-i18n="rulesObjective">Iswi amenzu, yal ma yetellet yiwen ileqqafen-is ad yemmečč yiwen uleqqaf n wexṣim, neɣ aḥbas-is iwakken ur izmer ara ad inaqel. Di tewsit n Učči bessif, yerbeḥ win i wummi mmeččen ileqqafen-is.</span>
</p>
<p>
<strong data-i18n="rulesPiecesStrong">Ileqqafen :</strong> <span data-i18n="rulesPieces">Yal amyurar yesɛa 10 n yileqqafen. Amyurar <strong>(Amellal)</strong> yetturar d amezwaru.</span>
</p>
<p>
<strong data-i18n="rulesPhasesStrong">Talliyin n wurar :</strong>
</p>
<ul>
<li><strong data-i18n="rulesPlacementPhaseStrong">Tallit n usrusu :</strong> <span data-i18n="rulesPlacementPhase">Imyuraren srusuyen s nnuba (yiwen/yiwen uleqqaf). Tallit-a tekfa mi rsen i 20 n yileqqafen.</span></li>
<li><strong data-i18n="rulesMovePhaseStrong">Tallit n unaqel :</strong> <span data-i18n="rulesMovePhase">Mi rsen yakk ileqqafen, imyuraren ad bdun ad ttenqalen ileqqafen ɣer texxamin yexlan yellan ɣer yidis yexlan.</span></li>
</ul>
<p>
<strong data-i18n="rulesMillStrong">Atellet :</strong> <span data-i18n="rulesMill">Asedukkel n <strong>tlata n yileqqafen</strong> kan n yiwen yini (s teɣzi neɣ s tehri).</span>
</p>
<p>
<strong data-i18n="rulesCaptureStrong">Učči :</strong> <span data-i18n="rulesCapture">Ma yesdukkel amyurar tlata ileqqafen, yezmer ad yečč aleqqaf n wexṣim-is.</span>
</p>
<p>
<strong data-i18n="rulesCapturePlacementRestrictionStrong">Yegdel ad tesdukleḍ 3 deg usrusu :</strong> <span data-i18n="rulesCapturePlacementRestriction">Yegdel ad tserseḍ aleqqaf iwakken ad tesdukleḍ tlata. Daymi, ulac Učči deg tallit n usrusu. Učči tettili kan deg tallit n unaqel.</span>
</p>
<p>
<strong data-i18n="rulesCaptureAllPiecesStrong">Akk ileqqafen zemren ad mmeččen :</strong> <span data-i18n="rulesCaptureAllPieces">Deg yakk tiwsiyin, <strong>akk ileqqafen zemren ad mmeččen</strong>, ula ma llan deg utellet.</span>
</p>
<p>
<strong data-i18n="rulesForcedMoveStrong">Atellet s tmara:</strong> <span data-i18n="rulesForcedMove">Deg tallit n unaqel, ma yella umyurar yezmer ad itellet, ilaq-as ad t-yexdem. Ma yella aṭas n yiberdan, ad yefren yiwen.</span>
</p>
</div>
<h4 data-i18n="rulesDifferences">Amgired gar tewsiyin :</h4>
<div class="rules-section">
<p data-i18n="rulesDifferencesIntro">
Yal tawsit tesɛa ilugan-is :
</p>
<p>
<strong data-i18n="rulesTIDDEST">TIDDEST :</strong>
</p>
<ul>
<li><strong data-i18n="rulesTIDDESTMovesStrong">Anaqel :</strong> <span data-i18n="rulesTIDDESTMoves">Kan s teɣzi neɣ s tehri.</span></li>
<li><strong data-i18n="rulesTIDDESTCapturesStrong">Učči :</strong> <span data-i18n="rulesTIDDESTCaptures">Win yesduklen tlata ad yefren aleqqaf n wexṣim-is ara yečč.</span></li>
<li><strong data-i18n="rulesTIDDESTWinStrong">Arbaḥ :</strong> <span data-i18n="rulesTIDDESTWin">yerbeḥ win yeččan.</span></li>
<li><strong data-i18n="rulesTIDDESTNoForcedMoveStrong">Ulac atellet s tmara :</strong> <span data-i18n="rulesTIDDESTNoForcedMove">Ilugan n wučči bessif ur ttilin ara.</span></li>
</ul>
<p>
<strong data-i18n="rulesBessif">Učči Bessif :</strong>
</p>
<ul>
<li><span data-i18n="rulesBessifCombines">Tesdukkel ilugan n <strong>TIDDEST</strong> d umenzay n <strong> werbaḥ s wexṣar</strong>.</span></li>
<li><strong data-i18n="rulesBessifMovesStrong">Anaqel :</strong> <span data-i18n="rulesBessifMoves">Kan s teɣzi neɣ s tehri.</span></li>
<li><strong data-i18n="rulesBessifInverseWinStrong">Arbaḥ s wexṣar :</strong> <span data-i18n="rulesBessifInverseWin">Amyurar ad irebḥ ma yella ggran-as-d ala sin (2) yileqqafen, neɣ ma yella uxṣim-is ur yezmir ara ad inaqel, u netta (win i d-yuraren) yesɛa drus n yileqqafen.</span></li>
<li><strong data-i18n="rulesBessifOpponentChoosesStrong">Axṣim ad yefren :</strong> <span data-i18n="rulesBessifOpponentChooses">Ma yella tetelteḍ, d <strong>axṣim-ik</strong> ara d-ifernen aleqqaf-is ara teččeḍ.</span></li>
<li><strong data-i18n="rulesBessifForcedMoveStrong">atellet s tmara :</strong> <span data-i18n="rulesBessifForcedMove">Ur d ak d iṣaḥ ara ad tenaqleḍ aleqqaf ɣer wanda ur tettellit ara ma yella yezmer.</span></li>
</ul>
</div>
</div>
<div class="rules-content" lang="en">
<h3 data-i18n="gameRulesTitle">Game Rules</h3>
<h4 data-i18n="rulesGeneral">General Rules of Tiddas (Common to all variants):</h4>
<div class="rules-section">
<p>
<strong data-i18n="rulesObjectiveStrong">Objective:</strong> <span data-i18n="rulesObjective">The main goal is to reduce your opponent's pieces to fewer than three, or to block them so they can no longer make valid moves. For the Učči bessif TIDDEST variant, the objective is reversed: the player wins if their own pieces are reduced to fewer than three, or if they are blocked and cannot make valid moves.</span>
</p>
<p>
<strong data-i18n="rulesPiecesStrong">Pieces:</strong> <span data-i18n="rulesPieces">Each player has 10 pieces (called "stones"). Player 2 (White) always goes first.</span>
</p>
<p>
<strong data-i18n="rulesPhasesStrong">Game Phases:</strong>
</p>
<ul>
<li><strong data-i18n="rulesPlacementPhaseStrong">Placement Phase:</strong> <span data-i18n="rulesPlacementPhase">Players take turns placing one of their pieces on any empty cell of the board. This phase continues until all 20 pieces (10 per player) are placed.</span></li>
<li><strong data-i18n="rulesMovePhaseStrong">Movement Phase:</strong> <span data-i18n="rulesMovePhase">Once all pieces are placed, players take turns moving one of their pieces one cell at a time to an adjacent empty cell (horizontally or vertically).</span></li>
</ul>
<p>
<strong data-i18n="rulesMillStrong">Mill (Alignment):</strong> <span data-i18n="rulesMill">Forming an alignment of <strong>exactly 3 pieces</strong> of your color (horizontally or vertically). <strong>Diagonal alignments are not valid mills.</strong></span>
</p>
<p>
<strong data-i18n="rulesCaptureStrong">Capture:</strong> <span data-i18n="rulesCapture">When a player forms a mill (3 pieces horizontally or vertically), they may "eat" (capture) one of the opponent's pieces.</span>
</p>
<p>
<strong data-i18n="rulesCapturePlacementRestrictionStrong">3-alignment forbidden during placement:</strong> <span data-i18n="rulesCapturePlacementRestriction">It is forbidden to place a piece in a way that forms a mill of 3 or more pieces. Therefore, <strong>no captures are possible during the placement phase</strong>. Captures are only possible during the movement phase.</span>
</p>
<p>
<strong data-i18n="rulesCaptureAllPiecesStrong">All pieces can be captured:</strong> <span data-i18n="rulesCaptureAllPieces">In all variants of this game, <strong>all pieces can be captured</strong>, even if they are part of a mill. There are no "protected" pieces.</span>
</p>
<p>
<strong data-i18n="rulesForcedMoveStrong">Forced mill move rule:</strong> <span data-i18n="rulesForcedMove">During the movement phase, if a player can form a mill with one of their pieces, they are <strong>required</strong> to do so. If multiple moves allow a mill, the player may choose one.</span>
</p>
</div>
<h4 data-i18n="rulesDifferences">Differences between variants:</h4>
<div class="rules-section">
<p data-i18n="rulesDifferencesIntro">
The basic rules apply, but each variant introduces important specifics:
</p>
<p>
<strong data-i18n="rulesTIDDEST">TIDDEST:</strong>
</p>
<ul>
<li><strong data-i18n="rulesTIDDESTMovesStrong">Moves:</strong> <span data-i18n="rulesTIDDESTMoves">Horizontal/vertical only. Diagonal moves are forbidden.</span></li>
<li><strong data-i18n="rulesTIDDESTCapturesStrong">Captures:</strong> <span data-i18n="rulesTIDDESTCaptures">The player who forms the mill chooses which opponent piece to capture.</span></li>
<li><strong data-i18n="rulesTIDDESTWinStrong">Victory:</strong> <span data-i18n="rulesTIDDESTWin">Standard.</span></li>
<li><strong data-i18n="rulesTIDDESTNoForcedMoveStrong">No forced mill move:</strong> <span data-i18n="rulesTIDDESTNoForcedMove">The forced mill move rule does not apply.</span></li>
</ul>
<p>
<strong data-i18n="rulesBessif">Učči Bessif:</strong>
</p>
<ul>
<li><span data-i18n="rulesBessifCombines">Combines the rules of <strong>TIDDEST</strong> with the principle of <strong>reversed victory</strong>.</span></li>
<li><strong data-i18n="rulesBessifMovesStrong">Moves:</strong> <span data-i18n="rulesBessifMoves">Horizontal/vertical only.</span></li>
<li><strong data-i18n="rulesBessifInverseWinStrong">Reversed Victory:</strong> <span data-i18n="rulesBessifInverseWin">The player wins if their own pieces are reduced to fewer than three (i.e. 0, 1 or 2 pieces), OR if their opponent is blocked and the current player has fewer pieces on the board than the opponent.</span></li>
<li><strong data-i18n="rulesBessifOpponentChoosesStrong">Choosing the piece to capture:</strong> <span data-i18n="rulesBessifOpponentChooses">When you form a mill, it is your <strong>opponent</strong> who must choose one of their own pieces for you to capture.</span></li>
<li><strong data-i18n="rulesBessifForcedMoveStrong">Forced move to form a mill:</strong> <span data-i18n="rulesBessifForcedMove">The forced mill move rule applies.</span></li>
</ul>
</div>
</div>
</div>
</div>
<!-- ===== Pack Produit: Stats / Replay / Install UI (single-file) ===== -->
<div aria-atomic="true" aria-live="polite" class="toast" id="toast" role="status"></div>
<div aria-hidden="true" class="modal-overlay app-modal" id="stats-modal">
<div aria-labelledby="stats-modal-title" aria-modal="true" class="modal-content stats-modal-content" role="dialog">
<h3 data-i18n="statsTitle" id="stats-modal-title">Stats &amp; progression</h3>
<div id="stats-content"></div>
<div class="modal-actions">
<button id="stats-reset-btn" type="button"><span data-i18n="resetStats">Réinitialiser</span></button>
<button id="stats-export-btn" type="button"><span data-i18n="exportStats">Exporter</span></button>
<button id="stats-close-btn" type="button"><span data-i18n="close">Fermer</span></button>
</div>
</div>
</div>
<div aria-hidden="true" class="modal-overlay app-modal" id="replay-modal">
  <div aria-labelledby="replay-modal-title" aria-modal="true" class="modal-content replay-modal-content" role="dialog">
    <h3 data-i18n="replayTitle" id="replay-modal-title" class="sr-only">Replay</h3>

    <div class="replay-dock">
      <div class="replay-dock-top">
        <div class="replay-pill" aria-live="polite">
          <span class="replay-pill-ico" aria-hidden="true">⏯</span>
          <span class="replay-pill-step" id="replay-step-indicator">— / —</span>
        </div>
        <div class="replay-dock-actions">
          <button class="replay-ghost-btn" id="replay-info-btn" type="button" aria-label="Info" title="Info">i</button>
          <button class="replay-ghost-btn" id="replay-exit-btn" type="button" aria-label="Fermer" title="Fermer">✕</button>
        </div>
      </div>

      <div class="replay-meta" id="replay-meta" hidden></div>

      <input aria-label="Timeline" class="replay-range replay-range-dock" id="replay-range" max="0" min="0" step="1" type="range" value="0" />

      <div aria-label="Replay controls" class="replay-controls replay-controls-dock">
        <button id="replay-first-btn" type="button" title="Start">⏮</button>
        <button id="replay-prev-btn" type="button" title="Previous">⏪</button>
        <button id="replay-play-btn" type="button" title="Play/Pause">▶️</button>
        <button id="replay-next-btn" type="button" title="Next">⏩</button>
        <button id="replay-last-btn" type="button" title="End">⏭</button>

        <label class="replay-speed-pill">
          <span class="sr-only" data-i18n="speed">Vitesse</span>
          <select id="replay-speed" aria-label="Speed">
            <option value="0.5">0.5×</option>
            <option selected value="1">1×</option>
            <option value="1.5">1.5×</option>
            <option value="2">2×</option>
            <option value="3">3×</option>
          </select>
        </label>
      </div>
    </div>
  </div>
</div>
<!-- Badge REPLAY sur le plateau -->
<div class="replay-badge" id="replay-badge">
⏯ Replay
</div>
<!-- Barre d'état replay en haut -->
<div class="replay-board-indicator" id="replay-board-indicator"></div>
<div aria-hidden="true" class="modal-overlay app-modal" id="install-help-modal">
<div aria-labelledby="install-modal-title" aria-modal="true" class="modal-content install-modal-content" role="dialog">
<h3 data-i18n="installHelpTitle" id="install-modal-title">Installer l'app</h3>
<div id="install-help-content">
<p data-i18n="installHelpBody">
Astuce : sur iPhone/iPad, utilisez “Partager” → “Sur l'écran d'accueil”. Sur Android/Chrome, le bouton “Installer” apparaît si l'app est éligible.
</p>
</div>
<div class="modal-actions">
<button id="install-help-close-btn" type="button"><span data-i18n="close">Fermer</span></button>
</div>
</div>
</div>
<script nonce="tiddas">
/* ===== TIDDAS - Script consolidé (refactorisé) ===== */

// ============================================================
// Micro-interactions pointer glow (IIFE isolée)
// ============================================================

/* ===== UI micro-interactions (single-file) ===== */
(function() {
// Pointer position -> CSS variables for sheen/ripple
const setXY = (el, ev) => {
const r = el.getBoundingClientRect();
const x = ((ev.clientX - r.left) / r.width) * 100;
const y = ((ev.clientY - r.top) / r.height) * 100;
el.style.setProperty('--mx', x.toFixed(2) + '%');
el.style.setProperty('--my', y.toFixed(2) + '%');
};
// Throttle pointermove updates to one per animation frame (perf on mobile)
let __tiddasRaf = 0;
let __tiddasLast = null;
document.addEventListener('pointermove', (ev) => {
const t = ev.target;
if (!(t instanceof Element)) return;
__tiddasLast = {
t,
x: ev.clientX,
y: ev.clientY
};
if (__tiddasRaf) return;
__tiddasRaf = requestAnimationFrame(() => {
__tiddasRaf = 0;
const last = __tiddasLast;
if (!last) return;
const el = last.t.closest && last.t.closest('button, .version-card, .difficulty-card, .mode-card, .option-btn, .toolbar-btn, #settings-fab');
if (!el) return;
// call setXY with a minimal event-like object
setXY(el, {
clientX: last.x, clientY: last.y
});
});
}, {
passive: true
});

// Replace any leftover font-awesome tags gracefully
const map = {
'fa-globe': '🌐', 'fa-book-open': '📖', 'fa-robot': '🤖', 'fa-users': '👥', 'fa-eye': '👁️',
'fa-smile': '🙂', 'fa-meh': '😐', 'fa-grimace': '😬', 'fa-frown': '😟', 'fa-grin-beam': '😁',
'fa-mouse-pointer': '👉', 'fa-exchange-alt': '🔄', 'fa-skull-crossbones': '☠️', 'fa-check-circle': '✅',
'fa-play': '▶️', 'fa-compact-disc': '💿', 'fa-ghost': '👻', 'fa-home': '🏠', 'fa-undo': '↩️', 'fa-redo': '↪️', 'fa-flag': '🏳️'
};
document.querySelectorAll('i[class*="fa-"]').forEach(i => {
const cls = [...i.classList].find(c => c.startsWith('fa-'));
const s = document.createElement('span');
s.className = 'icon';
s.setAttribute('aria-hidden',
'true');
s.textContent = map[cls] || '•';
i.replaceWith(s);
});
})();

// ============================================================
// IIFE principale - tout le jeu dans une portée unique
// ============================================================
(function() {
'use strict';

// ============================================================
// ============================================================
// === ONLINE MULTIPLAYER (Back4App) — NO LiveQuery (polling) ===
// ============================================================
// Back4App keys (App Settings -> Security & Keys)
// IMPORTANT: Do NOT put Master Key in the browser.
const BACK4APP_APP_ID = "mLDVvlPNA6LyRawtxNvVztC4ch3l5V5ePjQP8SLM";        // <-- set me
const BACK4APP_JS_KEY = "Um86a8uC2OLlD13dh5V8ijiscAXvOHHydjO4ZQot";        // <-- set me (JavaScript Key)
const BACK4APP_SERVER_URL = "https://parseapi.back4app.com"; // default API URL
const BACK4APP_CLASS = "GameMatch"; // class/table name in Back4App

// Client identity (per device) to assign roles in a 1v1 room
const ONLINE_PLAYER_ID_KEY = "tiddas_online_player_id_v1";
function _getOrCreatePlayerId() {
  try {
    const existing = localStorage.getItem(ONLINE_PLAYER_ID_KEY);
    if (existing) return existing;
    const id = (window.crypto && typeof window.crypto.randomUUID === 'function')
      ? window.crypto.randomUUID()
      : ("p_" + Math.random().toString(36).slice(2) + Date.now().toString(36));
    localStorage.setItem(ONLINE_PLAYER_ID_KEY, id);
    return id;
  } catch (_) {
    return "p_" + Math.random().toString(36).slice(2) + Date.now().toString(36);
  }
}
const onlinePlayerId = _getOrCreatePlayerId();

// Persist last used room code / match id (lets users rejoin after leaving)
const ONLINE_LAST_ROOM_KEY = "tiddas_online_last_room_v1";
function saveLastOnlineRoom(info) {
  try {
    const payload = {
      v: 1,
      code: String(info?.code || ''),
      matchId: String(info?.matchId || ''),
      at: Date.now()
    };
    if (!payload.code && !payload.matchId) return;
    localStorage.setItem(ONLINE_LAST_ROOM_KEY, JSON.stringify(payload));
  } catch (_) {}
}
function loadLastOnlineRoom() {
  try {
    const raw = localStorage.getItem(ONLINE_LAST_ROOM_KEY);
    const parsed = raw ? safeJSONParse(raw, null) : null;
    if (!parsed || parsed.v !== 1) return null;
    return { code: String(parsed.code || ''), matchId: String(parsed.matchId || ''), at: Number(parsed.at || 0) };
  } catch (_) { return null; }
}
function clearLastOnlineRoom() {
  try { localStorage.removeItem(ONLINE_LAST_ROOM_KEY); } catch(_) {}
}


// Persist a small list of recent room codes — v2 (enriched, max 3)
const ONLINE_ROOMS_KEY = "tiddas_online_rooms_v2";
const ONLINE_ROOMS_MAX = 3;

function loadRecentOnlineRooms() {
  try {
    const raw = localStorage.getItem(ONLINE_ROOMS_KEY);
    const parsed = raw ? safeJSONParse(raw, null) : null;
    // Support v2 structure
    if (parsed && parsed.v === 2 && Array.isArray(parsed.rooms)) {
      return parsed.rooms
        .map(r => ({
          code:         String(r.code || '').toUpperCase(),
          at:           Number(r.at || 0),
          opponentName: r.opponentName || null,
          myName:       r.myName || null,
          variant:      r.variant || null,
          winnerId:     r.winnerId != null ? Number(r.winnerId) : null,
          didWin:       r.didWin != null ? !!r.didWin : null
        }))
        .filter(r => !!r.code)
        .sort((a, b) => (b.at || 0) - (a.at || 0))
        .slice(0, ONLINE_ROOMS_MAX);
    }
    // Migrate from v1
    if (parsed && parsed.v === 1 && Array.isArray(parsed.rooms)) {
      return parsed.rooms
        .map(r => ({ code: String(r.code || '').toUpperCase(), at: Number(r.at || 0), opponentName: null, myName: null, variant: null, winnerId: null, didWin: null }))
        .filter(r => !!r.code)
        .sort((a, b) => (b.at || 0) - (a.at || 0))
        .slice(0, ONLINE_ROOMS_MAX);
    }
    // Legacy flat key
    const rawOld = localStorage.getItem("tiddas_online_rooms_v1");
    if (rawOld) {
      const parsedOld = safeJSONParse(rawOld, null);
      if (parsedOld && Array.isArray(parsedOld.rooms)) {
        return parsedOld.rooms
          .map(r => ({ code: String(r.code || '').toUpperCase(), at: Number(r.at || 0), opponentName: null, myName: null, variant: null, winnerId: null, didWin: null }))
          .filter(r => !!r.code).sort((a,b) => (b.at||0)-(a.at||0)).slice(0, ONLINE_ROOMS_MAX);
      }
    }
    return [];
  } catch (_) { return []; }
}

/**
 * @param {string|object} codeOrObj  — string (legacy) OR {code, opponentName, myName, variant, winnerId, didWin}
 */
function addRecentOnlineRoom(codeOrObj) {
  try {
    let entry;
    if (typeof codeOrObj === 'string') {
      entry = { code: codeOrObj.trim().toUpperCase(), at: Date.now(), opponentName: null, myName: null, variant: null, winnerId: null, didWin: null };
    } else {
      entry = {
        code:         String(codeOrObj.code || '').trim().toUpperCase(),
        at:           Date.now(),
        opponentName: codeOrObj.opponentName || null,
        myName:       codeOrObj.myName || null,
        variant:      codeOrObj.variant || null,
        winnerId:     codeOrObj.winnerId != null ? Number(codeOrObj.winnerId) : null,
        didWin:       codeOrObj.didWin != null ? !!codeOrObj.didWin : null
      };
    }
    if (!entry.code) return;
    const rooms = loadRecentOnlineRooms().filter(r => r.code !== entry.code);
    rooms.unshift(entry);
    const payload = { v: 2, rooms: rooms.slice(0, ONLINE_ROOMS_MAX) };
    localStorage.setItem(ONLINE_ROOMS_KEY, JSON.stringify(payload));
  } catch (_) {}
}

function _fmtRelativeDate(ms) {
  try {
    if (!ms) return '';
    const diff = Date.now() - ms;
    const min = Math.floor(diff / 60000);
    const h = Math.floor(diff / 3600000);
    const d = Math.floor(diff / 86400000);
    if (d >= 1) return `${d}j`;
    if (h >= 1) return `${h}h`;
    if (min >= 1) return `${min}min`;
    return '<1min';
  } catch(_) { return ''; }
}

function renderRecentOnlineRooms() {
  try {
    const wrap = document.getElementById('online-recent-wrap');
    const list = document.getElementById('online-recent-list');
    if (!wrap || !list) return;
    const rooms = loadRecentOnlineRooms();
    list.innerHTML = '';
    if (!rooms.length) {
      wrap.classList.remove('open');
      return;
    }
    rooms.forEach(r => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'online-room-chip';
      btn.setAttribute('aria-label', `${t('onlineJoin','Rejoindre')} ${r.code}`);

      const vsLabel = r.opponentName
        ? `<em>${t('onlineChipVs','vs')}</em> ${r.opponentName}`
        : `<em>${t('onlineChipPending','En attente')}</em>`;
      const resultIcon = r.didWin === true ? '🏆' : r.didWin === false ? '💀' : '•';
      const dateStr = _fmtRelativeDate(r.at);

      btn.innerHTML = `<span class="chip-code">${r.code}</span>`
        + `<span class="chip-vs">${vsLabel}</span>`
        + `<span class="chip-result">${resultIcon}</span>`
        + `<span class="chip-date">${dateStr}</span>`;

      btn.onclick = () => {
        const inputCode = document.getElementById('online-room-code');
        if (inputCode) {
          inputCode.value = r.code;
          inputCode.dispatchEvent(new Event('input'));
        }
        // Close recent panel, open join panel, then auto-connect
        const joinPanel = document.getElementById('online-join-panel');
        const recentPanel = document.getElementById('online-recent-wrap');
        if (joinPanel) joinPanel.classList.add('open');
        if (recentPanel) recentPanel.classList.remove('open');
        // Trigger connection after short delay
        setTimeout(() => { try { onlineConnectToRoom(r.code, false); } catch(_) {} }, 200);
      };
      list.appendChild(btn);
    });
  } catch (_) {}
}
const ONLINE_NAME_KEY = "tiddas_online_name_v1";
function _getOnlineNameRaw() {
  try { return (onlineEls.inputName?.value || localStorage.getItem(ONLINE_NAME_KEY) || "").trim(); } catch(_) { return ""; }
}
function _getOnlineNameSafe(fallback) {
  const raw = _getOnlineNameRaw();
  const n = normalizeName(raw, "");
  if (!n) return fallback || "";
  try { localStorage.setItem(ONLINE_NAME_KEY, n); } catch(_) {}
  if (onlineEls.inputName && onlineEls.inputName.value !== n) onlineEls.inputName.value = n;
  return n;
}

let online = {
  matchId: null,
  room: null,
  role: null,      // Slot (p1=1 / p2=2) — stable for the room
  playerId: null,  // In-game Player ID (1=Noir / 2=Blanc) — can swap between games
  swapColors: false,
  gameId: 0,       // Incremented per "start" to support rematch + color alternation
  isHost: false,
  connected: false,
  ready: false,
  suppressSend: false,
  pollTimer: 0,
  lastSeenRev: -1,
  parseReady: false
};

const onlineEls = {
  area: null, statusText: null, roomCodeRow: null, roomCode: null,
  btnCreate: null, btnJoin: null, joinPanel: null, inputCode: null,
  btnConnect: null, btnStart: null, btnCopy: null, btnCopyLink: null, btnShareLink: null, btnBack: null,
  inputName: null, p1Name: null, p2Name: null,
  recentWrap: null, recentList: null, btnRejoinLast: null
};

function _isBack4AppConfigured() {
  const a = (BACK4APP_APP_ID || '').trim();
  const k = (BACK4APP_JS_KEY || '').trim();
  return !!a && !!k && !/set me/i.test(a) && !/set me/i.test(k);
}

function _ensureParseReady() {
  if (online.parseReady) return true;
  if (!_isBack4AppConfigured()) return false;
  if (!window.Parse) return false;
  try {
    // Normalize URL (no trailing slash)
    const url = (BACK4APP_SERVER_URL || 'https://parseapi.back4app.com').trim().replace(/\/$/, '');
    Parse.initialize(BACK4APP_APP_ID.trim(), BACK4APP_JS_KEY.trim());
    Parse.serverURL = url;
    online.parseReady = true;
    return true;
  } catch (_) {
    return false;
  }
}

function _setOnlineStatus(msg) {
  if (onlineEls.statusText) onlineEls.statusText.textContent = msg || '—';
  // Also update global status text
  const glob = document.getElementById('online-status-global');
  if (glob) glob.textContent = msg || '';
  // Show status card when we have a real message
  const statusCard = document.getElementById('online-status');
  if (statusCard && msg && msg !== '—') statusCard.style.display = '';
}
function _show(el, yes) { if (!el) return; el.style.display = yes ? '' : 'none'; }
function _randCode(len=4) {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let out = '';
  for (let i=0;i<len;i++) out += chars[Math.floor(Math.random()*chars.length)];
  return out;
}

function onlineDisconnect() {
  if (online.pollTimer) { clearInterval(online.pollTimer); online.pollTimer = 0; }
  online.matchId = null;
  online.room = null;
  online.role = null;
  online.playerId = null;
  online.swapColors = false;
  online.gameId = 0;
  online.isHost = false;
  online.connected = false;
  online.ready = false;
  online.suppressSend = false;
  online.lastSeenRev = -1;
}

async function _fetchMatchByCode(code) {
  const q = new Parse.Query(BACK4APP_CLASS);
  q.equalTo('code', code);
  q.descending('createdAt');
  return await q.first();
}

async function _fetchMatchById(id) {
  const q = new Parse.Query(BACK4APP_CLASS);
  return await q.get(id);
}

function _applyLobbyStateFromMatch(match) {
  const status = match.get('status') || 'waiting';
  const p1 = match.get('p1Id') || null;
  const p2 = match.get('p2Id') || null;

  const p1Name = match.get('p1Name') || null;
  const p2Name = match.get('p2Name') || null;
  if (onlineEls.p1Name) onlineEls.p1Name.textContent = p1Name || '—';
  if (onlineEls.p2Name) onlineEls.p2Name.textContent = p2Name || '—';

  // Determine role if not already set (slot in DB)
  if (!online.role) {
    if (p1 === onlinePlayerId) { online.role = 1; online.isHost = true; }
    else if (p2 === onlinePlayerId) { online.role = 2; online.isHost = false; }
  }

  online.ready = !!(p1 && p2);

  // Rematch readiness flags (persisted in room)
  const rm1 = !!match.get('rm1');
  const rm2 = !!match.get('rm2');

  // Rematch UI
  const rmWrap = document.getElementById('online-rematch');
  const rmChip1 = document.getElementById('online-rm1-chip');
  const rmChip2 = document.getElementById('online-rm2-chip');
  const rmBtn = document.getElementById('online-rematch-ready-btn');

  const setChip = (chip, ready) => {
    if (!chip) return;
    chip.classList.toggle('ready', !!ready);
  };
  setChip(rmChip1, rm1);
  setChip(rmChip2, rm2);

  // Default: hide rematch section
  if (rmWrap) rmWrap.style.display = 'none';
  if (rmBtn) rmBtn.style.display = 'none';

  const startBtn = onlineEls.btnStart;
  const startLabel = document.getElementById('online-start-label');
  const startDesc  = document.getElementById('online-start-desc');

  const setStartBtnText = (labelKey, descKey) => {
    if (startLabel) { startLabel.dataset.i18n = labelKey; startLabel.textContent = t(labelKey); }
    if (startDesc)  { startDesc.dataset.i18n  = descKey;  startDesc.textContent  = t(descKey); }
  };

  if (!online.ready) {
    _setOnlineStatus(online.isHost ? t('onlineStatusCreatedHost') : t('onlineStatusConnecting'));
    _show(startBtn, false);
    return;
  }

  // Ready: 2 players
  if (status === 'playing') {
    _setOnlineStatus(online.isHost ? t('onlineStatusPlayingHost') : t('onlineStatusPlayingGuest'));
    _show(startBtn, false);
    return;
  }

  if (status === 'finished') {
    // Finished → rematch flow (stay in same room)
    if (rmWrap) rmWrap.style.display = '';
    if (online.isHost) {
      setStartBtnText('onlineRematchStart', 'onlineRematchStartDesc');
      // Host can start only when both are ready
      if (startBtn) startBtn.disabled = !(rm1 && rm2);
      _show(startBtn, true);
      _setOnlineStatus((rm1 && rm2) ? t('onlineRematchCanStart') : t('onlineRematchWaitReady'));
    } else {
      // Guest: mark ready button
      if (rmBtn) {
        rmBtn.style.display = '';
        rmBtn.classList.toggle('active', (online.role === 1 ? rm1 : rm2));
        rmBtn.textContent = (online.role === 1 ? rm1 : rm2) ? t('onlineReadyRematchOn') : t('onlineReadyRematch');
        rmBtn.dataset.i18n = (online.role === 1 ? rm1 : rm2) ? 'onlineReadyRematchOn' : 'onlineReadyRematch';
      }
      _show(startBtn, false);
      _setOnlineStatus(t('onlineRematchGuestInfo'));
    }
    return;
  }

  // Waiting/Ready → normal start
  setStartBtnText('onlineStart', 'onlineStartDesc');
  if (startBtn) startBtn.disabled = false;
  _setOnlineStatus(online.isHost ? t('onlineStatusTwoPlayersHost') : t('onlineStatusTwoPlayersGuest'));
  _show(startBtn, !!online.isHost);
}



function _startPolling() {
  if (online.pollTimer) return;
  online.pollTimer = setInterval(async () => {
    if (!online.connected || !online.matchId) return;
    try {
      const match = await _fetchMatchById(online.matchId);
      _applyLobbyStateFromMatch(match);

      const rev = Number(match.get('rev') || 0);
      if (rev !== online.lastSeenRev) {
        online.lastSeenRev = rev;
        const payload = match.get('payload') || null;

        if (payload && payload.state) {
          onlineApplyState(payload);
          // If we received game state, jump into the game UI
          if (typeof showScreen === 'function') showScreen('game-play-area');
        }
      }
    } catch (e) {
      // network / permission errors
      _setOnlineStatus(t('onlineNetworkError', "Erreur réseau Back4App. Vérifie les permissions (CLP) et ta connexion."));
    }
  }, 800);
}

async function onlineConnectToRoom_Back4App(code, creating) {
  code = String(code || '').trim().toUpperCase();
  if (!code) return;

  if (!_ensureParseReady()) {
    _setOnlineStatus(t('onlineParseNotReady', "Back4App n'est pas configuré ou Parse SDK non chargé."));
    return;
  }

  onlineDisconnect();
  online.room = code;
  _show(onlineEls.roomCodeRow, true);
  if (onlineEls.roomCode) onlineEls.roomCode.textContent = code;
  _show(onlineEls.btnStart, false);

  try {
    if (creating) {
      _setOnlineStatus(t('onlineCreatingRoom', 'Création du salon {code}…').replace('{code}', code));
      const existing = await _fetchMatchByCode(code);
      if (existing) throw new Error(t('onlineCodeAlreadyUsed', 'Code déjà utilisé. Réessaie avec un autre code.'));

      const match = new Parse.Object(BACK4APP_CLASS);
      match.set('code', code);
      match.set('status', 'waiting');
      match.set('p1Id', onlinePlayerId);
      match.set('p1Name', _getOnlineNameSafe('Joueur 1'));
      match.set('p2Id', null);
      match.set('p2Name', null);
      match.set('variant', variant || 'TIDDEST-no-diag');
      match.set('rev', 0);
      match.set('payload', null);

      await match.save();

      online.matchId = match.id;
      try { saveLastOnlineRoom({ code, matchId: match.id }); addRecentOnlineRoom(code); renderRecentOnlineRooms(); } catch(_) {}
      online.role = 1;
      online.isHost = true;
      online.connected = true;
      online.ready = false;

      _setOnlineStatus(t('onlineCreatedShare', 'Salon créé. Partage le code : {code}').replace('{code}', code));
    } else {
      _setOnlineStatus(t('onlineConnectingRoom', 'Connexion au salon {code}…').replace('{code}', code));
      const match = await _fetchMatchByCode(code);
      if (!match) throw new Error(t('onlineRoomNotFound', 'Salon introuvable. Vérifie le code.'));

      const status = match.get('status') || 'waiting';
      const p1 = match.get('p1Id') || null;
      const p2 = match.get('p2Id') || null;

      const isKnownPlayer = (p1 === onlinePlayerId) || (p2 === onlinePlayerId);
      if (status === 'finished' && !isKnownPlayer) throw new Error(t('onlineGameFinished'));

      // If same device rejoining
      if (p1 === onlinePlayerId) {
        online.role = 1; online.isHost = true;
        // best-effort: store name if missing
        if (!match.get('p1Name')) { match.set('p1Name', _getOnlineNameSafe('Joueur 1')); await match.save(); }
      } else if (p2 === onlinePlayerId) {
        online.role = 2; online.isHost = false;
        if (!match.get('p2Name')) { match.set('p2Name', _getOnlineNameSafe('Joueur 2')); await match.save(); }
      } else if (!p2) {
        match.set('p2Id', onlinePlayerId);
        match.set('p2Name', _getOnlineNameSafe('Joueur 2'));
        if (status === 'waiting') match.set('status', 'ready');
        await match.save();
        online.role = 2; online.isHost = false;
      } else {
        throw new Error(t('onlineRoomFull', 'Salon complet (2 joueurs).'));
      }

      online.matchId = match.id;
      try { saveLastOnlineRoom({ code, matchId: match.id }); addRecentOnlineRoom(code); renderRecentOnlineRooms(); } catch(_) {}
      online.connected = true;
      online.ready = !!(match.get('p1Id') && match.get('p2Id'));

      _applyLobbyStateFromMatch(match);

      // If a game already started, apply latest state immediately
      const payload = match.get('payload') || null;
      if (payload && payload.state) {
        online.lastSeenRev = Number(match.get('rev') || 0);
        onlineApplyState(payload);
        if (typeof showScreen === 'function') showScreen('game-play-area');
      }
    }

    online.lastSeenRev = -1;
    _startPolling();
  } catch (e) {
    onlineDisconnect();
    _setOnlineStatus(t('onlineErrorPrefix', 'Erreur : {msg}').replace('{msg}', (e && e.message ? e.message : String(e))));
  }
}

function onlineSendState(reason='sync') {
  if (gameMode !== 'online') return;
  if (!online.connected || online.suppressSend) return;
  if (!_ensureParseReady()) return;
  if (!online.matchId) return;

  // build payload snapshot
  const payload = {
    reason,
    room: online.room,
    variant,
    state,
    meta: { player1Name, player2Name, turn: state?.turn ?? null, at: Date.now(), gameId: online.gameId || 0, swapColors: !!online.swapColors }
  };

  // Fire-and-forget: update room payload + increment revision
  (async () => {
    try {
      const match = new Parse.Object(BACK4APP_CLASS);
      match.id = online.matchId;

      match.set('payload', JSON.parse(JSON.stringify(payload)));
      match.increment('rev', 1);

      // Persist room-level rematch metadata
      try { match.set('gameId', online.gameId || 0); } catch(_) {}
      try { match.set('swapColors', !!online.swapColors); } catch(_) {}

      // Keep room status in sync (start -> playing, winner -> finished)
      if (reason === 'start') {
        match.set('status', 'playing');
        try { match.set('rm1', false); match.set('rm2', false); } catch(_) {}
      }
      if (state && state.winner) {
        match.set('status', 'finished');
        try { match.set('rm1', false); match.set('rm2', false); } catch(_) {}
      }

      await match.save();
    } catch (e) {
      // don't crash the game UI
      if (onlineEls.statusText) _setOnlineStatus(t('onlineSendError', "Erreur d'envoi. Vérifie ta connexion Back4App."));
    }
  })();
}

async function onlineStartMatch_Back4App() {
  if (gameMode !== 'online') gameMode = 'online';
  if (!online.connected || !online.matchId) { _setOnlineStatus(t('onlineNoRoomActive', "Pas de salon actif.")); return; }
  if (!online.isHost) { _setOnlineStatus(t('onlineOnlyHostStart', "Seul l’hôte peut lancer la partie.")); return; }
  if (!_ensureParseReady()) { _setOnlineStatus(t('onlineBack4AppNotReady', "Back4App n'est pas prêt.")); return; }

  try {
    const match = await _fetchMatchById(online.matchId);

    const p1 = match.get('p1Id') || null;
    const p2 = match.get('p2Id') || null;
    if (!(p1 && p2)) { _setOnlineStatus(t('onlineWaitTwoPlayers', "Attends que 2 joueurs soient connectés.")); return; }

    // Sync names from DB (or fallback)
    const p1Name = match.get('p1Name') || translations[currentLanguage]?.defaultPlayer1 || 'Joueur 1';
    const p2Name = match.get('p2Name') || translations[currentLanguage]?.defaultPlayer2 || 'Joueur 2';

    // Variant from DB if present
    const v = match.get('variant') || variant || 'TIDDEST-no-diag';
    if (v && variantConfig[v]) variant = v;

    // Init a fresh game state (no setup screen for online)
    clearSave();
    try { hideWinnerAnimation?.(); } catch(_) {}

    hideSaveNotification?.();

    state = initState();
    moveHistory = [];
    boardPositionHistory = new Map();
    forbiddenBoardPositions = new Set();

    // Rematch support + alternance des couleurs :
    // - gameId est incrémenté à chaque lancement
    // - swapColors alterne à chaque nouvelle partie (pair/impair)
    const currentGameId = Number(match.get('gameId') || 0);
    const nextGameId = currentGameId + 1;
    online.gameId = nextGameId;
    online.swapColors = (nextGameId % 2 === 0);

    // Player ID (couleur) pour CE match, basé sur le slot (p1/p2) + swapColors
    online.playerId = online.swapColors ? (3 - (online.role || 1)) : (online.role || 1);

    aiPlayerId = null;
    humanPlayerId = online.playerId || (online.role || 1);

    // player1Name = Noir (ID 1), player2Name = Blanc (ID 2)
    if (online.swapColors) {
      player1Name = p2Name;
      player2Name = p1Name;
    } else {
      player1Name = p1Name;
      player2Name = p2Name;
    }

    updateGameInfoDisplay?.();
    showScreen('game-play-area');
    renderAll?.();
    triggerNextAction?.();

    // Persist room status + initial payload
    onlineSendState('start');
    _setOnlineStatus(t('onlineStartOK', "Partie lancée ✅"));
  } catch (e) {
_setOnlineStatus(t('onlineStartErrorPrefix', 'Erreur lancement : {msg}').replace('{msg}', (e?.message || String(e))));
  }
}

function onlineApplyState(msg) {
  if (!msg || !msg.state) return;

  // Prevent echo (apply -> saveGame -> onlineSendState)
  online.suppressSend = true;

  try {
    if (msg.variant && variantConfig[msg.variant]) variant = msg.variant;
    gameMode = 'online';

    if (msg.meta) {
      if (msg.meta.player1Name) player1Name = msg.meta.player1Name;
      if (msg.meta.player2Name) player2Name = msg.meta.player2Name;
    }

    // Forward-compatible merge (prevents missing fields when saves/payloads evolve)
    const defaults = initState();
    const s = msg.state || {};
    const merged = {
      ...defaults,
      ...s,
      counts: { ...defaults.counts, ...(s.counts || {}) },
      captured: { ...defaults.captured, ...(s.captured || {}) }
    };

    // Normalize a few fields that sometimes arrive as undefined
    if (!Array.isArray(merged.board)) merged.board = defaults.board.slice();
    if (!Array.isArray(merged.highlightedMills)) merged.highlightedMills = [];
    if (!Array.isArray(merged.lastMove)) merged.lastMove = [];

    state = JSON.parse(JSON.stringify(merged));

    aiPlayerId = null;

    // Rematch metadata (optional but used for replay + alternance couleurs)
    try {
      const incomingGameId = (msg.meta && msg.meta.gameId != null) ? Number(msg.meta.gameId) : null;
      const incomingSwap = (msg.meta && typeof msg.meta.swapColors !== 'undefined') ? !!msg.meta.swapColors : null;

      const prevGameId = online.gameId || 0;
      if (incomingGameId != null && !Number.isNaN(incomingGameId)) {
        const isNewGame = incomingGameId !== prevGameId;
        online.gameId = incomingGameId;

        if (isNewGame) {
          // Reset local-only histories so replay doesn't keep previous game undo/history
          try { moveHistory = []; } catch(_) {}
          try { boardPositionHistory = new Map(); } catch(_) {}
          try { forbiddenBoardPositions = new Set(); } catch(_) {}
          try { hideWinnerAnimation?.(); } catch(_) {}
          try { clearSave?.(); hideSaveNotification?.(); } catch(_) {}
        }
      }

      if (incomingSwap != null) online.swapColors = incomingSwap;

      online.playerId = online.swapColors ? (3 - (online.role || 1)) : (online.role || 1);
    } catch(_) {}

    humanPlayerId = online.playerId || online.role || humanPlayerId;

    // Full UI refresh (board + counts + badges + history, etc.)
    if (typeof updateGameInfoDisplay === 'function') updateGameInfoDisplay();
    if (typeof renderAll === 'function') renderAll();
    else { renderBoard(); updateStatus(); }

    // Ephemeral UI: auto-clear mill highlights locally (do not affect game logic)
    try {
      if (state && Array.isArray(state.highlightedMills) && state.highlightedMills.length > 0) {
        if (online._millHiTimer) clearTimeout(online._millHiTimer);
        online._millHiTimer = setTimeout(() => {
          try {
            if (gameMode !== 'online') return;
            state.highlightedMills = [];
            if (typeof renderBoard === 'function') renderBoard();
          } catch(_) {}
        }, 1500);
      }
    } catch(_) {}

    // If remote state ends the game, show correct local end-screen (victory/defeat)

    try {
      const wo = document.getElementById('winner-overlay');
      const alreadyShown = wo && wo.classList.contains('active');
      if (state && state.winner && typeof endGame === 'function' && !alreadyShown) endGame();
    } catch (_) {}

    // Persist locally (but do not re-broadcast)
    saveGame();
  } catch (e) {
} finally {
    online.suppressSend = false;
  }
}

function isMyTurnOnline() {
  if (gameMode !== 'online') return true;
  const actor = (state && state.captureMode) ? state.turnForCapture : state?.turn;
  const me = online.playerId || online.role;
  return (me && actor) ? (me === actor) : true;
}

// Helpers DOM rapides
const $ = (sel, root = document) => root.querySelector(sel);
const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
const safeJSONParse = (s, fb = null) => {
try {
return JSON.parse(s);
} catch(_) {
return fb;
}
};
const nowMs = () => Date.now();
const clamp = (n, a, b) => Math.max(a, Math.min(b,
n));


// ============================================================
// === SAFE HTML HELPERS ===
// ============================================================
const MAX_NAME_LEN = 24;
function normalizeName(raw, fallback) {
const s = String(raw ?? '').replace(/[\u0000-\u001F\u007F]/g, ' ').replace(/\s+/g, ' ').trim();
if (!s) return fallback;
const clipped = s.slice(0, MAX_NAME_LEN);
return clipped.replace(/[<>]/g, '');
}

const ALLOWED_TAGS = new Set(['STRONG', 'EM', 'B', 'I', 'BR', 'SMALL', 'U', 'MARK', 'SUP', 'SUB', 'SPAN']);
function sanitizeHTML(html) {
const tpl = document.createElement('template');
tpl.innerHTML = String(html ?? '');
const walk = (node) => {
const children = Array.from(node.childNodes);
for (const child of children) {
if (child.nodeType === Node.ELEMENT_NODE) {
const tag = child.tagName.toUpperCase();
if (!ALLOWED_TAGS.has(tag)) {
child.replaceWith(document.createTextNode(child.textContent || ''));
continue;
}
for (const attr of Array.from(child.attributes)) child.removeAttribute(attr.name);
walk(child);
} else if (child.nodeType === Node.COMMENT_NODE) {
child.remove();
}
}
};
walk(tpl.content);
return tpl.innerHTML;
}

function setSafeHTML(el, html) {
if (!el) return;
el.innerHTML = sanitizeHTML(html);
}



// ============================================================
// === CANVAS CONFETTI (no external dependency) ===
// ============================================================
const _confettiCanvas = document.getElementById('confetti-canvas');
const _ctx2d = _confettiCanvas?.getContext('2d');
let _confettiRAF = 0;

(function() {
function resizeCanvas() {
if (!_confettiCanvas) return;
const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
_confettiCanvas.width = Math.floor(window.innerWidth * dpr);
_confettiCanvas.height = Math.floor(window.innerHeight * dpr);
_confettiCanvas.style.width = window.innerWidth + 'px';
_confettiCanvas.style.height = window.innerHeight + 'px';
_ctx2d?.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resizeCanvas, {
passive: true
});
resizeCanvas();
})();

function runConfetti(durationMs = 4500) {
if (!_confettiCanvas || !_ctx2d) return;
cancelAnimationFrame(_confettiRAF);
const start = performance.now();
const particles = [];
const colors = ['#f0c850',
'#ffffff',
'#00ffff',
'#ff4d4d',
'#d0c4b2'];

const emit = () => {
const n = 14;
for (let i = 0; i < n; i++) {
particles.push({
x: Math.random()*window.innerWidth,
y: -10,
vx: (Math.random()-0.5)*5,
vy: Math.random()*3+2,
color: colors[Math.floor(Math.random()*colors.length)],
r: Math.random()*5+3,
life: 1.0,
decay: Math.random()*0.008+0.004,
spin: (Math.random()-0.5)*0.3
});
}
};

const tick = (ts) => {
const elapsed = ts - start;
if (elapsed < durationMs) emit();
_ctx2d.clearRect(0, 0, window.innerWidth, window.innerHeight);
for (let i = particles.length-1; i >= 0; i--) {
const p = particles[i];
p.x += p.vx; p.y += p.vy; p.vy += 0.07;
p.life -= p.decay;
if (p.life <= 0 || p.y > window.innerHeight + 60) {
particles.splice(i, 1); continue;
}
_ctx2d.save();
_ctx2d.globalAlpha = Math.max(0, p.life);
_ctx2d.fillStyle = p.color;
_ctx2d.translate(p.x, p.y);
_ctx2d.rotate(p.spin * elapsed * 0.01);
_ctx2d.fillRect(-p.r/2, -p.r/2, p.r, p.r * 1.6);
_ctx2d.restore();
}
if (particles.length > 0 || elapsed < durationMs) {
_confettiRAF = requestAnimationFrame(tick);
} else {
_ctx2d.clearRect(0, 0, window.innerWidth, window.innerHeight);
}
};
_confettiRAF = requestAnimationFrame(tick);
}



// --- CONSTANTS AND GLOBAL VARIABLES ---
const SIZE = 5;
const PIECES = 10;

let state;
let variant = null;
let gameMode = null;
let aiDifficulty = null;
let currentScreen = 'version-selection-area';
let moveHistory = [];

let player1Name = "Joueur 1";
let player2Name = "Joueur 2";
let humanPlayerId = 1;
let aiPlayerId = null;
let currentLanguage = 'fr';
let onConfirmCallback = null;

// ============================================================
// === PLAYER NAMES (setup) — persistent save on each edit ===
// ============================================================
const NAMES_KEY = 'tiddas_names_v1';
let __nameSaveT = 0;

function loadNamePrefs() {
  try {
    const raw = localStorage.getItem(NAMES_KEY);
    const parsed = raw ? safeJSONParse(raw, null) : null;
    if (parsed && typeof parsed === 'object' && parsed.v === 1) {
      return {
        v: 1,
        p1: String(parsed.p1 || ''),
        p2: String(parsed.p2 || ''),
        updatedAt: Number(parsed.updatedAt || 0)
      };
    }
  } catch (_) {}
  return { v: 1, p1: '', p2: '', updatedAt: 0 };
}

function saveNamePrefs(p1Field, p2Field) {
  const data = {
    v: 1,
    p1: String(p1Field || ''),
    p2: String(p2Field || ''),
    updatedAt: nowMs()
  };
  try {
    localStorage.setItem(NAMES_KEY, JSON.stringify(data));
  } catch (_) {}
}

function applySavedSetupNames(isAiMode) {
  const pref = loadNamePrefs();
  if (player1NameInput) player1NameInput.value = pref.p1 || '';
  if (player2NameInput) player2NameInput.value = isAiMode ? '' : (pref.p2 || '');
}

function scheduleSaveNamePrefs() {
  if (__nameSaveT) window.clearTimeout(__nameSaveT);
  __nameSaveT = window.setTimeout(() => {
    const p1 = normalizeName(player1NameInput?.value || '', '');
    const p2 = normalizeName(player2NameInput?.value || '', '');
    saveNamePrefs(p1, p2);
    // Keep stats UI up-to-date if the modal is open
    try {
      if (typeof renderStats === 'function') renderStats();
    } catch (_) {}
  }, 120);
}


// --- DOM ELEMENTS CACHE ---
const boardDiv = document.getElementById("board");
const statusDiv = document.getElementById("status");
const p1Count = document.getElementById("p1-count");
const p2Count = document.getElementById("p2-count");
const p1Capt = document.getElementById("p1-capt");
const p2Capt = document.getElementById("p2-capt");
const p1Info = document.querySelector('.player1-info');
const p2Info = document.querySelector('.player2-info');
const allScreens = document.querySelectorAll('.selection-area, .game-play-area');
const versionCards = document.querySelectorAll('.version-card');
const player1NameInput = document.getElementById('player1-name-input');
const player2NameInput = document.getElementById('player2-name-input');
const p1DisplayName = document.getElementById('p1-display-name');
const p2DisplayName = document.getElementById('p2-display-name');
const languageSelect = document.getElementById('language-select');
const ephemeralMessageBubble = document.getElementById('ephemeral-message-bubble');
const winnerOverlay = document.getElementById('winner-overlay');
const winnerNameElement = winnerOverlay ? winnerOverlay.querySelector('.winner-name') : null;
const winnerReplayButton = document.getElementById('winner-replay-button');
const winnerMenuBtn = document.getElementById('winner-menu-btn');
const mainHeader = document.getElementById('main-header');
const player1NameLabel = document.getElementById('player1-name-label');
const player2NameGroup = document.getElementById('player2-name-group');
const colorChoiceSection = document.getElementById('color-choice-section');
const colorOptions = document.querySelectorAll('.color-option');
const confirmationModal = document.getElementById('confirmation-modal');
const modalTitle = document.getElementById('modal-title');
const modalMessage = document.getElementById('modal-message');
const modalConfirmBtn = document.getElementById('modal-confirm-btn');
const modalCancelBtn = document.getElementById('modal-cancel-btn');
const surrenderBtn = document.getElementById('surrender');
const undoBtn = document.getElementById('undo-btn');
const rulesModal = document.getElementById('rules-modal');
const showRulesBtn = document.getElementById('show-rules-btn');
const rulesCloseBtn = document.getElementById('rules-close-btn');
const aboutModal = document.getElementById('about-modal');
const showAboutBtn = document.getElementById('show-about-btn');
const aboutCloseBtn = document.getElementById('about-close-btn');

// --- VARIANT CONFIGURATION ---
const variantConfig = {
"TIDDEST-no-diag": {
name: "TIDDEST",
isInverseWin: false,
forceMillMove: false
},
"bessif-TIDDEST": {
name: "Učči bessif TIDDEST",
isInverseWin: true,
forceMillMove: true
}
};
// Accesseur sécurisé : retourne toujours une config valide même si variant est null/invalide
function cfg() {
return variantConfig[variant] || variantConfig['TIDDEST-no-diag'];
}
const aiDifficultyNames = {
1: "Easy",
2: "Medium",
3: "Hard",
4: "Expert"
};

// --- TRANSLATIONS ---
const translations = {
fr: {
backToMenu: "Menu",
onlineRematchHint: "Revanche",
onlineReadyRematch: "Je suis prêt",
onlineReadyRematchOn: "Prêt ✅",
onlineRematchNote: "Les couleurs alternent à chaque revanche.",
onlineRematchReadyToast: "Revanche: prêt. Attendez l'autre joueur…",
onlineRematchGuestInfo: "Partie terminée. Clique « Je suis prêt » pour la revanche.",
onlineRematchWaitReady: "En attente des joueurs prêts…",
onlineRematchCanStart: "Tout le monde est prêt ✅",
onlineRematchStart: "Lancer la revanche",
onlineRematchStartDesc: "Quand les 2 joueurs sont prêts",
onlineStatusPlayingHost: "Partie en cours. Bon jeu !",
onlineStatusPlayingGuest: "Partie en cours. Bon jeu !",
onlineGameFinished: "Cette partie est terminée.",
statsSectionActivity: "Activité",
statsPlacementsPerGame: "Placements / partie",
statsMovesPerGame: "Déplacements / partie",
statsActionsPerGame: "Coups / partie",
statsOnlineTopOpponent: "Adversaire favori",
statsActionsCount: "Coups",
statsPlacementsCount: "Placements",
statsMovesCount: "Déplacements",
resetStatsConfirm: "Réinitialiser les statistiques ?",
toastStatsReset: "Stats réinitialisées.",
toastExported: "Export généré.",
noStatsYet: "Aucune statistique pour l'instant. Lance une partie !",
statsSectionGlobal: "Vue globale",
gamesPlayedLabel: "Parties",
durationLabel: "Temps total",
avgDuration: "Durée moy. / partie",
statsBestWinTime: "Meilleure victoire",
actionsPerGameLabel: "Coups / partie",
statsCaptPerGame: "Captures / partie",
statsMillsPerGame: "Moulins / partie",
levelLabel: "Niveau",
statsLevelProgress: "Prochain niveau",
statsSectionByMode: "Par mode",
modeAI: "IA",
modeLocal: "Local",
statsOnlineMode: "En ligne",
modeSpectator: "Spectateur",
winRateLabel: "Taux de victoire",
winsLabel: "Victoires",
lossesLabel: "Défaites",
drawsLabel: "Nuls",
statsStreakCurrent: "Série actuelle",
statsStreakBest: "Meilleure série",
statsAvgDurPerMode: "Durée moy.",
statsByDifficulty: "Par difficulté",
statsSectionLastGame: "Dernière partie",
modeLabel: "Mode",
statsVariantLabel: "Variante",
winnerLabel: "Vainqueur",
capturesLabel: "Captures",
millsLabel: "Moulins",
player1ColorShort: "Noir",
player2ColorShort: "Blanc",
onlineStatusCreatedHost: "Salon créé. Partage le code et attends un adversaire…",
onlineStatusConnecting: "Connexion…",
onlineStatusTwoPlayersHost: "2 joueurs connectés. Tu peux lancer la partie.",
onlineStatusTwoPlayersGuest: "2 joueurs connectés. En attente du lancement…",
onlineChooseAction: "Choisis : créer ou rejoindre un salon.",

playSpectator: "Mode Spectateur",
installApp: "Installer",
playSpectatorDesc: "Regardez deux IA s'affronter",
spectatorSpeed: "Vitesse :",
speedSlow: "Lente",
speedNormal: "Normale",
speedFast: "Rapide",
moveHistoryTitle: "Historique des coups",
logPlace: "place en",
logMove: "de",
logMoveTo: "→",
logMill: "⚡ Tlata S Ya !",
logCapture: "💀 Capture en",
savedGameFound: "Partie sauvegardée trouvée. Reprendre ?",
themeClassic: "Classique",
themeDesert: "Désert",
themeNuit: "Nuit",
surrender: "Abandonner",
confirm: "Confirmer",
cancel: "Annuler",
defaultPlayer1: "Joueur 1",
defaultPlayer2: "Joueur 2",
defaultComputerName: "L'ordinateur",
defaultHumanName: "Humain",
appTitle: "Tiddas - Jeu",
chooseVersion: "Choisir la version du jeu :",
TIDDESTTitle: "TIDDEST",
TIDDESTDesc: "Pas de capture pendant le placement. Interdiction d'aligner 3 pions pendant le placement. Déplacements et captures uniquement horizontaux/verticaux. Victoire normale.",
bessifTitle: "Učči Bessif",
bessifDesc: "Mêmes règles que TIDDEST. Victoire inversée: gagnez en perdant tous vos pions. Quand vous formez un moulin, votre adversaire choisit un de ses pions à capturer.",
howToPlay: "Comment souhaitez-vous jouer ?",
playOnline: "Jouer en ligne",
playOnlineDesc: "Créer ou rejoindre une partie",
playAI: "Jouer contre l'ordinateur",
playAIDesc: "Affrontez une intelligence artificielle",
playOffline: "Jouer hors-ligne",
playOfflineDesc: "Partie locale sur votre appareil",
backToVersions: "Retour",
chooseAIDifficulty: "Choisir la difficulté de l'ordinateur",
difficultyEasy: "Facile",
difficultyMedium: "Moyen",
difficultyHard: "Difficile",
difficultyImpossible: "Expert",
difficultyEasyDesc: "L'ordinateur joue au hasard",
difficultyMediumDesc: "L'ordinateur est un adversaire correct",
difficultyHardDesc: "L'ordinateur est un vrai stratège",
difficultyImpossibleDesc: "L'IA anticipe vos moindres faits et gestes",
backToModes: "Retour",
playerSetup: "Configuration des joueurs",
playerNamesTitle: "Noms des joueurs",
chooseYourColorTitle: "Vous jouez avec les :",
colorLabelLocal: "Joueur 1 joue avec les :",
psuSubtitle: "Renseignez vos noms et choisissez votre camp",
colorDescBlack: "Joue en second",
colorDescWhite: "Commence en premier",
playerHumanName: "Nom de l'Humain :",
player1NameLabel: "Nom du Joueur 1 (Noir) :",
player2NameLabel: "Nom du Joueur 2 (Blanc) :",
yourNamePlaceholder: "Votre Nom",
player2Placeholder: "Joueur 2",
yourColor: "Votre couleur",
aiColor: "Couleur de l'IA",
player1Color: "Noir (Joueur 1)",
player2Color: "Blanc (Joueur 2)",
playButton: "Jouer",
gameVersion: "Version :",
aiDifficultyDisplayLabel: "Difficulté IA :",
ephemeralMill: "Tlata S Ya !",
ephemeralCaptureNormal: "Awi-d Wa !",
ephemeralCaptureBessif: "Ddem wa !",
ephemeralMovePhase: "Tallit n unaqel !",
newGame: "Accueil",
restartGame: "Recommencer",
undoMove: "Annuler",
gameRulesTitle: "Règles du Jeu",
rulesGeneral: "Règles Générales de Tiddas (Communes à toutes les variantes) :",
rulesObjectiveStrong: "Objectif :",
rulesObjective: "Le but principal est de réduire le nombre de pions de votre adversaire à moins de trois, ou de le bloquer de manière à ce qu'il ne puisse plus effectuer de mouvements valides. Pour la variante Učči bessif TIDDEST, l'objectif est inversé : le joueur gagne s'il réduit son propre nombre de pions à moins de trois.",
rulesPiecesStrong: "Pions :",
rulesPieces: "Chaque joueur dispose de 10 pions (appelés \"cailloux\"). Le Joueur 2 (Blanc) commence toujours.",
rulesPhasesStrong: "Phases de Jeu :",
rulesPlacementPhaseStrong: "Phase de Placement :",
rulesPlacementPhase: "Les joueurs placent à tour de rôle un de leurs pions sur n'importe quelle case vide du plateau. Cette phase continue jusqu'à ce que les 20 pions (10 pour chaque joueur) soient placés.",
rulesMovePhaseStrong: "Phase de Déplacement :",
rulesMovePhase: "Une fois tous les pions placés, les joueurs déplacent à tour de rôle l'un de leurs pions d'une case à la fois vers une case adjacente (horizontalement ou verticalement) qui est vide.",
rulesMillStrong: "Moulin (Alignement) :",
rulesMill: "Former un alignement de <strong>strictement 3 pions</strong> de sa couleur (horizontalement ou verticalement). <strong>Les alignements en diagonale ne sont pas considérés comme des moulins valides.</strong>",
rulesCaptureStrong: "Capture :",
rulesCapture: "Lorsqu'un joueur forme un moulin (horizontal ou vertical de 3 pions), il a le droit de \"manger\" (capturer) un pion adverse.",
rulesCapturePlacementRestrictionStrong: "Alignement de 3 interdit pendant le placement :",
rulesCapturePlacementRestriction: "Il est interdit de placer un pion de manière à former un moulin de 3 pions ou plus. Par conséquent, <strong>aucune capture n'est possible pendant la phase de placement</strong>. Les captures sont uniquement possibles en phase de déplacement.",
rulesCaptureAllPiecesStrong: "Tous les pions sont capturables :",
rulesCaptureAllPieces: "Dans toutes les variantes de ce jeu, <strong>tous les pions peuvent être capturés</strong>, même s'ils font partie d'un moulin. Il n'y a pas de pions \"protégés\".",
rulesForcedMoveStrong: "Règle de déplacement forcé de moulin :",
rulesForcedMove: "En phase de déplacement, si un joueur a la possibilité de former un moulin avec un de ses pions, il est <strong>obligé</strong> de le faire. Si plusieurs mouvements permettent de former un moulin, le joueur peut choisir l'un d'entre eux.",
rulesDifferences: "Différences entre les variantes :",
rulesDifferencesIntro: "Les règles de base s'appliquent, mais chaque variante introduit des spécificités importantes :",
rulesTIDDEST: "TIDDEST :",
rulesTIDDESTMovesStrong: "Déplacements :",
rulesTIDDESTMoves: "Uniquement horizontaux/verticaux. Les déplacements en diagonale sont interdits.",
rulesTIDDESTCapturesStrong: "Captures :",
rulesTIDDESTCaptures: "Le joueur qui forme le moulin choisit quel pion adverse capturer.",
rulesTIDDESTWinStrong: "Victoire :",
rulesTIDDESTWin: "Normale.",
rulesTIDDESTNoForcedMoveStrong: "Pas de déplacement forcé de moulin :",
rulesTIDDESTNoForcedMove: "La règle du déplacement forcé de moulin ne s'applique pas.",
rulesBessif: "Učči Bessif :",
rulesBessifCombines: "Combine les règles de <strong>TIDDEST</strong> avec le principe de <strong>victoire inversée</strong>.",
rulesBessifMovesStrong: "Déplacements :",
rulesBessifMoves: "Uniquement horizontaux/verticaux.",
rulesBessifInverseWinStrong: "Victoire Inversée :",
rulesBessifInverseWin: "Le joueur gagne si son propre nombre de pions est réduit à moins de trois (c'est-à-dire 0, 1 ou 2 pions), OU si son adversaire est bloqué et qu'il (le joueur qui vient de jouer) a moins de pions sur le plateau que son adversaire.",
rulesBessifOpponentChoosesStrong: "Choix du pion à capturer :",
rulesBessifOpponentChooses: "Lorsque vous formez un moulin, c'est votre <strong>adversaire</strong> qui doit choisir l'un de ses propres pions que vous allez capturer.",
rulesBessifForcedMoveStrong: "Déplacement forcé pour former un moulin :",
rulesBessifForcedMove: "La règle du déplacement forcé de moulin s'applique.",
footerHeritage: "Patrimoine Culturel Amazigh • Jeu Traditionnel Kabyle",
footerCreator: "Créé par",
congratulations: "Félicitations !",
winnerMessage: "a gagné !",
replay: "Rejouer",
statusPlayerTurn: "Au tour de",
statusChooseCapture: "choisissez un pion de",
statusToCapture: "à capturer.",
statusChooseSacrifice: "doit choisir un de ses pions à sacrifier.",
statusPlacementPhase: "Phase de placement : Au tour de",
statusMovePhase: "Phase de déplacement : Au tour de",
statusGameOver: "Fin de partie !",
statusAlreadyOccupied: "Cette case est déjà occupée !",
statusNoPiecesToPlace: "Vous n'avez plus de pions à placer !",
statusPlacementAlignForbidden: "Alignement de 3 interdit pendant le placement !",
statusYourPiecesTurn: "C'est le tour de vos pions !",
statusSelectYourPiece: "Veuillez sélectionner un de vos pions.",
statusInvalidMove: "Mouvement invalide.",
statusMustMakeMill: "Vous devez faire un moulin si possible !",
statusChooseOwnPieceToSacrifice: "Vous devez choisir un de VOS pions à sacrifier !",
statusChooseOpponentPieceToCapture: "Vous devez choisir un pion de l'ADVERSAIRE à capturer !",
aiCannotMove: "L'ordinateur ne peut pas bouger et perd la partie !",
statusConsecutiveBlocked: "Ce pion a déjà joué 3 fois de suite ! Jouez un autre pion.",
youLost: "Vous avez perdu 😭",
aiWinsMessage: "a gagné !",
surrenderConfirm: "Êtes-vous sûr de vouloir abandonner ?",
surrenderMessage: "a abandonné !",

stats: "Stats",
statsTitle: "Statistiques",
resetStats: "Réinitialiser",
exportStats: "Exporter",
close: "Fermer",
replayTitle: "Replay",
replayLast: "Replay",
guidedMode: "Guidé",
speed: "Vitesse",
installHelpTitle: "Installer l'app",
installHelpBody: "Astuce : sur iPhone/iPad, utilisez “Partager” → “Sur l'écran d'accueil”. Sur Android/Chrome, le bouton “Installer” apparaît si l'app est éligible.",
toastInstalled: "✅ App installée.",
toastInstallUnavailable: "ℹ️ Installation non disponible sur ce navigateur.",
toastReplayReady: "⏯️ Replay prêt.",
toastNoReplay: "Aucune partie à rejouer.",
toastStatsReset: "Stats réinitialisées.",
toastExported: "Export généré.",
toastSWReady: "✅ Mode hors-ligne prêt.",
toastSWUpdate: "🔄 Mise à jour dispo : rechargez l'app.",
boardAria: "Plateau de jeu",
cellLabel: "Case",
cellEmpty: "vide",
gamesPlayedLabel: "Parties",
winsLabel: "Victoires",
lossesLabel: "Défaites",
winRateLabel: "Taux de victoire",
streakLabel: "Série",
bestStreakLabel: "Meilleure série",
movesLabel: "Coups",
capturesLabel: "Captures",
millsLabel: "Moulins",
durationLabel: "Durée",
levelLabel: "Niveau",
xpLabel: "XP",
lastGameLabel: "Dernière partie",
btnTheme: "Thème",
btnSound: "Son",
btnSettings: "Paramètres",
btnDragMode: "Glisser",
themeGlass: "Verre",
themeContrast: "Contraste",
themeModern: "Moderne",
themeModernDark: "Moderne nuit",
themeKabylie: "Kabylie",
// Éléments codés en dur qui ne passaient pas par i18n
spectatorBadgeTxt: "👁 Mode Spectateur",
btnResume: "Reprendre",
btnDiscard: "Non",
ariaRulesClose: "Fermer",
ariaReplayFirst: "Début",
ariaReplayPrev: "Précédent",
ariaReplayPlay: "Lecture/Pause",
ariaReplayNext: "Suivant",
ariaReplayLast: "Fin",
ariaSettingsFab: "Paramètres",
ariaInstallBtn: "Installer l'application",
ariaModeGuide: "Mode guidé",
aboutTitle: "À propos de l'application",
aboutIntro: "Cette application est née d'un désir simple : <strong>préserver et transmettre</strong> un trésor de notre patrimoine kabyle.",
aboutP1: "<em>Tiddas</em>, pluriel de <em>Tiddest</em>, est bien plus qu'un jeu. C'est un art du raisonnement, un exercice de stratégie, un espace de réflexion où chaque mouvement compte. Autrefois gravé sur les bancs en béton des <em>taɛessast</em> de nos villages, il réunissait enfants, adultes et anciens autour d'un quadrillage de 25 cases et de simples cailloux appelés <em>ileqqafen</em>.",
aboutP2: "Ma génération fait sans doute partie des dernières à avoir connu ce jeu dans sa forme traditionnelle\u00a0: tracé à la craie, gravé dans la pierre ou esquissé au silex. Aujourd'hui, cette application lui offre une nouvelle vie, sans en trahir l'esprit.",
aboutP3: "Tiddas est un jeu de stratégie combinatoire abstrait, proche du jeu de dames et du morpion romain. <strong>Deux joueurs, dix pions chacun.</strong> L'objectif\u00a0: former un alignement de trois pions pour capturer ceux de l'adversaire, tout en évitant ses pièges.",
aboutVariantClassic: "La version classique.",
aboutVariantBessif: "Perdre tous ses pions devient… la clé de la victoire.",
aboutP4: "À travers cette application, nous souhaitons permettre à chacun de redécouvrir ce jeu ancestral, de le transmettre aux nouvelles générations et de perpétuer cet héritage stratégique.",
aboutQuoteTrans: "La vie est comme Tiddest\u00a0: si tu es pigé, lève-toi.",
aboutBtnLabel: "À propos",
avgDuration: "Durée moyenne",
winnerLabel: "Vainqueur",
actionsPerGameLabel: "Coups / partie",
modeAI: "IA",
modeLocal: "Local",
modeSpectator: "Spectateur",
modeLabel: "Mode",
noStatsYet: "Aucune statistique pour l'instant. Lance une partie !",
replayMoveLabel: "Coup",
ariaReplayExit: "Fermer",
ariaReplayInfo: "Infos",
woSubDefeat: "— Fin de partie —",
woSubVictory: "— Victoire —",

onlineTitle: "Multijoueur en ligne",
onlineProfileTitle: "Profil",
onlineProfileDesc: "Ton pseudo sera affiché à l’adversaire",
onlineYourNameLabel: "Ton nom",
onlineNameHint: "Ce nom est mémorisé sur ton appareil.",
onlineRoomTitle: "Salon",
onlineRoomDesc: "Crée un code ou rejoins un code existant",
onlineSubtitle: "Créez un salon et partagez le code, ou rejoignez un salon existant.",
onlineCreate: "Créer un salon",
onlineCreateDesc: "Génère un code",
onlineJoin: "Rejoindre",
onlineJoinDesc: "Entrer un code",
onlineRoomCode: "Code du salon",
onlineConnect: "Connexion",
onlineConnectDesc: "Se connecter au salon",
onlineStatusTitle: "Statut",
onlineShare: "Partagez ce code :",
onlineStart: "Lancer la partie",
onlineStartDesc: "Quand 2 joueurs sont connectés",
onlineNotConfigured: "Le serveur en ligne n'est pas configuré. Consultez le README pour renseigner l'URL.",
onlineNamePlaceholder: "Ex: Boussad",
onlineCopyCodeAria: "Copier le code",
onlineChooseAction: "Choisis : créer ou rejoindre un salon.",
onlineCodeCopied: "Code copié ✅",
onlineStatusTwoPlayersHost: "2 joueurs connectés. Tu peux lancer la partie.",
onlineStatusTwoPlayersGuest: "2 joueurs connectés. En attente du lancement…",
onlineStatusCreatedHost: "Salon créé. Partage le code et attends un adversaire…",
onlineStatusConnecting: "Connexion…",
onlineCreatingRoom: "Création du salon {code}…",
onlineCodeAlreadyUsed: "Code déjà utilisé. Réessaie avec un autre code.",
onlineCreatedShare: "Salon créé. Partage le code : {code}",
onlineConnectingRoom: "Connexion au salon {code}…",
onlineRoomNotFound: "Salon introuvable. Vérifie le code.",
onlineGameFinished: "Cette partie est terminée.",
onlineRoomFull: "Salon complet (2 joueurs).",
onlineNetworkError: "Erreur réseau Back4App. Vérifie les permissions (CLP) et ta connexion.",
onlineParseNotReady: "Back4App n'est pas configuré ou Parse SDK non chargé.",
onlineSendError: "Erreur d'envoi. Vérifie ta connexion Back4App.",
onlineNoRoomActive: "Pas de salon actif.",
onlineOnlyHostStart: "Seul l’hôte peut lancer la partie.",
onlineBack4AppNotReady: "Back4App n'est pas prêt.",
onlineWaitTwoPlayers: "Attends que 2 joueurs soient connectés.",
onlineStartOK: "Partie lancée ✅",
onlineStartErrorPrefix: "Erreur lancement : {msg}",
onlineErrorPrefix: "Erreur : {msg}",
onlineRecentRooms: "Salons récents",
onlineRejoinLast: "Reprendre le dernier salon",
onlineRejoinLastDesc: "Reconnexion rapide",
notYourTurn: "Ce n'est pas ton tour.",
onlineInviteBtn: "Inviter un ami",
onlinePanelCode: "Code seul",
onlinePanelLink: "Lien de partie",
onlinePanelShare: "Partager",
onlineAutoJoinDetected: "Salon détecté : {code}",
onlineAutoJoinWaiting: "Entrez votre nom pour rejoindre",
onlineJoinParam: "Connexion automatique à {code}…",
onlineRecentEmpty: "Aucun salon récent",
onlineChipVs: "vs",
onlineChipPending: "En attente",
onlineCodePreview: "Votre code :",
onlineCodeConfirm: "Créer ce salon ?",
onlineLinkCopied: "Lien copié ✅",
onlineCopyLinkAria: "Copier le lien",
onlineShareLinkAria: "Partager",
onlineShareText: "Rejoins mon salon Tiddas :",
statsSectionGlobal: "Vue globale",
statsSectionEfficiency: "Efficacité",
statsSectionByMode: "Par mode",
statsSectionLastGame: "Dernière partie",
statsBestWinTime: "Meilleure victoire",
statsCaptPerGame: "Captures / partie",
statsMillsPerGame: "Moulins / partie",
statsAvgDurPerMode: "Durée moy.",
statsStreakCurrent: "Série actuelle",
statsStreakBest: "Meilleure série",
statsByDifficulty: "Par difficulté",
statsOnlineOpponents: "Adversaires",
statsVariantLabel: "Variante",
statsActionsCount: "Coups",
statsLevelProgress: "Prochain niveau",
statsOnlineMode: "En ligne",
statsDraws: "Nuls",
},
kab: {
backToMenu: "Menu",
onlineRematchHint: "Revanche",
onlineReadyRematch: "Neɣ d iwejden",
onlineReadyRematchOn: "Iwejden ✅",
onlineRematchNote: "Initen ttbedden deg yal revanche.",
onlineRematchReadyToast: "Revanche: iwejden. Ṛǧu amgraw…",
onlineRematchGuestInfo: "Tura tfa. Sit ɣef « Neɣ d iwejden » i revanche.",
onlineRematchWaitReady: "Ṛǧu imeddukal ad ilin iwejden…",
onlineRematchCanStart: "Akk iwejden ✅",
onlineRematchStart: "Bdu revanche",
onlineRematchStartDesc: "Mi ara ilin sin iwejden",
onlineStatusPlayingHost: "Uraren tura. Abrid!",
onlineStatusPlayingGuest: "Uraren tura. Abrid!",
onlineGameFinished: "Uraren-agi yefra.",
statsSectionActivity: "Armud",
statsPlacementsPerGame: "Aseɣẓan / urar",
statsMovesPerGame: "Tirawin / urar",
statsActionsPerGame: "Tir / urar",
statsOnlineTopOpponent: "Amgraw ameqqran",
statsActionsCount: "Tirawin",
statsPlacementsCount: "Aseɣẓan",
statsMovesCount: "Tirawin",
resetStatsConfirm: "Sfeḍ tistatistik?",
toastStatsReset: "Tistatistik ttwafeḍ.",
toastExported: "Asuffeɣ yettwaǧǧa.",
noStatsYet: "Ulac tistatistik tura. Bdu urar!",
statsSectionGlobal: "Amezwaru",
gamesPlayedLabel: "Iurar",
durationLabel: "Akud amatu",
avgDuration: "Akud alemmas / urar",
statsBestWinTime: "Arraz yelhan",
actionsPerGameLabel: "Tir / urar",
statsCaptPerGame: "Ttekki / urar",
statsMillsPerGame: "Aline / urar",
levelLabel: "Aswir",
statsLevelProgress: "Aswir i d-iteddun",
statsSectionByMode: "S tarrayt",
modeAI: "IA",
modeLocal: "Ader",
statsOnlineMode: "Deg uẓeṭṭa",
modeSpectator: "Ameskan",
winRateLabel: "Afellay n rrbaḥ",
winsLabel: "Rbaḥ",
lossesLabel: "Ttfa",
drawsLabel: "Isemmaḍ",
statsStreakCurrent: "Aseḍḍad amiran",
statsStreakBest: "Aseḍḍad yelhan",
statsAvgDurPerMode: "Akud alemmas",
statsByDifficulty: "S uswir",
statsSectionLastGame: "Urar aneggaru",
modeLabel: "Tarrayt",
statsVariantLabel: "Tameslayt",
winnerLabel: "Aɣellif",
capturesLabel: "Ttekki",
millsLabel: "Aline",
player1ColorShort: "Aberkan",
player2ColorShort: "Amlal",
onlineStatusCreatedHost: "Tessut tura. Bḍu asaru n wakuḍ u ṛǧu amgraw…",
onlineStatusConnecting: "Ittwaqqen…",
onlineStatusTwoPlayersHost: "Sin imdanen qqnen. Tzemreḍ ad tebduḍ.",
onlineStatusTwoPlayersGuest: "Sin imdanen qqnen. Ṛǧu i usdukel ad yebdu…",
onlineChooseAction: "Fren: xleq neɣ kcem ar salon.",

surrender: "Mayna",
installApp: "Areṣṣi",
playSpectator: "Anezzeh",
playSpectatorDesc: "Urar n yiselkimen",
spectatorSpeed: "tazla :",
speedSlow: "s laɛqel",
speedNormal: "swaswa kan",
speedFast: "s uɣiwel",
moveHistoryTitle: "Ansa i yekka wurar",
logPlace: "yesres",
logMove: "seg",
logMoveTo: "→",
logMill: "⚡ Tlata S Ya !",
logCapture: "💀 Učči",
savedGameFound: "Urar yettwaskles. Ad d-iban?",
themeClassic: "Aqdim",
themeDesert: "Agadir",
themeNuit: "Timeddit",
themeGlass: "Zǧǧaǧ",
themeContrast: "Amgired",
themeModern: "Amaynut",
themeModernDark: "Amaynut qessiḥen",
themeKabylie: "Taqbaylit",
btnTheme: "Asentel",
btnSound: "Ṣṣut",
btnSettings: "Aseggem",
btnDragMode: "Asezger",
confirm: "Yahwa-yi",
cancel: "ALA",
defaultPlayer1: "Amyurar 1",
defaultPlayer2: "Amyurar 2",
defaultComputerName: "Aselkim",
defaultHumanName: "Amdan",
appTitle: "Tiddas - Urar",
chooseVersion: "Fren acu n tiddest ara turareḍ :",
TIDDESTTitle: "TIDDEST",
TIDDESTDesc: "Yerbeḥ win yeččan ileqqafen.",
bessifTitle: "Učči Bessif",
bessifDesc: "Am ilugan n TIDDEST, maca yerbeḥ win i wummi mmeččen ileqqafen.",
howToPlay: "Amek tebɣiḍ ad turareḍ ?",
playOnline: "Urar s internet",
playOnlineDesc: "Qqim ɣer teslaḍt d umeddakel ibaɛden ",
playAI: "Urar mgal aselkim",
playAIDesc: "Urar i yiman-ik",
playOffline: "Urar war internet",
playOfflineDesc: "Urar d umeddakul",
backToVersions: "Uɣal",
chooseAIDifficulty: "Fren aswir n uselkim",
difficultyEasy: "Aḥlawan",
difficultyMedium: "Alemmas",
difficultyHard: "Aquran",
difficultyImpossible: "Awessar",
difficultyEasyDesc: "Aselkim yetturar kan akka!",
difficultyMediumDesc: "Aselkim yetturar swaswa kan",
difficultyHardDesc: "Aselkim yewɛeṛ ad t-trebḥeḍ",
difficultyImpossibleDesc: "Aselkim yeẓra ayen ara txedmeḍ",
backToModes: "Uɣal",
playerSetup: "Aheggi n yimyurar",
playerNamesTitle: "Ismawen n yimyurar",
chooseYourColorTitle: "Tturareḍ s :",
colorLabelLocal: "Amyurar 1 yetturar s :",
psuSubtitle: "Kcem ismawen-nwen u fren ini-nwen",
colorDescBlack: "Yebdu d wis sin",
colorDescWhite: "Yebdu d amezwaru",
playerHumanName: "Isem n umdan :",
player1NameLabel: "Isem n umyurar 1 (Aberkan) :",
player2NameLabel: "Isem n umyurar 2 (Amellal) :",
yourNamePlaceholder: "Isem-ik",
player2Placeholder: "Amyurar 2",
yourColor: "Ini-k",
aiColor: "Ini n uselkim",
player1Color: "Aberkan (Amyurar 1)",
player2Color: "Amellal (Amyurar 2)",
playButton: "Urar",
gameVersion: "Tawsit:",
aiDifficultyDisplayLabel: "Aswir:",
ephemeralMill: "Tlata S Ya !",
ephemeralCaptureNormal: "Awi-d Wa !",
ephemeralCaptureBessif: "Ddem wa !",
ephemeralMovePhase: "Tallit n unaqel !",
newGame: "Aɣaram",
restartGame: "Ɛiwed",
undoMove: "Uɣal",
gameRulesTitle: "Ilugan n wurar",
rulesGeneral: "Ilugan s umata n Tiddas :",
rulesObjectiveStrong: "Iswi :",
rulesObjective: "Iswi amenzu, yal ma yetellet yiwen ileqqafen-is ad yemmečč yiwen uleqqaf n wexṣim, alamma yeǧǧa-as-d ala sin neɣ qqel, neɣ aḥbas-is iwakken ur izemmer ara ad inaqel. Di tewsit n Učči bessif, yerbeḥ win i wummi mmeččen ileqqafen-is.",
rulesPiecesStrong: "Ileqqafen :",
rulesPieces: "Yal amyurar yesɛa 10 yileqqafen. Amyurar <strong>(Amellal)</strong> yetturar d amezwaru.",
rulesPhasesStrong: "Talliyin n wurar :",
rulesPlacementPhaseStrong: "Tallit n usrusu :",
rulesPlacementPhase: "Imyuraren srusuyen s nnuba (yiwen/yiwen uleqqaf). Tallit-a tekfa mi rsen i 20 yileqqafen.",
rulesMovePhaseStrong: "Tallit n unaqel :",
rulesMovePhase: "Mi rsen yakk ileqqafen, imyuraren ad bdun ad ttenqalen ileqqafen ɣer texxamin yexlan yellan ɣer yidis yexlan.",
rulesMillStrong: "Atellet :",
rulesMill: "Asedukkel n <strong>tlata yileqqafen</strong> kan n yiwen yini (s teɣzi neɣ s tehri).",
rulesCaptureStrong: "Učči :",
rulesCapture: "Ma yesdukkel amyurar tlata yileqqafen, yezmer ad yečč aleqqaf n wexṣim-is.",
rulesCapturePlacementRestrictionStrong: "Yegdel ad tesdukkleḍ 3 deg usrusu :",
rulesCapturePlacementRestriction: "Yegdel ad tserseḍ aleqqaf i wakken ad tesdukkleḍ tlata. Daymi, ulac Učči deg tallit n usrusu. Učči yettili kan deg tallit n unaqel.",
rulesCaptureAllPiecesStrong: "Akk ileqqafen zemren ad mmeččen :",
rulesCaptureAllPieces: "Deg yakk tiwsiyin, <strong>akk ileqqafen zemren ad mmeččen</strong>, ula ma llan deg utellet.",
rulesForcedMoveStrong: "atellet s tmara:",
rulesForcedMove: "Deg tallit n unaqel, ma yella umyurar yezmer ad itellet, ilaq-as ad t-yexdem. Ma yella aṭas n yiberdan, ad yefren yiwen.",
rulesDifferences: "Amgired gar tewsiyin :",
rulesDifferencesIntro: "Yal tawsit tesɛa ilugan-is :",
rulesTIDDEST: "TIDDEST :",
rulesTIDDESTMovesStrong: "Anaqel :",
rulesTIDDESTMoves: "Kan s teɣzi neɣ s tehri.",
rulesTIDDESTCapturesStrong: "Učči :",
rulesTIDDESTCaptures: "Win yesdukklen tlata ad yefren aleqqaf n wexṣim-is ara yečč.",
rulesTIDDESTWinStrong: "Arbaḥ :",
rulesTIDDESTWin: "yerbeḥ win yeččan.",
rulesTIDDESTNoForcedMoveStrong: "Ulac atellet s tmara :",
rulesTIDDESTNoForcedMove: "Ilugan n Učči Bessif ur ttilin ara.",
rulesBessif: "Učči Bessif :",
rulesBessifCombines: "Tesdukkel ilugan n <strong>TIDDEST</strong> d umenzay n <strong>A werbaḥ s wexṣar</strong>.",
rulesBessifMovesStrong: "Anaqel :",
rulesBessifMoves: "Kan s teɣzi neɣ s tehri.",
rulesBessifInverseWinStrong: "Arbaḥ s wexṣar :",
rulesBessifInverseWin: "Amyurar ad irebḥ ma yella ggran-as-d ala sin (2) yileqqafen, Neɣ ma yella axṣim-is ur yezmir ara ad inaqel, u d netta (win i d-yuraren) i yesɛan drus yileqqafen.",
rulesBessifOpponentChoosesStrong: "Axṣim ad yefren :",
rulesBessifOpponentChooses: "Ma yella tetelteḍ, d <strong>axṣim-ik</strong> ara d-ifernen aleqqaf-is ara teččeḍ.",
rulesBessifForcedMoveStrong: "atellet s tmara :",
rulesBessifForcedMove: "Ur d ak d-iṣaḥ ara ad tneqleḍ aleqqaf ɣer wanda ur tettetelliteḍ ara ma yella tzmereḍ ad tetelteḍ.",
footerHeritage: "Idles n yimaziɣen • Urar Aqbuṛ n Yeqbayliyen",
footerCreator: "Iga-t",
congratulations: "Ayuuuuz!",
winnerMessage: "i yerbeḥen!",
replay: "Ɛiwed urar",
statusPlayerTurn: "D nnuba n",
statusChooseCapture: "fren aleqqaf n",
statusToCapture: "ad teččeḍ.",
statusChooseSacrifice: "ilaq-as ad yefren aleqqaf-is ara yefk.",
statusPlacementPhase: "Asrusu : D nnuba n",
statusMovePhase: "Anaqel : D nnuba n",
statusGameOver: "Yekfa wurar !",
statusAlreadyOccupied: "taxxamt-a teččur !",
statusNoPiecesToPlace: "Ur k-d-qqimen ara yileqqafen !",
statusPlacementAlignForbidden: "D awezɣi ad tesdukleḍ 3 deg usrusu !",
statusYourPiecesTurn: "D nnuba n yileqqafen-ik !",
statusSelectYourPiece: "Fren yiwen uleqqaf-ik.",
statusInvalidMove: "Ur d ak d-iṣaḥ ara.",
statusMustMakeMill: "Ilaq-ak ad tesdukleḍ tlata ma yella tzmereḍ !",
statusChooseOwnPieceToSacrifice: "Ilaq-ak ad teferneḍ yiwen uleqqaf-IK ara tefkeḍ !",
statusChooseOpponentPieceToCapture: "Ilaq-ak ad teferneḍ aleqqaf n WEXṢIM-IK !",
aiCannotMove: "Aselkim yeḥbes, yexṣer !",
statusConsecutiveBlocked: "Aleqqaf-a inaqel 3 tikkal tin ɣef tin! urar wayed.",
youLost: "Txesreḍ 😭",
aiWinsMessage: "i yerbeḥen !",
surrenderConfirm: "Tebɣiḍ ad tefkeḍ Mayna?",
surrenderMessage: "yefka Mayna !",
stats: "Igemmaḍ",
statsTitle: "Igemmaḍ",
resetStats: "Sfeḍ",
exportStats: "Ssufeɣ-d",
close: "Mdel",
replayTitle: "aɛiwed",
replayLast: "aɛiwed",
guidedMode: "Awelleh",
speed: "aɣiwel",
installHelpTitle: "Areṣṣi n wurar",
installHelpBody: "awelleh : iPhone/iPad «zuzer» → «Deg ​usebtar agejdan». Android/Chrome: «Areṣṣi» ma yella.",
toastInstalled: "✅ urar yettwareṣṣa.",
toastInstallUnavailable: "ℹ️ Areṣṣi ur yelli ara.",
toastReplayReady: "⏯️ Aɛiwed yewjed.",
toastNoReplay: "Ulac aɛiwed.",
toastStatsReset: "Agemmuḍ ittwasfeḍ.",
toastExported: "Asuffeɣ yekfa.",
toastSWReady: "✅ War-internet ihegga.",
toastSWUpdate: "🔄 Aleqqem yewjed.",
boardAria: "Taslaḍt n wurar",
cellLabel: "Taxxamt",
cellEmpty: "texla",
gamesPlayedLabel: "timlilit",
winsLabel: "timliliyin yettwarebḥen",
lossesLabel: "Timliliyin yettwaxesren",
winRateLabel: "Agemmuḍ n rbeḥ",
streakLabel: "Agraw",
bestStreakLabel: "Agraw ifazen",
movesLabel: "Ambiwel",
capturesLabel: "Učči",
millsLabel: "Atellet",
durationLabel: "Akud",
levelLabel: "Aswir",
xpLabel: "XP",
lastGameLabel: "Urar aneggaru",
btnTheme: "Asentel",
btnSound: "Ṣṣut",
btnSettings: "Aseggem",
btnDragMode: "Ajuṛṛu",
themeContrast: "Amgired",
themeModern: "Amaynut",
themeModernDark: "Amaynut qessiḥen",
themeKabylie: "Taqbaylit",
// NEW: hardcoded UI elements not previously translated
spectatorBadgeTxt: "👁 Anezzeh",
btnResume: "Kemmel",
btnDiscard: "Ala",
ariaRulesClose: "Mdel",
ariaReplayFirst: "Bdu",
ariaReplayPrev: "Yezrin",
ariaReplayPlay: "Urar/Ḥbes",
ariaReplayNext: "wayeḍ",
ariaReplayLast: "taggara",
ariaSettingsFab: "Aseggem",
ariaInstallBtn: "Areṣṣi n wurar",
ariaModeGuide: "Awelleh",
aboutTitle: "Ɣef wurar-a",
aboutIntro: "Leqdic-ayi ɣef wurar-ayi, illa-d i wakken ad nesseḥbiber ɣef yiwen ugerruj d-ǧǧan lejdud i yidles n yiqbayliyen.",
aboutP1: "<em>Tiddas</em>, asget n <em>Tiddest</em>, mačči d urar kan. D taẓuri n tmusni, d akayad n tiḥḥerci, yal aqeddim s wazal-is. Zik yal taslaḍt n tɛessast neɣ n tejmaɛt di tudrin n yiqbaliyen, ad tafeḍ tettwajerred tfelwit n Tiddest n 25 texxamin, zzin-d fell-as Qeccic Meccuc, ttemqabalen fel-as sin, tturaren s <em>ileqqafen</em>.",
aboutP2: "Tasuta-w ahat ad tili gar tneggura i yesnen urar-a s wudem-is aqbuṛ : ɣef teslaḍt n taddert. Ass-a, tasnasit-a tefka-yas tudert tamaynut,  s rriḥa n wurar-nni n zik.",
aboutP3: "Tiddas d urar yesɛan aṭṭas n useḥseb, yettemcabin i Ddamma neɣ i Umaryun uṛumi. <strong>Sin yimyuraren, 10 yileqqafen i yal yiwen.</strong> Iswi: asedukkel n tlata yileqqafen iwakken ad teččeḍ wid n uxṣim, u ad tḥadreḍ iman-ik seg tfextin-is..",
aboutVariantClassic: "Tawsit tamagnut neɣ taqbuṛt.",
aboutVariantBessif: "D win i wumi kkfan ileqqafen-is, i yrebḥen.",
aboutP4: "S leqdic-a, nessaram d akken tisutiwin d-iteddun ad urarent Tiddas, w ad zuxxent yes d akken d urar n lejdud nsen.",
aboutQuoteTrans: "Di ddunit ma yella tettuneḥca-y-ak , xas beddel abrid.",
aboutBtnLabel: "Awal fell-as",
avgDuration: "Akud alemmas",
winnerLabel: "Win irbeḥen",
actionsPerGameLabel: "Tikkal mbawelen ileqqafen i temlilit",
modeAI: "IA",
modeLocal: "Ameddakel",
modeSpectator: "Anezzeh",
modeLabel: "Mgal",
noStatsYet: "Ulac igemmaḍ tura. Urar timlilit !",
replayMoveLabel: "Tikkelt",
ariaReplayExit: "Mdel",
ariaReplayInfo: "Talɣut",
woSubDefeat: "— Taggara n wurar —",
woSubVictory: "— Rbeḥ —",

onlineTitle: "Urar d umeddakul s lebɛid",
onlineProfileTitle: "Amaɣnu",
onlineProfileDesc: "Isem-ik ad d-iban i umeddakul-ik",
onlineYourNameLabel: "Isem-ik",
onlineNameHint: "Isem-a yettwaḥraz .",
onlineRoomTitle: "Taslaḍt",
onlineRoomDesc: "Rnu tasarut neɣ kecem s yiwet yellan yakan",
onlineSubtitle: "Bnu taslaḍt, teceyyeɛeḍ-as tasarut, neɣ rnu ɣer tin umeddakul-ik.",
onlineCreate: "bnu taslaḍt",
onlineCreateDesc: "Ceyyeɛ tasarut",
onlineJoin: "Kcem",
onlineJoinDesc: "Sekcem tasarut",
onlineRoomCode: "Tasarut ",
onlineConnect: "Tuqqna",
onlineConnectDesc: "qqim ɣer teslaḍt",
onlineStatusTitle: "Addad",
onlineShare: "awi tasarut-a :",
onlineStart: "Bdu urar",
onlineStartDesc: "Qqimen-d i 2 yimyurar",
onlineNamePlaceholder: "Amedya: Akli",
onlineCopyCodeAria: "Glu tasarut",
onlineChooseAction: "Fren: bnu neɣ qqim ɣer teslaḍt.",
onlineCodeCopied: "Tasarut tettwanqal ✅",
onlineStatusTwoPlayersHost: "2 yimyuraren qqimen-d. Tzemreḍ ad tebduḍ urar.",
onlineStatusTwoPlayersGuest: "2 yimyuraren qqimen-d, arǧu ad ibdu urar…",
onlineStatusCreatedHost: "taslaḍt tettwabna. Ceyyeɛ tasarut, rǧu ameddakul-ik…",
onlineStatusConnecting: "Tuqqna…",
onlineCreatingRoom: "Asnulfu n teslaḍt {tasarut}…",
onlineCodeAlreadyUsed: "Tasarut tettwaseqdec yakan. Ԑreḍ tayeḍ.",
onlineCreatedShare: "taslaḍt yettwabna. Ceyyeɛ tasarut : {code}",
onlineConnectingRoom: "Tuqqna ɣer teslaḍt {tasarut}…",
onlineRoomNotFound: "Ulac taslaḍt-ayi. senqed tasarut-ik.",
onlineGameFinished: "Yekkfa Wurar.",
onlineRoomFull: "Asalon yeččur (2 yimyuraren).",
onlineNetworkError: "Tuccḍa n uzeṭṭa Back4App. Selken izerfan (CLP) akked tuqqna-inek.",
onlineParseNotReady: "Back4App ur yettuseɣwer ara neɣ Parse ur yuli ara.",
onlineSendError: "Tuccḍa deg tuznit. Senqed tuqqna Back4App.",
onlineNoRoomActive: "Ulac taslaḍt iheyyan.",
onlineOnlyHostStart: "Ala win yebnan taslaḍt (host) i yezmeren ad yebdu urar.",
onlineBack4AppNotReady: "Back4App ur yewjid ara.",
onlineWaitTwoPlayers: "Rǧu alamma qqnen-d i 2 yimyuraren.",
onlineStartOK: "yebda wurar ✅",
onlineStartErrorPrefix: "Tuccḍa n beddu : {msg}",
onlineErrorPrefix: "Tuccḍa : {msg}",
onlineRecentRooms: "tislaḍin n yakan",
onlineRejoinLast: "Uɣal ɣer teslaḍ-t taneggarut",
onlineRejoinLastDesc: "Tuqqna s tazzla",
notYourTurn: "Mačči d nnuba-k.",
onlineInviteBtn: "📤 Ɛiwet ameddakel",
onlinePanelCode: "Tasarut kan",
onlinePanelLink: "Aseɣwen n wurar",
onlinePanelShare: "Bḍu",
onlineAutoJoinDetected: "Teslaḍt tettwaf : {code}",
onlineAutoJoinWaiting: "Kcem isem-ik i wakken ad tedduḍ",
onlineJoinParam: "Tuqqna yidir ɣer {code}…",
onlineRecentEmpty: "Ulac tislaḍin",
onlineChipVs: "mgal",
onlineChipPending: "Yettṛaǧu",
onlineCodePreview: "Tamsart-ik :",
onlineCodeConfirm: "Asnulfu n teslaḍt ?",
onlineLinkCopied: "Aseɣwen yettwanqal ✅",
onlineCopyLinkAria: "Nqel aseɣwen",
onlineShareLinkAria: "Bḍu",
onlineShareText: "Qqim ɣer teslaḍt-iw n Tiddas :",
statsSectionGlobal: "Agemmuḍ s umata",
statsSectionEfficiency: "Tawuri",
statsSectionByMode: "S urar",
statsSectionLastGame: "Timlilit taneggarut",
statsBestWinTime: "Irebḥ ameqqran",
statsCaptPerGame: "Učči / timlilit",
statsMillsPerGame: "Atellet / timlilit",
statsAvgDurPerMode: "Akud alemmas",
statsStreakCurrent: "Angal tura",
statsStreakBest: "Angal ameqqran",
statsByDifficulty: "S uswir",
statsOnlineOpponents: "Ixṣimawen",
statsVariantLabel: "Tawsit",
statsActionsCount: "Tikkal",
statsLevelProgress: "Aswir d-iteddun",
statsOnlineMode: "S Internet",
statsDraws: "Imsegginen",
},
en: {
backToMenu: "Menu",
onlineRematchHint: "Rematch",
onlineReadyRematch: "I'm ready",
onlineReadyRematchOn: "Ready ✅",
onlineRematchNote: "Colors alternate every rematch.",
onlineRematchReadyToast: "Rematch: ready. Waiting for the other player…",
onlineRematchGuestInfo: "Game finished. Tap “I'm ready” for a rematch.",
onlineRematchWaitReady: "Waiting for players to be ready…",
onlineRematchCanStart: "Everyone is ready ✅",
onlineRematchStart: "Start rematch",
onlineRematchStartDesc: "When both players are ready",
onlineStatusPlayingHost: "Game in progress. Good luck!",
onlineStatusPlayingGuest: "Game in progress. Good luck!",
onlineGameFinished: "This game is finished.",
statsSectionActivity: "Activity",
statsPlacementsPerGame: "Placements / game",
statsMovesPerGame: "Moves / game",
statsActionsPerGame: "Turns / game",
statsOnlineTopOpponent: "Top opponent",
statsActionsCount: "Turns",
statsPlacementsCount: "Placements",
statsMovesCount: "Moves",
resetStatsConfirm: "Reset statistics?",
toastStatsReset: "Stats reset.",
toastExported: "Export created.",
noStatsYet: "No stats yet. Start a game!",
statsSectionGlobal: "Overview",
gamesPlayedLabel: "Games",
durationLabel: "Total time",
avgDuration: "Avg. time / game",
statsBestWinTime: "Best win",
actionsPerGameLabel: "Turns / game",
statsCaptPerGame: "Captures / game",
statsMillsPerGame: "Mills / game",
levelLabel: "Level",
statsLevelProgress: "Next level",
statsSectionByMode: "By mode",
modeAI: "AI",
modeLocal: "Local",
statsOnlineMode: "Online",
modeSpectator: "Spectator",
winRateLabel: "Win rate",
winsLabel: "Wins",
lossesLabel: "Losses",
drawsLabel: "Draws",
statsStreakCurrent: "Current streak",
statsStreakBest: "Best streak",
statsAvgDurPerMode: "Avg. time",
statsByDifficulty: "By difficulty",
statsSectionLastGame: "Last game",
modeLabel: "Mode",
statsVariantLabel: "Variant",
winnerLabel: "Winner",
capturesLabel: "Captures",
millsLabel: "Mills",
player1ColorShort: "Black",
player2ColorShort: "White",
onlineStatusCreatedHost: "Room created. Share the code and wait for an opponent…",
onlineStatusConnecting: "Connecting…",
onlineStatusTwoPlayersHost: "2 players connected. You can start the game.",
onlineStatusTwoPlayersGuest: "2 players connected. Waiting for the host to start…",
onlineChooseAction: "Choose: create or join a room.",

playSpectator: "Spectator Mode",
installApp: "Install",
playSpectatorDesc: "Watch two AIs face off",
spectatorSpeed: "Speed:",
speedSlow: "Slow",
speedNormal: "Normal",
speedFast: "Fast",
moveHistoryTitle: "Move History",
logPlace: "places at",
logMove: "from",
logMoveTo: "→",
logMill: "⚡  Tlata S Ya",
logCapture: "💀 Capture at",
savedGameFound: "Saved game found. Resume?",
themeClassic: "Classic",
themeDesert: "Desert",
themeNuit: "Night",
themeGlass: "Glass",
themeContrast: "Contrast",
themeModern: "Modern",
themeModernDark: "Modern Dark",
themeKabylie: "Kabylie",
surrender: "Surrender",
confirm: "Confirm",
cancel: "Cancel",
defaultPlayer1: "Player 1",
defaultPlayer2: "Player 2",
defaultComputerName: "Computer",
defaultHumanName: "Human",
appTitle: "Tiddas - Game",
chooseVersion: "Choose game version:",
TIDDESTTitle: "TIDDEST",
TIDDESTDesc: "No captures during placement. Forming 3 in a row during placement is forbidden. Moves and captures are horizontal/vertical only. Standard victory.",
bessifTitle: "Učči Bessif",
bessifDesc: "Same rules as TIDDEST. Reversed victory: win by losing all your pieces. When you form a mill, your opponent chooses one of their pieces to be captured.",
howToPlay: "How would you like to play?",
playOnline: "Play Online",
playOnlineDesc: "Create or join a match",
playAI: "Play vs Computer",
playAIDesc: "Challenge an artificial intelligence",
playOffline: "Play Offline",
playOfflineDesc: "Local game on your device",
backToVersions: "Back",
chooseAIDifficulty: "Choose AI difficulty",
difficultyEasy: "Easy",
difficultyMedium: "Medium",
difficultyHard: "Hard",
difficultyImpossible: "Expert",
difficultyEasyDesc: "The computer plays randomly",
difficultyMediumDesc: "The computer is a decent opponent",
difficultyHardDesc: "The computer is a true strategist",
difficultyImpossibleDesc: "The AI anticipates your every move",
backToModes: "Back",
playerSetup: "Player Setup",
playerNamesTitle: "Player Names",
chooseYourColorTitle: "You play with:",
colorLabelLocal: "Player 1 plays with:",
psuSubtitle: "Enter your names and choose your side",
colorDescBlack: "Goes second",
colorDescWhite: "Goes first",
playerHumanName: "Human's Name:",
player1NameLabel: "Player 1 Name (Black):",
player2NameLabel: "Player 2 Name (White):",
yourNamePlaceholder: "Your Name",
player2Placeholder: "Player 2",
yourColor: "Your color",
aiColor: "AI color",
player1Color: "Black (Player 1)",
player2Color: "White (Player 2)",
playButton: "Play",
gameVersion: "Version:",
aiDifficultyDisplayLabel: "AI Difficulty:",
ephemeralMill: "Tlata S Ya!",
ephemeralCaptureNormal: "Awi-d Wa!",
ephemeralCaptureBessif: "Ddem Wa!",
ephemeralMovePhase: "Movement Phase!",
newGame: "Home",
restartGame: "Restart",
undoMove: "Undo",
gameRulesTitle: "Game Rules",
rulesGeneral: "General Rules of Tiddas (Common to all variants):",
rulesObjectiveStrong: "Objective:",
rulesObjective: "The main goal is to reduce your opponent's pieces to fewer than three, or to block them so they can no longer make valid moves. For the Učči bessif TIDDEST variant, the objective is reversed: the player wins if their own pieces are reduced to fewer than three.",
rulesPiecesStrong: "Pieces:",
rulesPieces: "Each player has 10 pieces (called \"stones\"). Player 2 (White) always goes first.",
rulesPhasesStrong: "Game Phases:",
rulesPlacementPhaseStrong: "Placement Phase:",
rulesPlacementPhase: "Players take turns placing one of their pieces on any empty cell of the board. This phase continues until all 20 pieces (10 per player) are placed.",
rulesMovePhaseStrong: "Movement Phase:",
rulesMovePhase: "Once all pieces are placed, players take turns moving one of their pieces one cell at a time to an adjacent empty cell (horizontally or vertically).",
rulesMillStrong: "Mill (Alignment):",
rulesMill: "Forming an alignment of <strong>exactly 3 pieces</strong> of your color (horizontally or vertically). <strong>Diagonal alignments are not valid mills.</strong>",
rulesCaptureStrong: "Capture:",
rulesCapture: "When a player forms a mill (3 pieces horizontally or vertically), they may \"eat\" (capture) one of the opponent's pieces.",
rulesCapturePlacementRestrictionStrong: "3-alignment forbidden during placement:",
rulesCapturePlacementRestriction: "It is forbidden to place a piece in a way that forms a mill of 3 or more pieces. Therefore, <strong>no captures are possible during the placement phase</strong>. Captures are only possible during the movement phase.",
rulesCaptureAllPiecesStrong: "All pieces can be captured:",
rulesCaptureAllPieces: "In all variants of this game, <strong>all pieces can be captured</strong>, even if they are part of a mill. There are no \"protected\" pieces.",
rulesForcedMoveStrong: "Forced mill move rule:",
rulesForcedMove: "During the movement phase, if a player can form a mill with one of their pieces, they are <strong>required</strong> to do so. If multiple moves allow a mill, the player may choose one.",
rulesDifferences: "Differences between variants:",
rulesDifferencesIntro: "The basic rules apply, but each variant introduces important specifics:",
rulesTIDDEST: "TIDDEST:",
rulesTIDDESTMovesStrong: "Moves:",
rulesTIDDESTMoves: "Horizontal/vertical only. Diagonal moves are forbidden.",
rulesTIDDESTCapturesStrong: "Captures:",
rulesTIDDESTCaptures: "The player who forms the mill chooses which opponent piece to capture.",
rulesTIDDESTWinStrong: "Victory:",
rulesTIDDESTWin: "Standard.",
rulesTIDDESTNoForcedMoveStrong: "No forced mill move:",
rulesTIDDESTNoForcedMove: "The forced mill move rule does not apply.",
rulesBessif: "Učči Bessif:",
rulesBessifCombines: "Combines the rules of <strong>TIDDEST</strong> with the principle of <strong>reversed victory</strong>.",
rulesBessifMovesStrong: "Moves:",
rulesBessifMoves: "Horizontal/vertical only.",
rulesBessifInverseWinStrong: "Reversed Victory:",
rulesBessifInverseWin: "The player wins if their own pieces are reduced to fewer than three (i.e. 0, 1 or 2 pieces), OR if their opponent is blocked and the current player has fewer pieces on the board than the opponent.",
rulesBessifOpponentChoosesStrong: "Choosing the piece to capture:",
rulesBessifOpponentChooses: "When you form a mill, it is your <strong>opponent</strong> who must choose one of their own pieces for you to capture.",
rulesBessifForcedMoveStrong: "Forced move to form a mill:",
rulesBessifForcedMove: "The forced mill move rule applies.",
footerHeritage: "Amazigh Cultural Heritage • Traditional Kabyle Game",
footerCreator: "Created by",
congratulations: "Congratulations!",
winnerMessage: "wins!",
replay: "Play again",
statusPlayerTurn: "It's",
statusChooseCapture: "choose a piece from",
statusToCapture: "to capture.",
statusChooseSacrifice: "must choose one of their pieces to sacrifice.",
statusPlacementPhase: "Placement phase: It's",
statusMovePhase: "Movement phase: It's",
statusGameOver: "Game over!",
statusAlreadyOccupied: "This cell is already occupied!",
statusNoPiecesToPlace: "You have no more pieces to place!",
statusPlacementAlignForbidden: "Alignment of 3 forbidden during placement!",
statusYourPiecesTurn: "It's your pieces' turn!",
statusSelectYourPiece: "Please select one of your pieces.",
statusInvalidMove: "Invalid move.",
statusMustMakeMill: "You must form a mill if possible!",
statusChooseOwnPieceToSacrifice: "You must choose one of YOUR pieces to sacrifice!",
statusChooseOpponentPieceToCapture: "You must choose an OPPONENT piece to capture!",
aiCannotMove: "The computer cannot move and loses the game!",
statusConsecutiveBlocked: "This piece has played 3 times in a row! Play another piece.",
youLost: "You lost 😭",
aiWinsMessage: "wins!",
surrenderConfirm: "Are you sure you want to surrender?",
surrenderMessage: "has surrendered!",
stats: "Stats",
statsTitle: "Statistics",
resetStats: "Reset",
exportStats: "Export",
close: "Close",
replayTitle: "Replay",
replayLast: "Replay",
guidedMode: "Guided",
speed: "Speed",
installHelpTitle: "Install the app",
installHelpBody: "Tip: on iPhone/iPad, use \"Share\" → \"Add to Home Screen\". On Android/Chrome, the \"Install\" button appears if the app is eligible.",
toastInstalled: "✅ App installed.",
toastInstallUnavailable: "ℹ️ Installation not available on this browser.",
toastReplayReady: "⏯️ Replay ready.",
toastNoReplay: "No game to replay.",
toastStatsReset: "Stats reset.",
toastExported: "Export generated.",
toastSWReady: "✅ Offline mode ready.",
toastSWUpdate: "🔄 Update available: reload the app.",
boardAria: "Game board",
cellLabel: "Cell",
cellEmpty: "empty",
gamesPlayedLabel: "Games",
winsLabel: "Wins",
lossesLabel: "Losses",
winRateLabel: "Win rate",
streakLabel: "Streak",
bestStreakLabel: "Best streak",
movesLabel: "Moves",
capturesLabel: "Captures",
millsLabel: "Mills",
durationLabel: "Duration",
levelLabel: "Level",
xpLabel: "XP",
lastGameLabel: "Last game",
btnTheme: "Theme",
btnSound: "Sound",
btnSettings: "Settings",
btnDragMode: "Drag",
spectatorBadgeTxt: "👁 Spectator",
btnResume: "Resume",
btnDiscard: "No",
ariaRulesClose: "Close",
ariaReplayFirst: "First",
ariaReplayPrev: "Previous",
ariaReplayPlay: "Play/Pause",
ariaReplayNext: "Next",
ariaReplayLast: "Last",
ariaSettingsFab: "Settings",
ariaInstallBtn: "Install app",
ariaModeGuide: "Guided mode",
aboutTitle: "About the app",
aboutIntro: "This app was born from a simple desire: to <strong>preserve and pass on</strong> a treasure of our Kabyle heritage.",
aboutP1: "<em>Tiddas</em>, plural of <em>Tiddest</em>, is far more than a game. It is an art of reasoning, an exercise in strategy, a space for reflection where every move counts. Once carved into the concrete benches of the <em>taɛessast</em> of our villages, it brought together children, adults and elders around a 25-cell grid and simple stones called <em>ileqqafen</em>.",
aboutP2: "My generation is likely among the last to have known this game in its traditional form\u00a0— drawn in chalk, carved in stone, or sketched in flint. Today, this app gives it a new life, without betraying its spirit.",
aboutP3: "Tiddas is an abstract combinatorial strategy game, akin to draughts and Roman tic-tac-toe. <strong>Two players, ten pieces each.</strong> The goal\u00a0: form a line of three pieces to capture the opponent's, while avoiding their traps.",
aboutVariantClassic: "The classic version.",
aboutVariantBessif: "Losing all your pieces becomes… the key to victory.",
aboutP4: "Through this app, we hope to allow everyone to rediscover this ancient game, pass it on to new generations, and perpetuate this strategic heritage.",
aboutQuoteTrans: "Life is like Tiddest\u00a0: if you're cornered, get up.",
aboutBtnLabel: "About",
avgDuration: "Average duration",
winnerLabel: "Winner",
actionsPerGameLabel: "Moves / game",
modeAI: "AI",
modeLocal: "Local",
modeSpectator: "Spectator",
modeLabel: "Mode",
noStatsYet: "No stats yet. Play a game!",
replayMoveLabel: "Move",
ariaReplayExit: "Close",
ariaReplayInfo: "Info",
woSubDefeat: "— Game over —",
woSubVictory: "— Victory —",

onlineTitle: "Online multiplayer",
onlineProfileTitle: "Profile",
onlineProfileDesc: "Your nickname will be shown to your opponent",
onlineYourNameLabel: "Your name",
onlineNameHint: "This name is saved on your device.",
onlineRoomTitle: "Room",
onlineRoomDesc: "Create a code or join an existing one",
onlineSubtitle: "Create a room and share the code, or join an existing one.",
onlineCreate: "Create room",
onlineCreateDesc: "Generates a code",
onlineJoin: "Join",
onlineJoinDesc: "Enter a code",
onlineRoomCode: "Room code",
onlineConnect: "Connect",
onlineConnectDesc: "Connect to room",
onlineStatusTitle: "Status",
onlineShare: "Share this code:",
onlineStart: "Start match",
onlineStartDesc: "When 2 players are connected",
onlineNotConfigured: "Online server is not configured. See README to set the URL.",
onlineNamePlaceholder: "e.g., Boussad",
onlineCopyCodeAria: "Copy the code",
onlineChooseAction: "Choose: create or join a room.",
onlineCodeCopied: "Code copied ✅",
onlineStatusTwoPlayersHost: "2 players connected. You can start the game.",
onlineStatusTwoPlayersGuest: "2 players connected. Waiting for the host to start…",
onlineStatusCreatedHost: "Room created. Share the code and wait for an opponent…",
onlineStatusConnecting: "Connecting…",
onlineCreatingRoom: "Creating room {code}…",
onlineCodeAlreadyUsed: "Code already used. Try another code.",
onlineCreatedShare: "Room created. Share the code: {code}",
onlineConnectingRoom: "Connecting to room {code}…",
onlineRoomNotFound: "Room not found. Check the code.",
onlineGameFinished: "This game is finished.",
onlineRoomFull: "Room is full (2 players).",
onlineNetworkError: "Back4App network error. Check permissions (CLP) and your connection.",
onlineParseNotReady: "Back4App isn't configured or Parse SDK isn't loaded.",
onlineSendError: "Send error. Check your Back4App connection.",
onlineNoRoomActive: "No active room.",
onlineOnlyHostStart: "Only the host can start the game.",
onlineBack4AppNotReady: "Back4App isn't ready.",
onlineWaitTwoPlayers: "Wait until 2 players are connected.",
onlineStartOK: "Game started ✅",
onlineStartErrorPrefix: "Start error: {msg}",
onlineErrorPrefix: "Error: {msg}",
onlineRecentRooms: "Recent rooms",
onlineRejoinLast: "Rejoin last room",
onlineRejoinLastDesc: "Quick reconnect",
notYourTurn: "Not your turn.",
onlineInviteBtn: "📤 Invite a friend",
onlinePanelCode: "Code only",
onlinePanelLink: "Game link",
onlinePanelShare: "Share",
onlineAutoJoinDetected: "Room detected: {code}",
onlineAutoJoinWaiting: "Enter your name to join",
onlineJoinParam: "Auto-connecting to {code}…",
onlineRecentEmpty: "No recent rooms",
onlineChipVs: "vs",
onlineChipPending: "Waiting",
onlineCodePreview: "Your code:",
onlineCodeConfirm: "Create this room?",
onlineLinkCopied: "Link copied ✅",
onlineCopyLinkAria: "Copy link",
onlineShareLinkAria: "Share",
onlineShareText: "Join my Tiddas room:",
statsSectionGlobal: "Overview",
statsSectionEfficiency: "Efficiency",
statsSectionByMode: "By mode",
statsSectionLastGame: "Last game",
statsBestWinTime: "Best win",
statsCaptPerGame: "Captures / game",
statsMillsPerGame: "Mills / game",
statsAvgDurPerMode: "Avg duration",
statsStreakCurrent: "Current streak",
statsStreakBest: "Best streak",
statsByDifficulty: "By difficulty",
statsOnlineOpponents: "Opponents",
statsVariantLabel: "Variant",
statsActionsCount: "Moves",
statsLevelProgress: "Next level",
statsOnlineMode: "Online",
statsDraws: "Draws",
}
};
// --- DEEP COPY HELPER ---
function deepCopy(obj) {
return JSON.parse(JSON.stringify(obj));
}

// --- MODAL FUNCTIONS ---
function showConfirmationModal(titleKey, messageKey, onConfirm) {
modalTitle.textContent = translations[currentLanguage][titleKey];
modalMessage.textContent = translations[currentLanguage][messageKey];
modalConfirmBtn.textContent = translations[currentLanguage]['confirm'];
modalCancelBtn.textContent = translations[currentLanguage]['cancel'];
onConfirmCallback = onConfirm;
confirmationModal.classList.add('active');
}

function hideConfirmationModal() {
confirmationModal.classList.remove('active');
onConfirmCallback = null;
}

function showRulesModal() {
document.querySelectorAll('.rules-content').forEach(el => el.style.display = 'none');
const currentRules = document.querySelector(`.rules-content[lang="${currentLanguage}"]`);
if (currentRules) {
currentRules.style.display = 'block';
}
rulesModal.classList.add('active');
}

function hideRulesModal() {
rulesModal.classList.remove('active');
}

function showAboutModal() {
aboutModal.classList.add('active');
document.body.style.overflow = 'hidden';
}
function hideAboutModal() {
aboutModal.classList.remove('active');
document.body.style.overflow = '';
}

// --- DISPLAY AND UI FUNCTIONS ---
function updateLanguage(lang) {
const oldLang = currentLanguage;
currentLanguage = lang;
document.documentElement.lang = lang;

const defaultNames = [
translations[oldLang]?.defaultPlayer1,
translations[oldLang]?.defaultPlayer2,
translations[oldLang]?.defaultHumanName,
translations[oldLang]?.defaultComputerName
].filter(Boolean);

if (defaultNames.includes(player1Name)) {
if (gameMode === 'ai') {
player1Name = humanPlayerId === 1 ? translations[lang].defaultHumanName: translations[lang].defaultComputerName;
} else {
player1Name = translations[lang].defaultPlayer1;
}
}
if (defaultNames.includes(player2Name)) {
if (gameMode === 'ai') {
player2Name = humanPlayerId === 2 ? translations[lang].defaultHumanName: translations[lang].defaultComputerName;
} else {
player2Name = translations[lang].defaultPlayer2;
}
}

document.querySelectorAll('[data-i18n]').forEach(el => {
const key = el.dataset.i18n;
const translation = translations[lang][key];
if (translation !== undefined) {
let target = el.querySelector('span:not([data-i18n])') || el;
setSafeHTML(target, translation);
}
});
document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
el.placeholder = translations[lang][el.dataset.i18nPlaceholder] || el.dataset.i18nPlaceholder;
});
document.title = translations[lang].appTitle;

if (state && !state.winner) {
updateStatus();
updatePlayerNamesDisplay();
updateGameInfoDisplay();
}
updateColorOptionSelection(humanPlayerId);
if (rulesModal.classList.contains('active')) {
showRulesModal();
}
// Update hardcoded UI elements not covered by data-i18n
_applyHardcodedI18n(lang);

// Refresh dynamic modals if open (language switch)
try {
  const sm = document.getElementById('stats-modal');
  if (sm && sm.classList.contains('active') && typeof renderStats === 'function') renderStats();
} catch(_) {}
try {
  const rm = document.getElementById('replay-modal');
  if (rm && rm.classList.contains('active') && typeof updateReplayMeta === 'function') updateReplayMeta();
} catch(_) {}

}

function _applyHardcodedI18n(lang) {
const tr = translations[lang] || translations['fr'];
// Spectator badge
const badge = document.getElementById('spectator-badge');
if (badge) badge.textContent = tr.spectatorBadgeTxt || '👁 Mode Spectateur';
// Save notification buttons
const btnResume = document.getElementById('btn-resume');
if (btnResume) btnResume.textContent = tr.btnResume || 'Reprendre';
const btnDiscard = document.getElementById('btn-discard');
if (btnDiscard) btnDiscard.textContent = tr.btnDiscard || 'Non';
// Rules close button aria/title
const rulesCloseBtn2 = document.getElementById('rules-close-btn');
if (rulesCloseBtn2) {
rulesCloseBtn2.setAttribute('aria-label', tr.ariaRulesClose || 'Fermer');
rulesCloseBtn2.title = tr.ariaRulesClose || 'Fermer';
}
// Replay controls aria-labels
const replayMap = {
'replay-first-btn': tr.ariaReplayFirst || 'Début',
'replay-prev-btn': tr.ariaReplayPrev || 'Précédent',
'replay-play-btn': tr.ariaReplayPlay || 'Lecture/Pause',
'replay-next-btn': tr.ariaReplayNext || 'Suivant',
'replay-last-btn': tr.ariaReplayLast || 'Fin'
};
for (const [id, label] of Object.entries(replayMap)) {
const el = document.getElementById(id);
if (el) { el.setAttribute('aria-label', label); el.title = label; }
}

// Replay dock extra buttons
const rExit = document.getElementById('replay-exit-btn');
if (rExit) {
  const lbl = tr.ariaReplayExit || 'Fermer';
  rExit.setAttribute('aria-label', lbl);
  rExit.title = lbl;
}
const rInfo = document.getElementById('replay-info-btn');
if (rInfo) {
  const lbl = tr.ariaReplayInfo || 'Infos';
  rInfo.setAttribute('aria-label', lbl);
  rInfo.title = lbl;
}
// Settings FAB title/aria
const sfab = document.getElementById('settings-fab');
if (sfab) {
sfab.setAttribute('aria-label', tr.ariaSettingsFab || 'Paramètres');
sfab.title = tr.ariaSettingsFab || 'Paramètres';
}
// Install btn title/aria
const installBtn = document.getElementById('install-btn');
if (installBtn) {
installBtn.setAttribute('aria-label', tr.ariaInstallBtn || 'Installer l\'application');
installBtn.title = tr.ariaInstallBtn || 'Installer l\'application';
}
// Guided btn title/aria
const guidedBtn = document.getElementById('guided-btn');
if (guidedBtn) {
guidedBtn.setAttribute('aria-label', tr.ariaModeGuide || 'Mode guidé');
guidedBtn.title = tr.ariaModeGuide || 'Mode guidé';
}
// Online copy code aria/title
const oCopy = document.getElementById('online-copy-code');
if (oCopy) {
  const lbl = tr.onlineCopyCodeAria || 'Copier le code';
  oCopy.setAttribute('aria-label', lbl);
  oCopy.title = lbl;
}
// online-invite-toggle aria-label
const oInvite = document.getElementById('online-invite-toggle');
if (oInvite) {
  const lbl = tr.onlineInviteBtn || '📤 Inviter un ami';
  oInvite.setAttribute('aria-label', lbl);
}
// ── Color section label (mode-aware) ────────────────────────────
const colorSectionLabel = document.getElementById('color-section-label');
if (colorSectionLabel) {
const labelKey = (gameMode === 'ai') ? 'chooseYourColorTitle': 'colorLabelLocal';
colorSectionLabel.textContent = tr[labelKey] || colorSectionLabel.textContent;
colorSectionLabel.dataset.i18n = labelKey;
}
}

function showScreen(screenId) {
currentScreen = screenId;
allScreens.forEach(screen => screen.classList.remove('active'));
document.getElementById(screenId)?.classList.add('active');

if (screenId === 'game-play-area') {
mainHeader.classList.add('hidden');
hideSaveNotification(); // masquer la notif pendant qu'on joue
} else {
mainHeader.classList.remove('hidden');
stopSpectatorMode();
}

// ── Ré-afficher la notif "reprendre" chaque fois qu'on revient à l'accueil ──
if (screenId === 'version-selection-area') {
checkForSavedGame();
} else {
// Masquer la notif sur toutes les autres pages (menus, setup…)
hideSaveNotification();
}

if (screenId === 'player-setup-area') {
const isAiMode = gameMode === 'ai';
player2NameGroup.style.display = isAiMode ? 'none': 'flex';
// ── Afficher la section couleur dans les 2 modes ──────────────
colorChoiceSection.style.display = 'flex';

// Adapter le libellé selon le mode
const colorSectionLabel = document.getElementById('color-section-label');
if (colorSectionLabel) {
const labelKey = isAiMode ? 'chooseYourColorTitle': 'colorLabelLocal';
colorSectionLabel.textContent = translations[currentLanguage][labelKey] || colorSectionLabel.textContent;
colorSectionLabel.dataset.i18n = labelKey;
}

player1NameLabel.textContent = translations[currentLanguage][isAiMode ? 'playerHumanName': 'player1NameLabel'];

// Restore last typed names (saved on each edit)
applySavedSetupNames(isAiMode);

if (isAiMode) {
humanPlayerId = 1; // Default human to player 1
player1Name = translations[currentLanguage].defaultHumanName;
player2Name = translations[currentLanguage].defaultComputerName;
} else {
humanPlayerId = 1; // Default: J1 plays Black (Player ID 1)
player1Name = translations[currentLanguage].defaultPlayer1;
player2Name = translations[currentLanguage].defaultPlayer2;
}
updateColorOptionSelection(humanPlayerId);
}
}

function updateColorOptionSelection(selectedPlayerId) {
// ── 1. Mettre à jour les boutons de choix de couleur ─────────────
colorOptions.forEach(option => {
const id = parseInt(option.dataset.player);
const isSelected = id === selectedPlayerId;
option.classList.toggle('selected', isSelected);
option.querySelector('input[type="radio"]').checked = isSelected;
const nameSpan = option.querySelector('.psu-opt-name');
if (!nameSpan) return;
const colorKey = `player${id}Color`;
const colorName = (translations[currentLanguage][colorKey] || '').split(' ')[0];
if (gameMode === 'ai') {
nameSpan.textContent = isSelected
? `${translations[currentLanguage].yourColor || 'Vous'} (${colorName})`: `${translations[currentLanguage].aiColor || 'IA'} (${colorName})`;
} else {
const j1Label = translations[currentLanguage].defaultPlayer1 || 'Joueur 1';
const j2Label = translations[currentLanguage].defaultPlayer2 || 'Joueur 2';
const playerLabel = (id === selectedPlayerId) ? j1Label: j2Label;
nameSpan.textContent = `${playerLabel} — ${colorName}`;
}
});

// ── 2. Synchroniser les pions des cartes joueur ──────────────────
// humanPlayerId = l'ID de couleur (1=Noir, 2=Blanc) choisi par le J1 humain
// card1 = carte du J1 (champ nom haut), card2 = carte du J2 / IA
const card1Stone = document.getElementById('card1-stone');
const card2Stone = document.getElementById('card2-stone');

// Clés de traduction pour le label couleur dans la carte
const colorBlackKey = 'player1Color'; // "Noir / Aberkan"
const colorWhiteKey = 'player2Color'; // "Blanc / Amellal"
const blackLabel = (translations[currentLanguage][colorBlackKey] || 'Noir').split('(')[0].trim();
const whiteLabel = (translations[currentLanguage][colorWhiteKey] || 'Blanc').split('(')[0].trim();

// J1 choisit selectedPlayerId (1=Noir, 2=Blanc)
const card1PlayerClass = `player${selectedPlayerId}`; // couleur choisie par J1
const card2PlayerClass = `player${selectedPlayerId === 1 ? 2: 1}`; // couleur de J2 / IA
const card1ColorLabel = selectedPlayerId === 1 ? blackLabel: whiteLabel;
const card2ColorLabel = selectedPlayerId === 1 ? whiteLabel: blackLabel;

if (card1Stone) {
card1Stone.classList.remove('player1', 'player2');
card1Stone.classList.add(card1PlayerClass);
}
if (card2Stone) {
card2Stone.classList.remove('player1', 'player2');
card2Stone.classList.add(card2PlayerClass);
}

// ── 3. Mettre à jour les labels de couleur dans les cartes ───────
const label1 = document.getElementById('player1-name-label');
const label2 = document.getElementById('player2-name-label');
const tr = translations[currentLanguage];

if (gameMode === 'ai') {
// Une seule carte visible : le label indique la couleur du joueur humain
if (label1) {
label1.textContent = `${tr.playerHumanName || 'Humain'} · ${card1ColorLabel}`;
label1.removeAttribute('data-i18n'); // géré dynamiquement
}
} else {
// Deux cartes : afficher J1/J2 + leur couleur attribuée
const j1 = tr.defaultPlayer1 || 'Joueur 1';
const j2 = tr.defaultPlayer2 || 'Joueur 2';
if (label1) {
label1.textContent = `${j1} · ${card1ColorLabel}`; label1.removeAttribute('data-i18n');
}
if (label2) {
label2.textContent = `${j2} · ${card2ColorLabel}`; label2.removeAttribute('data-i18n');
}
}
}

function updateGameInfoDisplay() {
const variantInfoEl = document.getElementById('game-variant-info');
const difficultyInfoEl = document.getElementById('game-difficulty-info');

if (variant) {
const variantTitleKey = variant === 'TIDDEST-no-diag' ? 'TIDDESTTitle': 'bessifTitle';
variantInfoEl.innerHTML = `<strong>${translations[currentLanguage].gameVersion}</strong> ${translations[currentLanguage][variantTitleKey]}`;
} else {
variantInfoEl.innerHTML = '';
}

if (gameMode === 'ai' && aiDifficulty) {
const difficultyNameKey = {
1: 'difficultyEasy',
2: 'difficultyMedium',
3: 'difficultyHard',
4: 'difficultyImpossible'
}[aiDifficulty];
difficultyInfoEl.innerHTML = `<strong>${translations[currentLanguage].aiDifficultyDisplayLabel}</strong> ${translations[currentLanguage][difficultyNameKey]}`;
difficultyInfoEl.style.display = 'block';
} else {
difficultyInfoEl.innerHTML = '';
difficultyInfoEl.style.display = 'none';
}
}

function triggerConfetti() {
runConfetti(5000);
}

function showWinnerAnimation(message, name, isDefeat) {
  playSound('victory');
  clearSave();

  if (!winnerOverlay) return;

  // Label principal (Félicitations ! / Vous avez perdu)
  const msgEl = winnerOverlay.querySelector('.winner-message');
  if (msgEl) msgEl.textContent = message;

  // Sous-titre contextuel
  const sub = document.getElementById('wo-result-sub');
  if (sub) sub.textContent = isDefeat ? t('woSubDefeat','— Fin de partie —') : t('woSubVictory','— Victoire —');

  // Icône trophée / cœur brisé
  const trophy = document.getElementById('wo-trophy');
  if (trophy) trophy.textContent = isDefeat ? '💔' : '🏆';

  // Nom
  if (winnerNameElement) winnerNameElement.textContent = name;

  // Classe défaite
  winnerOverlay.classList.toggle('wo-defeat', !!isDefeat);

  // Particules de fond
  _spawnWoParticles(isDefeat);

  winnerOverlay.classList.add('active');
  triggerConfetti();
  finalizeSessionAndStats();
  pushReplayFrame();
  persistLastReplay();
}

function _spawnWoParticles(isDefeat) {
const c = document.getElementById('wo-particles');
if (!c) return;
c.innerHTML = '';
const cols = isDefeat
? ['rgba(100,160,255,.7)',
'rgba(70,110,220,.5)',
'rgba(140,175,255,.45)']: ['rgba(240,200,80,.7)',
'rgba(230,140,50,.6)',
'rgba(255,220,100,.5)'];
for (let i = 0; i < 20; i++) {
const p = document.createElement('div');
p.className = 'p';
const s = 4 + Math.random() * 9;
p.style.cssText = [
`width:${s}px`,
`height:${s}px`,
`left:${Math.random()*100}%`,
`bottom:${-s}px`,
`background:${cols[i%cols.length]}`,
`animation-duration:${5+Math.random()*6}s`,
`animation-delay:${Math.random()*4}s`
].join(';');
c.appendChild(p);
}
}

function hideWinnerAnimation() {
stopSpectatorMode();
winnerOverlay.classList.remove('active', 'wo-defeat');
const c = document.getElementById('wo-particles');
if (c) c.innerHTML = '';
showScreen('version-selection-area');
}

function showStatusError(messageKey) {
playSound('error');
const originalText = statusDiv.textContent;
statusDiv.textContent = translations[currentLanguage][messageKey] || messageKey;
statusDiv.classList.add('status-error');
setTimeout(() => {
statusDiv.classList.remove('status-error');
statusDiv.textContent = originalText;
updateStatus();
}, 1500);
}

function __resolveIconEmoji(iconToken) {
if (!iconToken) return '';
const s = String(iconToken);
// If it doesn't look like a FontAwesome class list, treat it as a direct emoji/symbol.
if (s.indexOf('fa-') === -1) return s;

const cls = s.split(/\s+/).find(c => c.startsWith('fa-'));
const map = {
'fa-globe': '🌐',
'fa-book-open': '📖',
'fa-robot': '🤖',
'fa-users': '👥',
'fa-eye': '👁️',
'fa-smile': '🙂',
'fa-meh': '😐',
'fa-grimace': '😬',
'fa-frown': '😟',
'fa-grin-beam': '😁',
'fa-mouse-pointer': '👉',
'fa-exchange-alt': '🔄',
'fa-skull-crossbones': '☠️',
'fa-check-circle': '✅',
'fa-play': '▶️',
'fa-compact-disc': '💿',
'fa-ghost': '👻',
'fa-home': '🏠',
'fa-undo': '↩️',
'fa-redo': '↪️',
'fa-flag': '🏳️'
};
return map[cls] || '•';
}

function showEphemeralBubbleMessage(messageKey, iconClass = '', playerId = 0, duration = 2000) {
const msg = (translations[currentLanguage] && translations[currentLanguage][messageKey]) || messageKey;
const emoji = __resolveIconEmoji(iconClass);

// Determine visual variant from message key
const variantMap = {
ephemeralMill:          'badge-mill',
ephemeralCaptureNormal: 'badge-capture',
ephemeralCaptureBessif: 'badge-sacrifice',
ephemeralMovePhase:     'badge-phase',
};
const variant = variantMap[messageKey] || 'badge-capture';

// Targets: 0 = both, 1 = p1, 2 = p2
const ids = playerId === 1 ? ['p1-badge']
           : playerId === 2 ? ['p2-badge']
           : ['p1-badge', 'p2-badge'];

ids.forEach(id => {
const badge = document.getElementById(id);
if (!badge) return;

// Clear previous timer if any
if (badge._ephTimer) clearTimeout(badge._ephTimer);

// Build pill content
const pill = document.createElement('div');
pill.className = 'badge-pill';
if (emoji) {
  const iconEl = document.createElement('i');
  iconEl.setAttribute('aria-hidden', 'true');
  iconEl.textContent = emoji;
  pill.appendChild(iconEl);
}
const span = document.createElement('span');
span.textContent = msg;
pill.appendChild(span);

// Reset and inject
badge.innerHTML = '';
badge.appendChild(pill);
badge.className = `player-badge ${variant} active`;

badge._ephTimer = setTimeout(() => {
  badge.classList.remove('active');
  setTimeout(() => { badge.innerHTML = ''; badge.className = 'player-badge'; }, 350);
}, duration);
});
}

// --- GAME INITIALIZATION AND LOGIC ---
function initState() {
return {
board: Array(SIZE * SIZE).fill(null),
phase: "placement",
turn: 2,
turnForCapture: null,
counts: {
1: PIECES,
2: PIECES
},
captured: {
1: 0,
2: 0
},
selected: null,
captureMode: false,
winner: null,
highlightedMills: [],
pendingCaptures: 0,
// --- RÈGLE : même pion max 3 fois de suite ---
// consecutivePiece[p] = indice actuel du pion surveillé pour le joueur p
// consecutiveCount[p] = combien de fois consécutives ce pion a été déplacé
consecutivePiece: {
1: null,
2: null
},
consecutiveCount: {
1: 0,
2: 0
},
};
}


// ─────────────────────────────────────────────────────────────
// RÈGLE : Même pion max 3 fois consécutives
// ─────────────────────────────────────────────────────────────

/**
* Vérifie si le pion à la position fromIdx est interdit pour player
* parce quil a déjà été déplacé 3 fois de suite.
* Exception : si cest le SEUL pion que le joueur peut bouger (deadlock)
*/
function isConsecutiveBlocked(player, fromIdx) {
if (state.phase !== 'move') return false;
if (state.consecutivePiece[player] !== fromIdx) return false;
if (state.consecutiveCount[player] < 3) return false;
return hasAlternativePiece(player, fromIdx);
}

/**
* Renvoie true si le joueur possède au moins un autre pion capable de bouger.
*/
function hasAlternativePiece(player, forbiddenIdx) {
for (let from = 0; from < SIZE * SIZE; from++) {
if (from === forbiddenIdx) continue;
if (state.board[from] !== player) continue;
for (let to = 0; to < SIZE * SIZE; to++) {
if (state.board[to] === null && isAdjacent(from, to)) return true;
}
}
return false;
}

/**
* Met à jour le suivi consécutif APRÈS un déplacement from->to.
*/
function updateConsecutiveTracking(player, fromIdx, toIdx) {
if (state.consecutivePiece[player] === fromIdx) {
state.consecutiveCount[player] = Math.min(state.consecutiveCount[player] + 1, 99);
} else {
state.consecutiveCount[player] = 1;
}
state.consecutivePiece[player] = toIdx;
}

/**
* Filtre une liste de mouvements pour retirer le pion interdit.
* Exception : si aucun autre mouvement nexiste, garde tout (deadlock).
*/
function filterConsecutiveMoves(player, moves) {
if (state.phase !== 'move') return moves;
const forbidden = state.consecutivePiece[player];
if (forbidden === null) return moves;
if (state.consecutiveCount[player] < 3) return moves;
const allowed = moves.filter(m => m.from !== forbidden);
return allowed.length > 0 ? allowed: moves;
}

// ─────────────────────────────────────────────────────────────

function startGame() {
clearSave(); // effacer toute sauvegarde précédente avant de démarrer
hideSaveNotification();
state = initState();
moveHistory = [];
boardPositionHistory = new Map();
forbiddenBoardPositions = new Set();

const p1Input = normalizeName(player1NameInput.value, '');
const p2Input = normalizeName(player2NameInput.value, '');
// Persist the setup fields immediately (also saved on each edit)
saveNamePrefs(p1Input, p2Input);

if (gameMode === 'ai') {
aiPlayerId = (humanPlayerId === 1) ? 2: 1;
if (p1Input) {
if (humanPlayerId === 1) player1Name = p1Input;
else player2Name = p1Input;
} else {
if (humanPlayerId === 1) player1Name = translations[currentLanguage].defaultHumanName;
else player2Name = translations[currentLanguage].defaultHumanName;
}

if (aiPlayerId === 1) player1Name = translations[currentLanguage].defaultComputerName;
else player2Name = translations[currentLanguage].defaultComputerName;
} else {
aiPlayerId = null;
// humanPlayerId = Player ID (1=Noir, 2=Blanc) choisi par J1 (premier champ nom)
// Player ID 2 (Blanc) commence toujours (turn: 2 dans initState)
if (humanPlayerId === 1) {
// J1 joue Noir (Player ID 1), J2 joue Blanc (Player ID 2, commence)
player1Name = p1Input || translations[currentLanguage].defaultPlayer1;
player2Name = p2Input || translations[currentLanguage].defaultPlayer2;
} else {
// J1 joue Blanc (Player ID 2, commence), J2 joue Noir (Player ID 1)
player1Name = p2Input || translations[currentLanguage].defaultPlayer1; // Noir = J2
player2Name = p1Input || translations[currentLanguage].defaultPlayer2; // Blanc = J1
}
}

updateGameInfoDisplay();
showScreen('game-play-area');
renderAll();
triggerNextAction();
}


// ---------------------------------------------------------
// Rematch / Replay (same room, alternating colors each round)
// ---------------------------------------------------------
function toggleLocalColorForNextRound() {
  // In AI and Local modes, humanPlayerId determines which side starts (White=2 starts)
  // We alternate each new game start.
  if (gameMode === 'ai' || gameMode === 'local') {
    humanPlayerId = (humanPlayerId === 1) ? 2 : 1;
    try { updateColorOptionSelection?.(humanPlayerId); } catch(_) {}
  }
}

async function onlineSetRematchReady(isReady) {
  if (gameMode !== 'online') return;
  if (!online || !online.connected || !online.matchId) return;
  if (!_ensureParseReady()) return;
  try {
    const match = new Parse.Object(BACK4APP_CLASS);
    match.id = online.matchId;
    if (online.role === 1) match.set('rm1', !!isReady);
    if (online.role === 2) match.set('rm2', !!isReady);
    match.increment('rev', 1);
    await match.save();
  } catch(_) {}
}

function handleReplayClick() {
  hideWinnerAnimation();

  // Online: stay in the same room
  if (gameMode === 'online' && online && online.connected) {
    // Mark ready for rematch; host will start when both are ready.
    onlineSetRematchReady(true);
    // Go back to online lobby UI (without leaving the room)
    try { showScreen('online-lobby-area'); } catch(_) {}
    _setOnlineStatus(t('onlineRematchReadyToast'));
    // If host, try auto-start when both players are ready (will be checked by lobby polling)
    if (online.isHost) {
      // Attempt immediate start if already both ready (best-effort; polling also handles it)
      (async () => {
        try {
          const match = await _fetchMatchById(online.matchId);
          const rm1 = !!match.get('rm1');
          const rm2 = !!match.get('rm2');
          if (rm1 && rm2) onlineStartMatch_Back4App();
        } catch(_) {}
      })();
    }
    return;
  }

  // Spectator: restart the AI-vs-AI match
  if (gameMode === 'spectator') {
    startSpectatorGame();
    return;
  }

  // Offline / AI / Local
  toggleLocalColorForNextRound();
  startGame();
}

function renderAll() {
renderBoard();
updateInfo();
updateStatus();
updatePlayerNamesDisplay();
updateUndoButtonState();
}

function renderBoard() {
boardDiv.innerHTML = '';
// Calcul du pion bloqué pour le joueur actif (affichage visuel)
const blockedIdx = (state.phase === 'move' && !state.captureMode)
? (() => {
const p = state.turn;
const idx = state.consecutivePiece[p];
if (idx === null || state.consecutiveCount[p] < 3) return null;
return hasAlternativePiece(p, idx) ? idx: null;
})(): null;

for (let i = 0; i < SIZE * SIZE; i++) {
const cell = document.createElement('div');
cell.className = "cell";
cell.dataset.idx = i;
if ((Math.floor(i / SIZE) + i % SIZE) % 2 !== 0) {
cell.classList.add("dark-cell");
}
if (state.selected === i) {
cell.classList.add("selected");
}
if (!state.captureMode && state.selected !== null && state.board[i] === null && isAdjacent(state.selected, i)) {
cell.classList.add("possible-move");
}
if (state.highlightedMills.includes(i)) {
cell.classList.add("mill-highlight");
}
if (state.board[i]) {
const stone = document.createElement('div');
stone.className = `stone player${state.board[i]}`;
if (state.selected === i) stone.classList.add("selected");
// ── Marquage pion épuisé (3 fois de suite) ──
if (i === blockedIdx) stone.classList.add("consecutive-blocked");
cell.appendChild(stone);
}
// Marquer la cellule aussi si le pion y est bloqué
if (i === blockedIdx) cell.classList.add("consecutive-blocked-cell");
cell.onclick = () => onCellClick(i);
boardDiv.appendChild(cell);
}

if (state.captureMode) {
const playerWhosePiecesAreTargetable = cfg().isInverseWin ? state.turnForCapture: (3 - state.turnForCapture);
for (let i = 0; i < SIZE * SIZE; i++) {
if (state.board[i] === playerWhosePiecesAreTargetable) {
boardDiv.children[i].classList.add("capturable");
boardDiv.children[i].onclick = () => onCellClick(i);
} else {
boardDiv.children[i].onclick = null;
}
}
} else {
for (let i = 0; i < SIZE * SIZE; i++) {
boardDiv.children[i].onclick = () => onCellClick(i);
}
}


// ── Mode glisser-déposer : binder pointerdown sur les pions déplaçables (sans empiler les listeners) ──
boardDiv.classList.toggle('drag-mode-active', dragMode);
const actor = state.turn;
const isHuman = gameMode !== 'spectator' && (gameMode !== 'ai' || actor !== aiPlayerId);
for (let i = 0; i < SIZE * SIZE; i++) {
const cell = boardDiv.children[i];
const canDrag = dragMode && isHuman && state.phase === 'move' && !state.captureMode && !state.winner && state.board[i] === actor && !isConsecutiveBlocked(actor, i);
if (canDrag) {
cell.dataset.draggable = 'true';
cell.onpointerdown = (e) => _onDragStart(e, i);
} else {
cell.dataset.draggable = 'false';
cell.onpointerdown = null;
}
}
updateActivePlayerDisplay();
}

function updateInfo() {
if (state.phase === 'placement') {
// During placement: show remaining pieces to place
p1Count.textContent = state.counts[1];
p2Count.textContent = state.counts[2];
} else {
// During move phase: show pieces on the board
p1Count.textContent = state.board.filter(p => p === 1).length;
p2Count.textContent = state.board.filter(p => p === 2).length;
}
p1Capt.textContent = state.captured[1];
p2Capt.textContent = state.captured[2];
}

function updatePlayerNamesDisplay() {
const p1ColorName = translations[currentLanguage].player1Color.split(' ')[0];
const p2ColorName = translations[currentLanguage].player2Color.split(' ')[0];
p1DisplayName.textContent = `${player1Name} (${p1ColorName})`;
p2DisplayName.textContent = `${player2Name} (${p2ColorName})`;
}

function updateStatus() {
if (state.winner) {
statusDiv.textContent = translations[currentLanguage].statusGameOver;
return;
}

const p1NameForStatus = p1DisplayName.textContent.split(' (')[0];
const p2NameForStatus = p2DisplayName.textContent.split(' (')[0];

if (state.captureMode) {
// captureCountInfo: only shown if multiple captures remain in one turn
const captureCountInfo = state.pendingCaptures > 1 ? ` (×${state.pendingCaptures})`: '';

const playerWhoChoosesName = (state.turnForCapture === 1) ? p1NameForStatus: p2NameForStatus;

if (cfg().isInverseWin) {
statusDiv.textContent = `${playerWhoChoosesName} ${translations[currentLanguage].statusChooseSacrifice}${captureCountInfo}`;
} else {
const playerWhosePieceIsCapturedName = (state.turnForCapture === 1) ? p2NameForStatus: p1NameForStatus;
statusDiv.textContent = `${playerWhoChoosesName}, ${translations[currentLanguage].statusChooseCapture} ${playerWhosePieceIsCapturedName} ${translations[currentLanguage].statusToCapture}${captureCountInfo}`;
}
} else {
const currentPlayerName = (state.turn === 1) ? p1NameForStatus: p2NameForStatus;
const phaseKey = state.phase === 'placement' ? 'statusPlacementPhase': 'statusMovePhase';
statusDiv.textContent = `${translations[currentLanguage][phaseKey]} ${currentPlayerName}.`;
}
}

function updateActivePlayerDisplay() {
const activePlayer = state.captureMode ? state.turnForCapture: state.turn;
p1Info.classList.toggle('active-player', activePlayer === 1);
p2Info.classList.toggle('active-player', activePlayer === 2);
}

function updateUndoButtonState() {
const canUndo = moveHistory.length > 0 &&
!state.winner &&
(gameMode !== 'ai' || state.turn === humanPlayerId) &&
!state.captureMode;
undoBtn.disabled = !canUndo;
}

function onCellClick(i) {
if (_dragSuppressClick) return; // un glissement vient de se terminer
if (state.winner) return;
if (gameMode === 'spectator') return;
const playerWhoShouldAct = state.captureMode ? state.turnForCapture: state.turn;
if (gameMode === 'ai' && playerWhoShouldAct === aiPlayerId) {
return;
}
if (state.captureMode) {
handleCaptureClick(i);
return;
}

const prevSelected = state.selected;
moveHistory.push(deepCopy(state));
if (state.phase === 'placement') {
handlePlacement(i);
} else {
handleMove(i);
if (state.selected !== null && state.selected !== prevSelected) {
playSound('select');
}
}
}


function handleUndo() {
// Online multiplayer: only act on your turn
if (gameMode === 'online' && !isMyTurnOnline()) {
  if (typeof showStatusError === 'function') showStatusError('notYourTurn');
  return;
}

if (undoBtn.disabled) return;
if (moveHistory.length === 0) return;

playSound('undo');
if (gameMode === 'ai') {
const isPlayableHumanTurn = (s) => s && !s.captureMode && s.turn === humanPlayerId;
let candidate = null;
while (moveHistory.length > 0) {
candidate = moveHistory.pop();
if (isPlayableHumanTurn(candidate)) break;
}
if (candidate) state = candidate;
} else {
state = moveHistory.pop();
}

if (moveLog.length > 0) {
moveLog.pop(); renderMoveLog();
}
renderAll();
saveGame();
if (!state.winner) triggerNextAction();
}


function handleCaptureClick(i) {
if (!state.captureMode || state.winner) return;
const pieceOwner = state.board[i];
const isInverseWin = cfg().isInverseWin;
if (isInverseWin) {
if (pieceOwner !== state.turnForCapture) {
showStatusError('statusChooseOwnPieceToSacrifice');
return;
}
} else {
if (pieceOwner !== (3 - state.turnForCapture)) {
showStatusError('statusChooseOpponentPieceToCapture');
return;
}
}
handleCapture(i);
}

function handlePlacement(i) {
  // Online multiplayer: only act on your turn
  if (gameMode === 'online' && !isMyTurnOnline()) {
    if (typeof showStatusError === 'function') showStatusError('notYourTurn');
    return;
  }

  if (state.board[i] !== null) {
    showStatusError('statusAlreadyOccupied'); moveHistory.pop(); return;
  }
  if (state.counts[state.turn] <= 0) {
    showStatusError('statusNoPiecesToPlace'); moveHistory.pop(); return;
  }

  const originalBoard = [...state.board];

  const tempBoard = [...state.board];
  tempBoard[i] = state.turn;
  if (formsForbiddenPlacementAlignment(i, state.turn, tempBoard)) {
    showStatusError('statusPlacementAlignForbidden');
    moveHistory.pop();
    return;
  }

  state.board[i] = state.turn;
  state.counts[state.turn]--;
  animateStonePlacement(i, state.turn);

  // Detect mills formed during PLACEMENT as well (important for online sync)
  const formedMills = findAllMills(originalBoard, state.board, i, i, state.turn);

  if (formedMills.length > 0) {
    const placer = state.turn;

    state.captureMode = true;
    state.pendingCaptures = formedMills.length;
    state.turnForCapture = cfg().isInverseWin ? (3 - placer) : placer;
    state.highlightedMills = formedMills.flat();

    const emoji = cfg().isInverseWin ? '😋' : 'far fa-grin-beam';
    showEphemeralBubbleMessage('ephemeralMill', emoji, state.turnForCapture);

    renderBoard();
    updateUndoButtonState();
    setTimeout(() => {
      state.highlightedMills = [];
      renderBoard();
    }, 1500);

    updateStatus();
    saveGame(); // <-- crucial for online sync
    triggerNextAction();
  } else {
    endTurn();
  }
}

function handleMove(i) {
// Online multiplayer: only act on your turn
if (gameMode === 'online' && !isMyTurnOnline()) {
  if (typeof showStatusError === 'function') showStatusError('notYourTurn');
  return;
}

if (state.selected === null) {
if (state.board[i] === state.turn) {
// ── Règle : pion joué 3× de suite interdit ──
if (isConsecutiveBlocked(state.turn, i)) {
showStatusError('statusConsecutiveBlocked');
moveHistory.pop();
return;
}
state.selected = i;
moveHistory.pop();
renderBoard();
updateStatus();
} else {
showStatusError(state.board[i] ? 'statusYourPiecesTurn': 'statusSelectYourPiece');
moveHistory.pop();
}
} else {
const from = state.selected;
const to = i;
if (to === from) {
state.selected = null; moveHistory.pop(); renderBoard(); updateStatus(); return;
}
// Si le joueur clique sur un autre de ses pions → le sélectionner
// Mais vérifier la règle consécutive sur le nouveau pion aussi
if (state.board[to] === state.turn) {
if (isConsecutiveBlocked(state.turn, to)) {
showStatusError('statusConsecutiveBlocked');
state.selected = null;
moveHistory.pop();
renderBoard();
updateStatus();
return;
}
state.selected = to;
moveHistory.pop();
renderBoard();
updateStatus();
return;
}
if (state.board[to] === null && isAdjacent(from, to)) {
if (cfg().forceMillMove) {
const allPossibleMillMovesForPlayer = getPossibleMillMoves(state.turn, state.board, 'move');
const tempBoard = simulateMove(state.board, {
from, to
}, state.turn);
const isCurrentMoveAMill = findAllMills(state.board, tempBoard, from, to, state.turn).length > 0;
if (allPossibleMillMovesForPlayer.length > 0 && !isCurrentMoveAMill) {
showStatusError('statusMustMakeMill');
state.selected = null;
moveHistory.pop();
renderBoard();
updateStatus();
return;
}
}

// ── Mémoriser le joueur AVANT l'animation (state.turn peut changer) ──
const movingPlayer = state.turn;
const moveFrom = from;
const moveTo = to;

animateStoneMove(from, to);
setTimeout(() => {
const originalBoard = [...state.board];
state.board[moveTo] = movingPlayer;
state.board[moveFrom] = null;
state.selected = null;

// ── Mise à jour suivi consécutif ──
updateConsecutiveTracking(movingPlayer, moveFrom, moveTo);

const formedMills = findAllMills(originalBoard, state.board, moveFrom, moveTo, movingPlayer);

if (formedMills.length > 0) {
state.captureMode = true;
state.pendingCaptures = formedMills.length;
state.turnForCapture = cfg().isInverseWin ? (3 - movingPlayer): movingPlayer;
state.highlightedMills = formedMills.flat();

const emoji = cfg().isInverseWin ? '😋' : 'far fa-grin-beam';
showEphemeralBubbleMessage('ephemeralMill', emoji, state.turnForCapture);

renderBoard();
updateUndoButtonState();
setTimeout(() => {
state.highlightedMills = []; renderBoard();
}, 1500);

updateStatus();
saveGame();
triggerNextAction();
} else {
endTurn();
}
},
300);
} else {
showStatusError('statusInvalidMove');
state.selected = null;
moveHistory.pop();
renderBoard();
updateStatus();
}
}
}

function handleCapture(idxToCapture) {
// Online multiplayer: only act on your turn
if (gameMode === 'online' && !isMyTurnOnline()) {
  if (typeof showStatusError === 'function') showStatusError('notYourTurn');
  return;
}

const capturerTurn = state.turnForCapture;
// Undo behavior: a capture is part of the same "turn transaction" as the move/placement that created it.
// We deliberately DO NOT push a new snapshot here, otherwise undo can revert to a captureMode state and lock the player.
if (!state.captureMode || state.winner) return;
const playerWhoGetsPoint = cfg().isInverseWin ? (3 - state.turnForCapture): state.turnForCapture;

// ── Étape 1 : mettre en évidence le pion capturé pour que l'adversaire puisse le voir ──
const messageKey = cfg().isInverseWin ? 'ephemeralCaptureBessif': 'ephemeralCaptureNormal';
showEphemeralBubbleMessage(messageKey, 'fas fa-mouse-pointer', capturerTurn);
const targetCell = boardDiv.children[idxToCapture];
if (targetCell) targetCell.classList.add('capture-pending');

// ── Étape 2 : après 900 ms, jouer le son + animation de suppression ──
setTimeout(() => {
if (targetCell) targetCell.classList.remove('capture-pending');
playSound('capture');
addMoveLog( {
player: capturerTurn, text: `${(translations[currentLanguage] && translations[currentLanguage].logCapture) || 'Capture'} [${Math.floor(idxToCapture/5)+1},${idxToCapture%5+1}]`, capture: true
});
animateStoneCapture(idxToCapture);

// ── Étape 3 : après encore 500 ms, supprimer réellement le pion et continuer ──
setTimeout(() => {
state.board[idxToCapture] = null;
state.captured[playerWhoGetsPoint]++;
state.pendingCaptures--;

if (state.pendingCaptures > 0) {
renderAll();
saveGame();
triggerNextAction();
} else {
state.captureMode = false;
state.turnForCapture = null;
state.highlightedMills = [];
endTurn();
}
},
500);
}, 900);
}

function handleSurrender() {
  // Online multiplayer: only act on your turn
  if (gameMode === 'online' && !isMyTurnOnline()) {
    if (typeof showStatusError === 'function') showStatusError('notYourTurn');
    return;
  }

  if (state.winner) return;

  const surrenderer = state.turn;
  const winnerId = 3 - surrenderer;
  state.winner = winnerId;

  const p1NameForStatus = p1DisplayName.textContent.split(' (')[0];
  const p2NameForStatus = p2DisplayName.textContent.split(' (')[0];
  const surrendererName = surrenderer === 1 ? p1NameForStatus : p2NameForStatus;

  statusDiv.textContent = `${surrendererName} ${translations[currentLanguage].surrenderMessage}`;

  // Use unified end-game UI so each device sees Victory/Defeat correctly in online mode.
  if (typeof endGame === 'function') endGame();

  updateUndoButtonState();
  saveGame();
  if (gameMode === 'online') { try { onlineSendState('surrender'); } catch(_) {} }
}

function endTurn() {
state.turn = 3 - state.turn;
// ── Enregistrement de la position pour la détection des boucles IA ──
const _boardSig = state.board.map(v => v || 0).join('');
const _posCount = (boardPositionHistory.get(_boardSig) || 0) + 1;
boardPositionHistory.set(_boardSig, _posCount);
if (_posCount >= 3) forbiddenBoardPositions.add(_boardSig);
if (state.phase === 'placement' && state.counts[1] === 0 && state.counts[2] === 0) {
state.phase = 'move';
showEphemeralBubbleMessage('ephemeralMovePhase', "fas fa-exchange-alt");
}
checkWinner();
renderAll();
saveGame();
if (!state.winner) {
triggerNextAction();
}
}

function endGame() {
  let finalMessage = "";
  let finalWinnerName = "";
  let isDefeat = false;

  const winnerName = (state.winner === 1)
    ? p1DisplayName.textContent.split(' (')[0]
    : p2DisplayName.textContent.split(' (')[0];

  if (gameMode === 'online') {
    // In online mode, each device must see Victory or Defeat depending on its role.
    const myRole = online?.role || humanPlayerId || 1;
    isDefeat = (state.winner !== myRole);
    finalMessage = isDefeat ? translations[currentLanguage].youLost : translations[currentLanguage].congratulations;
    finalWinnerName = `${winnerName} ${translations[currentLanguage].winnerMessage}`;
  } else if (gameMode === 'ai' && state.winner === aiPlayerId) {
    isDefeat = true;
    finalMessage = translations[currentLanguage].youLost;
    finalWinnerName = `${winnerName} ${translations[currentLanguage].aiWinsMessage}`;
  } else {
    finalMessage = translations[currentLanguage].congratulations;
    finalWinnerName = `${winnerName} ${translations[currentLanguage].winnerMessage}`;
  }

  showWinnerAnimation(finalMessage, finalWinnerName, isDefeat);
  updateStatus();
  updateUndoButtonState();
}

function triggerNextAction() {
if (state.winner) return;
const playerToAct = state.captureMode ? state.turnForCapture: state.turn;

if (gameMode === 'spectator') {
const spd = parseInt(document.getElementById('spectator-speed')?.value || '700');
setTimeout(() => {
if (gameMode !== 'spectator') return;
const currentActor = state.captureMode ? state.turnForCapture: state.turn;
aiPlayerId = currentActor;
humanPlayerId = 3 - currentActor;
makeAiMove();
},
spd);
return;
}
if (gameMode === 'ai' && playerToAct === aiPlayerId) {
const delay = aiDifficulty === 4 ? 800: 500;
setTimeout(() => {
makeAiMove();
}, delay);
}
}

// --- GAME RULES AND CHECKS ---
function findAllMills(originalBoard, newBoard, from, to, player) {
const millsBefore = new Set();
for (let i = 0; i < SIZE * SIZE; i++) {
if (originalBoard[i] === player) {
getFormedMills(i, player, originalBoard).forEach(mill => millsBefore.add(mill.sort().join(',')));
}
}

const millsAfter = new Set();
for (let i = 0; i < SIZE * SIZE; i++) {
if (newBoard[i] === player) {
getFormedMills(i, player, newBoard).forEach(mill => millsAfter.add(mill.sort().join(',')));
}
}

const newlyFormedMills = [];
for (const millString of millsAfter) {
if (!millsBefore.has(millString)) {
newlyFormedMills.push(millString.split(',').map(Number));
}
}

const uniqueNewlyFormedMills = [];
const seen = new Set();
for (const mill of newlyFormedMills) {
const sortedMill = [...mill].sort((a, b)=>a-b),
key = sortedMill.join(',');
if (!seen.has(key)) {
uniqueNewlyFormedMills.push(sortedMill); seen.add(key);
}
}
return uniqueNewlyFormedMills;
}

function getFormedMills(idx, player, board) {
const mills = [],
r = Math.floor(idx / SIZE),
c = idx % SIZE;
const directions = [[[0,
-1],
[0,
1]],
[[-1,
0],
[1,
0]]];
for (const [dir1, dir2] of directions) {
let line = [idx];
for (let i = 1; i < SIZE; i++) {
const nr = r + dir1[0] * i,
nc = c + dir1[1] * i,
nIdx = nr * SIZE + nc;
if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && board[nIdx] === player) {
line.unshift(nIdx);
} else break;
}
for (let i = 1; i < SIZE; i++) {
const nr = r + dir2[0] * i,
nc = c + dir2[1] * i,
nIdx = nr * SIZE + nc;
if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && board[nIdx] === player) {
line.push(nIdx);
} else break;
}
if (line.length === 3) {
mills.push([...line].sort((a, b) => a-b));
}
}
return mills;
}



// Placement rule: it is forbidden to create an alignment of 3 OR MORE stones during placement.
// (Mills during movement remain STRICTLY 3 stones.)
function formsForbiddenPlacementAlignment(idx, player, board) {
const r = Math.floor(idx / SIZE),
c = idx % SIZE;

const countDir = (dr, dc) => {
let n = 0;
let rr = r + dr,
cc = c + dc;
while (rr >= 0 && rr < SIZE && cc >= 0 && cc < SIZE) {
const ii = rr * SIZE + cc;
if (board[ii] === player) {
n++; rr += dr; cc += dc;
} else break;
}
return n;
};

// Horizontal length through idx
const h = 1 + countDir(0, -1) + countDir(0, 1);
if (h >= 3) return true;

// Vertical length through idx
const v = 1 + countDir(-1, 0) + countDir(1, 0);
if (v >= 3) return true;

return false;
}
function isAdjacent(a, b) {
const r1 = Math.floor(a / SIZE),
c1 = a % SIZE;
const r2 = Math.floor(b / SIZE),
c2 = b % SIZE;
return (Math.abs(r1 - r2) === 1 && c1 === c2) || (Math.abs(c1 - c2) === 1 && r1 === r2);
}

function canPlayerMove(player, board) {
if (board.filter(p => p === player).length < 3) return false;
for (let i = 0; i < SIZE * SIZE; i++) {
if (board[i] === player) {
for (let j = 0; j < SIZE * SIZE; j++) {
if (board[j] === null && isAdjacent(i, j)) return true;
}
}
}
return false;
}

function checkWinner() {
if (state.phase !== 'move') return;
const p1Pieces = state.board.filter(p => p === 1).length;
const p2Pieces = state.board.filter(p => p === 2).length;
const p1CanMove = canPlayerMove(1, state.board);
const p2CanMove = canPlayerMove(2, state.board);

if (cfg().isInverseWin) {
if (p1Pieces < 3 || !p1CanMove) state.winner = 1;
else if (p2Pieces < 3 || !p2CanMove) state.winner = 2;
} else {
if (p2Pieces < 3 || !p2CanMove) state.winner = 1;
else if (p1Pieces < 3 || !p1CanMove) state.winner = 2;
}
if (state.winner) endGame();
}

function countPlayerMoves(player, board, phase) {
const currentPhase = phase !== undefined ? phase: state.phase;
if (currentPhase === 'placement') return board.filter(p => p === null).length;
let moveCount = 0;
for (let i = 0; i < SIZE * SIZE; i++) {
if (board[i] === player) {
for (let j = 0; j < SIZE * SIZE; j++) {
if (board[j] === null && isAdjacent(i, j)) moveCount++;
}
}
}
return moveCount;
}

// --- ARTIFICIAL INTELLIGENCE ---
const STRATEGIC_CELLS = {
center: [12],
inner_corners: [6,
8,
16,
18],
edge_centers: [7,
11,
13,
17],
inner_ring: [6,
7,
8,
11,
12,
13,
16,
17,
18],
};



function isInInnerRing(idx) {
return STRATEGIC_CELLS.inner_ring.includes(idx);
}
function isCenterCell(idx) {
return STRATEGIC_CELLS.center.includes(idx);
}

// Aggregation metrics around a target cell.
// adj1: number of own pieces at Chebyshev distance 1 (including diagonals)
// adj2: number of own pieces at Chebyshev distance 2
function getAggregationMetrics(board, targetIdx, player) {
const tr = Math.floor(targetIdx / SIZE);
const tc = targetIdx % SIZE;
let adj1 = 0,
adj2 = 0;

for (let i = 0; i < board.length; i++) {
if (i === targetIdx) continue;
if (board[i] !== player) continue;
const r = Math.floor(i / SIZE);
const c = i % SIZE;
const d = Math.max(Math.abs(r - tr), Math.abs(c - tc));
if (d === 1) adj1++;
else if (d === 2) adj2++;
}
return {
adj1,
adj2
};
}
function evaluatePlacement(board, playerToEvaluate) {
const opponent = 3 - playerToEvaluate;
let score = 0;

const playerPotentialMills = getPotentialMillsCount(board, playerToEvaluate);
const opponentPotentialMills = getPotentialMillsCount(board, opponent);
const playerDoubleMills = countDoubleMillSetups(board, playerToEvaluate);
const opponentDoubleMills = countDoubleMillSetups(board, opponent);

if (!cfg().isInverseWin) {
// --- NORMAL WIN LOGIC ---
score += playerDoubleMills * 600;
score -= opponentDoubleMills * 700;
score += playerPotentialMills * 40;
score -= opponentPotentialMills * 50;

board.forEach((cell, idx) => {
if (cell === playerToEvaluate) {
if (STRATEGIC_CELLS.center.includes(idx)) score += 40;
if (STRATEGIC_CELLS.inner_corners.includes(idx)) score += 25;
if (STRATEGIC_CELLS.edge_centers.includes(idx)) score += 15;
} else if (cell === opponent) {
if (STRATEGIC_CELLS.center.includes(idx)) score -= 40;
if (STRATEGIC_CELLS.inner_corners.includes(idx)) score -= 25;
}
});

} else {
// --- INVERSE WIN LOGIC (Učči Bessif) ---
// Higher score = safer for inverse objective:
// - avoid opening mills / double threats
// - avoid the center / inner ring
// - avoid clustering (including diagonals and distance-2)
score -= playerPotentialMills * 650;
score -= playerDoubleMills * 2600;

// It's generally helpful (for losing pieces later) if the opponent has more mill potential.
score += opponentPotentialMills * 90;
score += opponentDoubleMills * 650;

board.forEach((cell, idx) => {
if (cell === playerToEvaluate) {
// Strong avoidance of the center / inner ring.
if (isCenterCell(idx)) score -= 2200;
else if (isInInnerRing(idx)) score -= 1400;

// Avoid aggregation of own pieces (distance 1 & 2, incl. diagonals).
const aggSelf = getAggregationMetrics(board, idx, playerToEvaluate);
score -= aggSelf.adj1 * 950;
score -= aggSelf.adj2 * 420;

// Slight bonus if close to opponent pieces (easier to be captured later),
// but much smaller than the anti-aggregation penalty.
const aggOpp = getAggregationMetrics(board, idx, opponent);
score += aggOpp.adj1 * 80;
}
});
}
return score;
}

function getPossibleMillMoves(player,
board,
phase) {
const currentPhase = phase !== undefined ? phase: state.phase;
const millMoves = [];
if (currentPhase === 'placement') return [];
for (let from = 0; from < SIZE * SIZE; from++) {
if (board[from] === player) {
for (let to = 0; to < SIZE * SIZE; to++) {
if (board[to] === null && isAdjacent(from, to)) {
const tempBoard = simulateMove(board, {
from, to
}, player);
if (findAllMills(board, tempBoard, from, to, player).length > 0) {
millMoves.push({
from, to
});
}
}
}
}
}
return millMoves;
}

function makeAiMove() {
if (state.winner) return;
if (!state.captureMode) {
moveHistory.push(deepCopy(state));
}
if (state.captureMode) {
const pieceToActOn = aiChoosePieceToActOn();
if (pieceToActOn !== null) {
handleCapture(pieceToActOn);
} else {
// No valid capture target (shouldn't happen, but prevent infinite captureMode lock)
state.captureMode = false;
state.turnForCapture = null;
state.pendingCaptures = 0;
state.highlightedMills = [];
endTurn();
}
return;
}
let move = aiFindBestMove();
if (state.phase === 'placement') {
if (move) {
handlePlacement(move.to);
} else {
state.winner = 3 - aiPlayerId; endGame();
} // use opponent ID, not humanPlayerId (spectator-safe)
} else {
if (!canPlayerMove(aiPlayerId, state.board)) {
showStatusError('aiCannotMove');
state.winner = 3 - aiPlayerId; // use opponent ID, not humanPlayerId (spectator-safe)
endGame();
return;
}
if (move) {
state.selected = move.from;
renderBoard();
setTimeout(() => {
handleMove(move.to);
}, 150);
} else {
state.winner = 3 - aiPlayerId; // use opponent ID, not humanPlayerId (spectator-safe)
endGame();
}
}
setTimeout(() => saveGame(), 800);
}

function isPieceInPotentialMill(board, pieceIndex, player) {
const potentialMillsBefore = getPotentialMillsCount(board, player);
const tempBoard = [...board];
tempBoard[pieceIndex] = null;
const potentialMillsAfter = getPotentialMillsCount(tempBoard, player);
return potentialMillsAfter < potentialMillsBefore;
}

function aiChoosePieceToActOn() {
const isInverse = cfg().isInverseWin;
const playerToTarget = isInverse ? aiPlayerId: humanPlayerId;
const possibleTargets = [];
for (let i = 0; i < state.board.length; i++) {
if (state.board[i] === playerToTarget) possibleTargets.push(i);
}

if (possibleTargets.length === 0) return null;
if (aiDifficulty === 1) {
return possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
}

let bestTarget = possibleTargets[0];

// piecesPlaced = pieces on board + captured (total ever placed)
const piecesPlacedSoFar = state.board.filter(p => p !== null).length + state.captured[1] + state.captured[2];

if (isInverse) {
// In Učči Bessif, AI chooses one of its OWN pieces to sacrifice.
// Goal: maximize inverse evaluation (lose pieces, but avoid creating future forced-mill situations).
__MINIMAX_TT.clear();

let bestScore = -Infinity;
for (const target of possibleTargets) {
const tempBoard = [...state.board];
tempBoard[target] = null;

const winner = getWinnerInState(tempBoard, 'move');
let score = evaluateBoard(tempBoard, aiPlayerId, winner, 'move');

// Prefer sacrificing pieces in the middle / inner ring and in clusters (reduces future mill threats).
if (isCenterCell(target)) score += 900;
else if (isInInnerRing(target)) score += 450;

const aggBefore = getAggregationMetrics(state.board, target, aiPlayerId);
score += aggBefore.adj1 * 120;
score += aggBefore.adj2 * 60;

// Optional shallow lookahead (kept small to remain fast)
if (aiDifficulty >= 3 && winner === null) {
const d = (aiDifficulty === 4) ? 2: 1;
score += minimax(tempBoard, d, true, aiPlayerId, -Infinity, Infinity, piecesPlacedSoFar);
}

if (score > bestScore) {
bestScore = score;
bestTarget = target;
}
}
} else {
// Normal variant: capture the opponent piece that hurts them the most
let bestScore = -Infinity;
__MINIMAX_TT.clear();

for (const target of possibleTargets) {
const tempBoard = [...state.board];
tempBoard[target] = null;
let score = 0;

const opponentMillsBefore = getFormedMillsCount(state.board, humanPlayerId);
const opponentMillsAfter = getFormedMillsCount(tempBoard, humanPlayerId);
if (opponentMillsAfter < opponentMillsBefore) score += 5000;

if (isPieceInPotentialMill(state.board, target, humanPlayerId)) score += 3500;

const opponentCanFormMillBefore = canPlayerFormMillNextTurn(humanPlayerId, state.board, 'move');
const opponentCanFormMillAfter = canPlayerFormMillNextTurn(humanPlayerId, tempBoard, 'move');
if (opponentCanFormMillBefore && !opponentCanFormMillAfter) score += 2500;

if (aiDifficulty >= 3) {
// Small minimax refinement
const d = (aiDifficulty === 4) ? 3: aiDifficulty - 1;
score += minimax(tempBoard, d, false, humanPlayerId, -Infinity, Infinity, piecesPlacedSoFar);
} else {
score += evaluateBoard(tempBoard, aiPlayerId, null, 'move');
}

if (score > bestScore) {
bestScore = score;
bestTarget = target;
}
}
}

return bestTarget;
}

function countDoubleMillSetups(board, player) {
let hotSpots = {};
const lines = [];
for (let r = 0; r < SIZE; r++) {
for (let c = 0; c < SIZE - 2; c++) {
lines.push([r*SIZE+c, r*SIZE+c+1, r*SIZE+c+2]);
}
}
for (let c = 0; c < SIZE; c++) {
for (let r = 0; r < SIZE - 2; r++) {
lines.push([r*SIZE+c, (r+1)*SIZE+c, (r+2)*SIZE+c]);
}
}

for (const line of lines) {
let pCount = 0;
let emptyIdx = -1;
for (const idx of line) {
if (board[idx] === player) pCount++;
else if (board[idx] === null) emptyIdx = idx;
}
if (pCount === 2 && emptyIdx !== -1) {
hotSpots[emptyIdx] = (hotSpots[emptyIdx] || 0) + 1;
}
}

let doubleMillCount = 0;
for (const spot in hotSpots) {
if (hotSpots[spot] >= 2) {
doubleMillCount++;
}
}
return doubleMillCount;
}

function evaluateBoard(board, playerToEvaluate, simulatedWinner, phase) {
const opponent = 3 - playerToEvaluate;
const currentPhase = phase !== undefined ? phase: state.phase;

if (simulatedWinner !== null) {
// Always from AI's perspective: higher is better for aiPlayerId (winner = +, loser = -)
return simulatedWinner === playerToEvaluate ? 100000: -100000;
}

const playerPieces = board.filter(p => p === playerToEvaluate).length;
const opponentPieces = board.filter(p => p === opponent).length;
const playerMoves = countPlayerMoves(playerToEvaluate, board, currentPhase);
const opponentMoves = countPlayerMoves(opponent, board, currentPhase);

let score = 0;
score += (playerPieces - opponentPieces) * 200;
score += (playerMoves - opponentMoves) * 60;

const playerMills = getFormedMillsCount(board, playerToEvaluate);
const opponentMills = getFormedMillsCount(board, opponent);
score += (playerMills - opponentMills) * 150;

const playerPotentialMills = getPotentialMillsCount(board, playerToEvaluate);
const opponentPotentialMills = getPotentialMillsCount(board, opponent);
score += (playerPotentialMills - opponentPotentialMills) * 75;

const playerDoubleMills = countDoubleMillSetups(board, playerToEvaluate);
const opponentDoubleMills = countDoubleMillSetups(board, opponent);
score += (playerDoubleMills - opponentDoubleMills) * 5000;

if (canPlayerFormMillNextTurn(opponent, board, currentPhase)) score -= 1000;
if (canPlayerFormMillNextTurn(playerToEvaluate, board, currentPhase)) score += 900;

if (cfg().isInverseWin) {
// In inverse mode, fewer pieces and fewer moves are GOOD for AI => invert the "normal" score.
score = -score;

// Extra penalties: in Učči Bessif we want to AVOID creating mills (because it captures the opponent).
score -= playerMills * 650;

// Avoid center / inner ring + clustering in move phase too (lighter than placement heuristic).
board.forEach((cell, idx) => {
if (cell === playerToEvaluate) {
if (isCenterCell(idx)) score -= 700;
else if (isInInnerRing(idx)) score -= 350;
const agg = getAggregationMetrics(board, idx, playerToEvaluate);
score -= agg.adj1 * 240;
score -= agg.adj2 * 120;
}
});

// Huge penalty if AI is currently forced to make a mill (forced-mill rule active and a mill move exists).
if (cfg().forceMillMove && currentPhase === 'move') {
const millMoves = getPossibleMillMoves(playerToEvaluate, board, currentPhase);
if (millMoves.length > 0) {
score -= 50000;
}
}
}

return score;
}

function getFormedMillsCount(board, player) {
const seen = new Set();
let count = 0;
for (let i = 0; i < board.length; i++) {
if (board[i] === player) {
const mills = getFormedMills(i, player, board);
for (const mill of mills) {
const key = mill.join(',');
if (!seen.has(key)) {
count++;
seen.add(key);
}
}
}
}
return count;
}

function isGrouped(board, pieceIndex, player) {
const r = Math.floor(pieceIndex / SIZE);
const c = pieceIndex % SIZE;
const directions = [[-1,
0],
[1,
0],
[0,
-1],
[0,
1]];

for (const [dr, dc] of directions) {
const nr = r + dr;
const nc = c + dc;
if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE) {
const neighborIndex = nr * SIZE + nc;
if (board[neighborIndex] === player) {
return true;
}
}
}
return false;
}

function canPlayerFormMillByMoving(player, board) {
for (let from = 0; from < SIZE * SIZE; from++) {
if (board[from] === player) {
for (let to = 0; to < SIZE * SIZE; to++) {
if (board[to] === null && isAdjacent(from, to)) {
const tempBoard = simulateMove(board, {
from, to
}, player);
if (findAllMills(board, tempBoard, from, to, player).length > 0) {
return true;
}
}
}
}
}
return false;
}

function canPlayerFormMillNextTurn(player, board, phase) {
return getPossibleMillMoves(player, board, phase).length > 0;
}

function getPotentialMillsCount(board, player) {
let count = 0;
const lines = [];
for (let r = 0; r < SIZE; r++) {
for (let c = 0; c < SIZE - 2; c++) {
lines.push([r*SIZE+c, r*SIZE+c+1, r*SIZE+c+2]);
}
}
for (let c = 0; c < SIZE; c++) {
for (let r = 0; r < SIZE - 2; r++) {
lines.push([r*SIZE+c, (r+1)*SIZE+c, (r+2)*SIZE+c]);
}
}

for (const line of lines) {
let pCount = 0;
let eCount = 0;
for (const idx of line) {
if (board[idx] === player) pCount++;
else if (board[idx] === null) eCount++;
}
if (pCount === 2 && eCount === 1) {
// Ensure this window is not part of a longer line of player pieces (would form 4+ in a row, not a valid mill)
const isHorizontal = (Math.floor(line[0] / SIZE) === Math.floor(line[1] / SIZE));
let cellBefore = -1,
cellAfter = -1;
if (isHorizontal) {
const r = Math.floor(line[0] / SIZE);
const cStart = line[0] % SIZE;
const cEnd = line[2] % SIZE;
if (cStart > 0) cellBefore = r * SIZE + (cStart - 1);
if (cEnd < SIZE - 1) cellAfter = r * SIZE + (cEnd + 1);
} else {
const c = line[0] % SIZE;
const rStart = Math.floor(line[0] / SIZE);
const rEnd = Math.floor(line[2] / SIZE);
if (rStart > 0) cellBefore = (rStart - 1) * SIZE + c;
if (rEnd < SIZE - 1) cellAfter = (rEnd + 1) * SIZE + c;
}
// Only count if the adjacent cells won't extend this to a 4+ chain
const beforeOk = cellBefore === -1 || board[cellBefore] !== player;
const afterOk = cellAfter === -1 || board[cellAfter] !== player;
if (beforeOk && afterOk) count++;
}
}
return count;
}



// Minimax cache (cleared at each AI decision) to keep the AI responsive.
const __MINIMAX_TT = new Map();
function boardKeyFast(board) {
let s = '';
for (let i = 0; i < board.length; i++) {
const v = board[i];
s += (v === null) ? '0': (v === 1 ? '1': '2');
}
return s;
}
function minimax(currentBoard, depth, isMaximizingPlayer, currentPlayer, alpha, beta, piecesPlaced) {
// piecesPlaced = total pieces ever placed (doesn't decrease on capture)
const currentPiecesPlaced = piecesPlaced !== undefined ? piecesPlaced: (currentBoard.filter(p => p !== null).length + 0);
const currentPhase = currentPiecesPlaced < PIECES * 2 ? 'placement': 'move';

// Transposition table
const ttKey = `${depth}|${isMaximizingPlayer ? 1: 0}|${currentPlayer}|${currentPiecesPlaced}|${boardKeyFast(currentBoard)}`;
const cached = __MINIMAX_TT.get(ttKey);
if (cached !== undefined) return cached;

const simulatedWinner = getWinnerInState(currentBoard, currentPhase);
if (depth === 0 || simulatedWinner !== null) {
const leafVal = (currentPhase === 'placement')
? evaluatePlacement(currentBoard, aiPlayerId): evaluateBoard(currentBoard, aiPlayerId, simulatedWinner, currentPhase);
__MINIMAX_TT.set(ttKey, leafVal);
return leafVal;
}

const opponentPlayer = 3 - currentPlayer;
const possibleMoves = generateAllPossibleMoves(currentPlayer, currentBoard, currentPhase);
if (possibleMoves.length === 0) {
const noMoveVal = (currentPhase === 'placement')
? evaluatePlacement(currentBoard, aiPlayerId): evaluateBoard(currentBoard, aiPlayerId, opponentPlayer, currentPhase);
__MINIMAX_TT.set(ttKey, noMoveVal);
return noMoveVal;
}

let bestEval = isMaximizingPlayer ? -Infinity: Infinity;

for (const move of possibleMoves) {
const newBoard = simulateMove(currentBoard, move, currentPlayer);
const from = move.from !== undefined ? move.from: move.to;
const formedMills = findAllMills(currentBoard, newBoard, from, move.to, currentPlayer);

const nextPiecesPlaced = currentPhase === 'placement' ? currentPiecesPlaced + 1: currentPiecesPlaced;

let evaluation;

if (formedMills.length > 0) {
// A capture happens. The piece that gets removed is ALWAYS from the opponent of the mover.
// In normal rules: the mover chooses which opponent piece to capture.
// In Učči Bessif: the opponent chooses which of THEIR OWN pieces will be captured.
const victim = opponentPlayer;
const chooser = cfg().isInverseWin ? opponentPlayer: currentPlayer;
const chooserIsAI = chooser === aiPlayerId;

const capturablePieces = [];
for (let i = 0; i < newBoard.length; i++) {
if (newBoard[i] === victim) capturablePieces.push(i);
}

if (capturablePieces.length > 0) {
let captureEval = chooserIsAI ? -Infinity: Infinity;

for (const pieceToRemove of capturablePieces) {
const boardAfterCapture = [...newBoard];
boardAfterCapture[pieceToRemove] = null;

const val = minimax(
boardAfterCapture,
depth - 1,
!isMaximizingPlayer,
opponentPlayer,
alpha,
beta,
nextPiecesPlaced
);

if (chooserIsAI) captureEval = Math.max(captureEval, val);
else captureEval = Math.min(captureEval, val);
}

evaluation = captureEval;
} else {
evaluation = minimax(newBoard, depth - 1, !isMaximizingPlayer, opponentPlayer, alpha, beta, nextPiecesPlaced);
}
} else {
evaluation = minimax(newBoard, depth - 1, !isMaximizingPlayer, opponentPlayer, alpha, beta, nextPiecesPlaced);
}

if (isMaximizingPlayer) {
bestEval = Math.max(bestEval, evaluation);
alpha = Math.max(alpha, bestEval);
} else {
bestEval = Math.min(bestEval, evaluation);
beta = Math.min(beta, bestEval);
}
if (beta <= alpha) break;
}

__MINIMAX_TT.set(ttKey, bestEval);
return bestEval;
}

function simulateMove(board, move, player) {
const newBoard = [...board];
if (move.from !== undefined) {
newBoard[move.from] = null;
}
newBoard[move.to] = player;
return newBoard;
}

function generateAllPossibleMoves(player, board, phase) {
const moves = [];
if (phase === 'placement') {
for (let i = 0; i < SIZE * SIZE; i++) {
if (board[i] === null) {
const tempBoard = simulateMove(board, {
to: i
}, player);
if (!formsForbiddenPlacementAlignment(i, player, tempBoard)) {
moves.push({
to: i
});
}
}
}
} else {
const millMoves = getPossibleMillMoves(player, board, phase);
if (cfg().forceMillMove && millMoves.length > 0) {
return millMoves;
}
for (let i = 0; i < SIZE * SIZE; i++) {
if (board[i] === player) {
for (let j = 0; j < SIZE * SIZE; j++) {
if (board[j] === null && isAdjacent(i, j)) {
moves.push({
from: i, to: j
});
}
}
}
}
}
return moves;
}

function generateAllPossibleMovesOrdered(player, board, phase) {
const moves = generateAllPossibleMoves(player, board, phase);
if (phase !== 'move') return moves;
const opponent = 3 - player;
const millMoves = new Set();
moves.forEach(m => {
const tempB = simulateMove(board, m, player);
if (findAllMills(board, tempB, m.from, m.to, player).length > 0) millMoves.add(JSON.stringify(m));
});
const opponentMillTargets = getPossibleMillMoves(opponent,
board,
'move').map(m => m.to);
const ordered = [], rest = [];
moves.forEach(m => {
if (millMoves.has(JSON.stringify(m))) ordered.unshift(m);
else if (opponentMillTargets.includes(m.to)) ordered.push(m);
else rest.push(m);
});
return [...ordered, ...rest];
}

function getWinnerInState(board,
phase) {
// Accept explicit phase to handle captures correctly (captures reduce piece count below PIECES*2 even in move phase)
const currentPhase = phase !== undefined ? phase: (board.filter(p => p !== null).length >= PIECES * 2 ? 'move': 'placement');
if (currentPhase !== 'move') return null;

const p1Pieces = board.filter(p => p === 1).length;
const p2Pieces = board.filter(p => p === 2).length;
const p1CanMove = canPlayerMove(1, board);
const p2CanMove = canPlayerMove(2, board);

const p1Loses = p1Pieces < 3 || !p1CanMove;
const p2Loses = p2Pieces < 3 || !p2CanMove;

if (cfg().isInverseWin) {
// Inverse win: the player who "loses" (has <3 pieces or can't move) actually WINS
if (p1Loses) return 1;
if (p2Loses) return 2;
} else {
// Normal win: the player who causes the opponent to "lose" wins
if (p1Loses) return 2;
if (p2Loses) return 1;
}
return null;
}

function aiFindBestMove() {
const player = aiPlayerId;
const opponent = humanPlayerId;
const currentPhase = state.phase;
const isInverse = cfg().isInverseWin;

const cmpVec = (a, b) => {
for (let i = 0; i < Math.min(a.length, b.length); i++) {
if (a[i] < b[i]) return -1;
if (a[i] > b[i]) return 1;
}
return 0;
};

// This hardcoded opening is only for the NORMAL win variant.
if (!isInverse && aiDifficulty === 4 && currentPhase === 'placement') {
const turnNumber = state.board.filter(p => p !== null).length;
if (turnNumber < 2 && state.board[12] === null) {
return {
to: 12
};
}
if (turnNumber < 4 && state.board[12] === aiPlayerId) {
const preferredCorners = [6,
8,
16,
18];
for (const corner of preferredCorners) {
if (state.board[corner] === null) return {
to: corner
};
}
}
}

let possibleMoves = generateAllPossibleMoves(player, state.board, currentPhase);
if (possibleMoves.length === 0) return null;

// ── Règle : exclure le pion joué 3× de suite (sauf deadlock) ──
possibleMoves = filterConsecutiveMoves(player, possibleMoves);

// ===============================
// Učči Bessif: anti-milieu + anti-agrégation + anti-moulins ouverts
// ===============================
if (isInverse) {
const beforePotential = getPotentialMillsCount(state.board, player);
const beforeDouble = countDoubleMillSetups(state.board, player);

if (currentPhase === 'placement') {
const annotated = possibleMoves.map(move => {
const newBoard = simulateMove(state.board, move, player);
const afterPotential = getPotentialMillsCount(newBoard, player);
const afterDouble = countDoubleMillSetups(newBoard, player);

const inCenter = isCenterCell(move.to);
const inInnerRing = isInInnerRing(move.to);

const agg = getAggregationMetrics(newBoard, move.to, player);
const canMillSoon = canPlayerFormMillByMoving(player, newBoard);

const vec = [
canMillSoon ? 1: 0,
afterDouble - beforeDouble,
afterPotential - beforePotential,
inCenter ? 1: 0,
inInnerRing ? 1: 0,
agg.adj1,
agg.adj2
];

return {
move,
vec,
canMillSoon,
deltaPotential: afterPotential - beforePotential,
deltaDouble: afterDouble - beforeDouble,
inCenter,
inInnerRing,
agg1: agg.adj1,
agg2: agg.adj2
};
});

// Strict filter first
let candidates = annotated.filter(x =>
x.deltaPotential <= 0 &&
x.deltaDouble <= 0 &&
!x.canMillSoon &&
!x.inCenter &&
!x.inInnerRing &&
x.agg1 === 0 &&
x.agg2 === 0
);

if (candidates.length === 0) {
// Fallback: keep the safest "risk vector" moves
annotated.sort((a, b) => cmpVec(a.vec, b.vec));
const bestVec = annotated[0].vec;
candidates = annotated.filter(x => cmpVec(x.vec, bestVec) === 0);
}

possibleMoves = candidates.map(x => x.move);

} else {
// Move phase
const mustMakeMill = cfg().forceMillMove &&
getPossibleMillMoves(player, state.board, 'move').length > 0;

const annotated = possibleMoves.map(move => {
const newBoard = simulateMove(state.board, move, player);
const afterPotential = getPotentialMillsCount(newBoard, player);
const afterDouble = countDoubleMillSetups(newBoard, player);

const inCenter = isCenterCell(move.to);
const inInnerRing = isInInnerRing(move.to);

const agg = getAggregationMetrics(newBoard, move.to, player);
const canMillSoon = canPlayerFormMillByMoving(player, newBoard);

// Encourage giving the opponent mill opportunities (they can force a sacrifice of our pieces).
const oppMillMoves = getPossibleMillMoves(opponent, newBoard, 'move').length;

const vec = [
mustMakeMill ? 0: (canMillSoon ? 1: 0),
afterDouble - beforeDouble,
afterPotential - beforePotential,
inCenter ? 1: 0,
inInnerRing ? 1: 0,
agg.adj1,
agg.adj2,
-oppMillMoves
];

return {
move,
vec,
mustMakeMill,
canMillSoon,
deltaPotential: afterPotential - beforePotential,
deltaDouble: afterDouble - beforeDouble,
inCenter,
inInnerRing,
agg1: agg.adj1,
agg2: agg.adj2
};
});

let candidates = annotated.filter(x =>
!x.inCenter &&
!x.inInnerRing &&
x.agg1 === 0 &&
x.agg2 === 0 &&
(x.mustMakeMill || (x.deltaPotential <= 0 && x.deltaDouble <= 0 && !x.canMillSoon))
);

if (candidates.length === 0) {
annotated.sort((a, b) => cmpVec(a.vec, b.vec));
const bestVec = annotated[0].vec;
candidates = annotated.filter(x => cmpVec(x.vec, bestVec) === 0);
}

possibleMoves = candidates.map(x => x.move);
}
}

// Normal variant: try to make a mill / block mills quickly in move phase
if (currentPhase === 'move' && !isInverse) {
const millMoves = getPossibleMillMoves(player, state.board, 'move');
if (millMoves.length > 0) {
return millMoves[Math.floor(Math.random() * millMoves.length)];
}
const opponentMillMoves = getPossibleMillMoves(opponent, state.board, 'move');
if (opponentMillMoves.length > 0) {
const blockingMoveTargets = opponentMillMoves.map(move => move.to);
const availableBlockingMoves = possibleMoves.filter(move => blockingMoveTargets.includes(move.to));
if (availableBlockingMoves.length > 0) {
return availableBlockingMoves[Math.floor(Math.random() * availableBlockingMoves.length)];
}
}
}

if (aiDifficulty === 1) {
return possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
}

let depth = {
1: 1,
2: 2,
3: 4,
4: 5
}[aiDifficulty] || 2;
if (currentPhase === 'placement' && depth > 4) depth = 4;
if (aiDifficulty === 4 && state.phase === 'move' && state.board.filter(p => p !== null).length <= 10) {
depth++;
}

// Clear cache each decision for responsiveness
__MINIMAX_TT.clear();

// ── Anti-boucle IA vs IA : exclure les positions déjà vues ≥ 3 fois ──
if (forbiddenBoardPositions.size > 0) {
const nonRepeating = possibleMoves.filter(m => {
const nb = simulateMove(state.board, m, player);
return !forbiddenBoardPositions.has(nb.map(v => v || 0).join(''));
});
if (nonRepeating.length > 0) possibleMoves = nonRepeating;
}

let bestMove = null;
let bestScore = -Infinity;
let alpha = -Infinity;
let beta = Infinity;

// piecesPlaced = pieces on board + captured (total ever placed)
const piecesPlacedSoFar = state.board.filter(p => p !== null).length + state.captured[1] + state.captured[2];

for (const move of possibleMoves) {
const newBoard = simulateMove(state.board, move, player);
const nextPiecesPlaced = currentPhase === 'placement' ? piecesPlacedSoFar + 1: piecesPlacedSoFar;

// Petit jitter aléatoire pour casser les ex-aequo et éviter les cycles
const jitter = (Math.random() * 4 - 2);
const score = minimax(newBoard, depth - 1, false, opponent, alpha, beta, nextPiecesPlaced) + jitter;

if (score > bestScore) {
bestScore = score;
bestMove = move;
alpha = Math.max(alpha, bestScore);
}
}

return bestMove || possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
}

// ==========================================
// ===== NEW FEATURES: SOUND, THEME, SAVE, SPECTATOR, AI+ =====
// ==========================================

// --- GLOBALS ---
let soundEnabled = true;
const THEMES = ['kabylie',
'desert',
'nuit',
'glass',
'contrast',
'modern',
'modern-dark'];
const THEME_ICONS = ['ⵣ',
'🏜️',
'🌙',
'💎',
'⚡',
'✨',
'🌑'];
let currentTheme = THEMES.indexOf('kabylie'); // default: kabylie
let moveLog = []; // for move history log
let spectatorDelay = 700;

// --- ANTI-BOUCLE IA vs IA ---
// Mémorise les positions déjà vues pour briser les cycles répétitifs
let boardPositionHistory = new Map(); // signature → nb d'occurrences
let forbiddenBoardPositions = new Set(); // positions vues ≥ 3 fois (évitées par l'IA)

// --- MODE GLISSER-DÉPOSER ---
let dragMode = false;
let _dragActive = false;
let _dragFromIdx = null;
let _dragOverIdx = null;
let _dragStartX = 0;
let _dragStartY = 0;
let _dragMoved = false;
let _dragSuppressClick = false;

// Pointer drag internals (smooth)
let _dragPointerId = null;
let _dragRaf = 0;
let _dragLastX = 0;
let _dragLastY = 0;
let _dragTargets = null; // Set<int> of allowed target indices for current drag
let _dragVisualReady = false;

const _DRAG_THRESHOLD = 3; // px min pour considérer que c'est un glissement (plus réactif)

// --- IMPROVED SOUND SYSTEM (Web Audio API with dynamics + reverb) ---
let __audio = null;

function ensureAudioGraph() {
const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
if (!AudioContextCtor) return null;
if (__audio?.ctx) return __audio;
const ctx = new AudioContextCtor();
const master = ctx.createGain();
master.gain.value = 0.85;
const compressor = ctx.createDynamicsCompressor();
compressor.threshold.value = -22;
compressor.knee.value = 24;
compressor.ratio.value = 10;
compressor.attack.value = 0.004;
compressor.release.value = 0.18;
const delayNode = ctx.createDelay(0.35);
delayNode.delayTime.value = 0.16;
const feedback = ctx.createGain();
feedback.gain.value = 0.18;
const wet = ctx.createGain();
wet.gain.value = 0.16;
delayNode.connect(feedback);
feedback.connect(delayNode);
delayNode.connect(wet);
master.connect(compressor);
wet.connect(compressor);
compressor.connect(ctx.destination);
__audio = {
ctx,
master,
wetSend: delayNode,
wetGain: wet
};
return __audio;
}

function audioNow() {
const a = ensureAudioGraph();
return a ? a.ctx.currentTime: 0;
}

function audioEnv(gainNode, t0, a = 0.005, d = 0.09, s = 0.0, r = 0.12, peak = 0.6) {
const g = gainNode.gain;
g.cancelScheduledValues(t0);
g.setValueAtTime(0.0001, t0);
g.exponentialRampToValueAtTime(Math.max(0.0002, peak), t0 + a);
g.exponentialRampToValueAtTime(Math.max(0.0002, peak * Math.max(0.001, s)), t0 + a + d);
g.exponentialRampToValueAtTime(0.0001, t0 + a + d + r);
}

function addNoiseBurst(t0, duration = 0.08, peak = 0.35) {
const a = ensureAudioGraph(); if (!a) return;
const ctx = a.ctx;
const buf = ctx.createBuffer(1, Math.floor(ctx.sampleRate * duration), ctx.sampleRate);
const data = buf.getChannelData(0);
for (let i = 0; i < data.length; i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
const src = ctx.createBufferSource();
src.buffer = buf;
const filt = ctx.createBiquadFilter();
filt.type = 'highpass';
filt.frequency.value = 700;
const g = ctx.createGain();
src.connect(filt); filt.connect(g); g.connect(a.master); g.connect(a.wetSend);
audioEnv(g, t0, 0.001, 0.03, 0.0, 0.08, peak);
src.start(t0); src.stop(t0 + duration + 0.02);
}

function audioTone(t0, f0, duration = 0.11, type = 'sine', peak = 0.35, pan = 0) {
const a = ensureAudioGraph(); if (!a) return;
const ctx = a.ctx;
const osc = ctx.createOscillator();
osc.type = type;
osc.frequency.setValueAtTime(f0, t0);
const filt = ctx.createBiquadFilter();
filt.type = 'lowpass';
filt.frequency.setValueAtTime(Math.min(6000, Math.max(900, f0*6)), t0);
const g = ctx.createGain();
const p = ctx.createStereoPanner ? ctx.createStereoPanner(): null;
if (p) p.pan.setValueAtTime(pan, t0);
osc.connect(filt); filt.connect(g);
if (p) {
g.connect(p); p.connect(a.master); p.connect(a.wetSend);
} else {
g.connect(a.master); g.connect(a.wetSend);
}
audioEnv(g, t0, 0.004, duration*0.35, 0.12, duration*0.6, peak);
osc.start(t0); osc.stop(t0 + duration + 0.04);
}

function audioChord(t0, freqs, duration = 0.22) {
freqs.forEach((f, i) => audioTone(t0 + i*0.03, f, duration, 'triangle', 0.32, (i-1)*0.25));
}

function playSound(type) {
if (!soundEnabled) return;
try {
const a = ensureAudioGraph(); if (!a) return;
if (a.ctx.state === 'suspended') a.ctx.resume();
const t0 = audioNow();
switch (type) {
case 'place':
audioTone(t0, 420, 0.09, 'sine', 0.24, -0.12);
audioTone(t0+0.04, 650, 0.07, 'sine', 0.18, 0.12);
break;
case 'move':
audioTone(t0, 360, 0.08, 'triangle', 0.18, -0.08);
audioTone(t0+0.06, 520, 0.09, 'triangle', 0.15, 0.08);
break;
case 'select':
audioTone(t0, 700, 0.06, 'sine', 0.12, 0);
break;
case 'undo':
audioTone(t0, 520, 0.07, 'sine', 0.14, 0);
audioTone(t0+0.08, 360, 0.09, 'sine', 0.12, 0);
break;
case 'mill':
audioChord(t0, [523.25, 659.25, 783.99], 0.22);
break;
case 'capture':
addNoiseBurst(t0, 0.07, 0.38);
audioTone(t0+0.02, 220, 0.12, 'sawtooth', 0.14, 0);
break;
case 'victory':
audioChord(t0, [392.0, 523.25, 659.25], 0.28);
audioChord(t0+0.22, [440.0, 587.33, 739.99], 0.30);
break;
case 'phase':
audioTone(t0, 330, 0.14, 'triangle', 0.16, -0.15);
audioTone(t0+0.10, 550, 0.14, 'triangle', 0.16, 0.15);
break;
case 'error':
audioTone(t0, 180, 0.14, 'sawtooth', 0.10, 0);
addNoiseBurst(t0+0.03, 0.09, 0.22);
break;
default:
audioTone(t0, 440, 0.06, 'sine', 0.08, 0);
}
} catch (e) {
/* silently ignore audio errors */
}
}

// --- THEME SYSTEM ---
function applyTheme(themeIndex) {
const theme = THEMES[themeIndex] || 'kabylie';
document.documentElement.setAttribute('data-theme', theme);
const btn = document.getElementById('theme-btn');
if (btn) {
const thLabel = (typeof translations !== 'undefined' && translations[currentLanguage] && translations[currentLanguage].btnTheme) || 'Thème';
btn.textContent = '';
btn.appendChild(document.createTextNode((THEME_ICONS[themeIndex] || 'ⵣ') + ' '));
const span = document.createElement('span');
span.className = 'btn-label';
span.setAttribute('data-i18n', 'btnTheme');
span.textContent = thLabel;
btn.appendChild(span);
}
try {
localStorage.setItem('tiddas_theme', String(themeIndex));
} catch(e) {}
}
function cycleTheme() {
currentTheme = (currentTheme + 1) % THEMES.length;
applyTheme(currentTheme);
}

// --- SOUND TOGGLE ---
function toggleSound() {
soundEnabled = !soundEnabled;
const btn = document.getElementById('sound-btn');
if (btn) {
const sndLabel = (typeof translations !== 'undefined' && translations[currentLanguage] && translations[currentLanguage].btnSound) || 'Son';
btn.textContent = '';
btn.appendChild(document.createTextNode(soundEnabled ? '🔊 ': '🔇 '));
const span = document.createElement('span');
span.className = 'btn-label';
span.setAttribute('data-i18n', 'btnSound');
span.textContent = sndLabel;
btn.appendChild(span);
btn.classList.toggle('sound-off', !soundEnabled);
}
try {
localStorage.setItem('tiddas_sound', soundEnabled ? '1': '0');
} catch(e) {}
}

// --- MODE GLISSER-DÉPOSER ---
function loadDragPref() {
try {
dragMode = localStorage.getItem('tiddas_drag') === '1';
} catch(e) {}
}
function saveDragPref() {
try {
localStorage.setItem('tiddas_drag', dragMode ? '1': '0');
} catch(e) {}
}
function toggleDragMode() {
dragMode = !dragMode;
saveDragPref();
applyDragBtn();
// Rebind le plateau si une partie est en cours
if (state && !state.winner) renderBoard();
}
function applyDragBtn() {
const btn = document.getElementById('drag-btn');
if (!btn) return;
btn.classList.toggle('active', dragMode);
btn.setAttribute('aria-pressed', dragMode ? 'true': 'false');
if (boardDiv) boardDiv.classList.toggle('drag-mode-active', dragMode);
}


// Retourne l'index de la cellule sous le point (x, y), ou null
function _cellIdxFromPoint(x, y) {
// pointer-events:none sur #drag-ghost → elementFromPoint le traverse nativement.
// Pas besoin de display:none (qui causait un scintillement à chaque frame).
const el = document.elementFromPoint(x, y);
if (!el) return null;
const cell = el.classList?.contains('cell') ? el: el.closest?.('.cell');
if (!cell) return null;
const idx = parseInt(cell.dataset.idx, 10);
return Number.isFinite(idx) ? idx: null;
}

function _clearDragUI(fromIdx) {
// Stop any pending RAF
if (_dragRaf) {
cancelAnimationFrame(_dragRaf); _dragRaf = 0;
}

// remove drag-over highlight
if (_dragOverIdx !== null) {
boardDiv.children[_dragOverIdx]?.classList.remove('drag-over');
_dragOverIdx = null;
}
// remove dragging visual on source stone
if (fromIdx !== null && fromIdx !== undefined) {
const srcStone = boardDiv.children[fromIdx]?.querySelector('.stone');
if (srcStone) srcStone.classList.remove('dragging');
}
// Filet de sécurité : nettoyer possible-move et selected sur toutes les cellules
// (utile si renderBoard() n'est pas appelé après, ex: pointercancel inattendu)
boardDiv.querySelectorAll('.cell.possible-move').forEach(c => c.classList.remove('possible-move'));
boardDiv.querySelectorAll('.cell.selected').forEach(c => c.classList.remove('selected'));
boardDiv.querySelectorAll('.stone.selected').forEach(s => s.classList.remove('selected'));
// hide ghost
const ghost = document.getElementById('drag-ghost');
if (ghost) {
ghost.classList.remove('visible');
ghost.style.transform = 'translate(-9999px, -9999px) scale(1.15)';
}
_dragVisualReady = false;
}

function _computeTargetsFrom(fromIdx) {
// Si l'UI affiche déjà les coups possibles (pion sélectionné via clic), on réutilise.
if (state.selected === fromIdx) {
const existing = new Set();
boardDiv.querySelectorAll('.cell.possible-move').forEach(c => {
const idx = parseInt(c.dataset.idx, 10);
if (Number.isFinite(idx)) existing.add(idx);
});
if (existing.size) return existing;
}
const targets = new Set();
for (let i = 0; i < SIZE * SIZE; i++) {
if (state.board[i] === null && isAdjacent(fromIdx, i)) targets.add(i);
}
return targets;
}

function _applyDragSelectionUI(fromIdx) {
// MAJ visuelle uniquement : pas de renderBoard() (beaucoup plus fluide)
boardDiv.querySelectorAll('.cell.selected').forEach(c => c.classList.remove('selected'));
boardDiv.querySelectorAll('.stone.selected').forEach(s => s.classList.remove('selected'));
boardDiv.querySelectorAll('.cell.possible-move').forEach(c => c.classList.remove('possible-move'));

const fromCell = boardDiv.children[fromIdx];
if (fromCell) {
fromCell.classList.add('selected');
fromCell.querySelector('.stone')?.classList.add('selected');
}

const targets = _computeTargetsFrom(fromIdx);
targets.forEach(idx => boardDiv.children[idx]?.classList.add('possible-move'));
return targets;
}

function _ensureDragVisuals(x, y) {
if (_dragVisualReady) return;
const fromIdx = _dragFromIdx;
if (fromIdx === null) return;

const srcStone = boardDiv.children[fromIdx]?.querySelector('.stone');
if (srcStone) srcStone.classList.add('dragging');

const ghost = document.getElementById('drag-ghost');
if (ghost) {
const rect = srcStone ? srcStone.getBoundingClientRect(): null;
ghost.style.width = rect ? rect.width + 'px': '48px';
ghost.style.height = rect ? rect.height + 'px': '48px';

ghost.className = `player${state.board[fromIdx]}`;
ghost.classList.add('visible');
// Transform GPU composite : pas de reflow, fluide même à 120 Hz
ghost.style.transform = 'translate(calc(' + x + 'px - 50%), calc(' + y + 'px - 50%)) scale(1.15)';
}
_dragVisualReady = true;
}

function _dragUpdateFrame() {
_dragRaf = 0;
if (!_dragActive || !_dragMoved) return;

const x = _dragLastX,
y = _dragLastY;
_ensureDragVisuals(x, y);

const ghost = document.getElementById('drag-ghost');
if (ghost && ghost.classList.contains('visible')) {
// Transform GPU composite : pas de reflow
ghost.style.transform = 'translate(calc(' + x + 'px - 50%), calc(' + y + 'px - 50%)) scale(1.15)';
}

const idx = _cellIdxFromPoint(x, y);
const nextOver = (idx !== null && _dragTargets && _dragTargets.has(idx)) ? idx: null;

if (nextOver !== _dragOverIdx) {
if (_dragOverIdx !== null) boardDiv.children[_dragOverIdx]?.classList.remove('drag-over');
if (nextOver !== null) boardDiv.children[nextOver]?.classList.add('drag-over');
_dragOverIdx = nextOver;
}
}

// Démarre un glissement depuis la cellule fromIdx
function _onDragStart(e, fromIdx) {
if (!dragMode) return;
if (state.winner || state.phase !== 'move' || state.captureMode) return;
if (gameMode === 'spectator') return;

// Ignore non-primary pointers (multi-touch)
if (e.isPrimary === false) return;

const actor = state.turn;
if (gameMode === 'ai' && actor === aiPlayerId) return;
if (state.board[fromIdx] !== actor) return;
if (isConsecutiveBlocked(actor, fromIdx)) return;

_dragActive = true;
_dragFromIdx = fromIdx;
_dragOverIdx = null;
_dragMoved = false;
_dragTargets = null;
_dragVisualReady = false;

_dragPointerId = (typeof e.pointerId === 'number') ? e.pointerId: null;
_dragStartX = e.clientX;
_dragStartY = e.clientY;
_dragLastX = e.clientX;
_dragLastY = e.clientY;

// Pointer capture for reliable move tracking
try {
e.currentTarget?.setPointerCapture?.(e.pointerId);
} catch (_) {}

window.addEventListener('pointermove', _onDragMove, {
passive: false
});
window.addEventListener('pointerup', _onDragEnd, {
once: true
});
window.addEventListener('pointercancel', _onDragCancel, {
once: true
});
}

function _onDragMove(e) {
if (!_dragActive) return;
if (_dragPointerId !== null && e.pointerId !== _dragPointerId) return;

// Utiliser le dernier événement coalescé pour la position la plus récente
// (getCoalescedEvents retourne tous les points intermédiaires — crucial sur mobile haute fréquence)
const events = e.getCoalescedEvents ? e.getCoalescedEvents(): [e];
const last = events[events.length - 1] || e;
_dragLastX = last.clientX;
_dragLastY = last.clientY;

const dx = _dragLastX - _dragStartX;
const dy = _dragLastY - _dragStartY;

if (!_dragMoved && Math.hypot(dx, dy) >= _DRAG_THRESHOLD) {
_dragMoved = true;

// Sélection logique nécessaire pour handleMove()
state.selected = _dragFromIdx;

// Crée les coups possibles sans renderBoard()
_dragTargets = _applyDragSelectionUI(_dragFromIdx);
}

if (_dragMoved) {
if (e.cancelable) e.preventDefault();
// Un seul RAF par frame : pas de calculs redondants
if (!_dragRaf) _dragRaf = requestAnimationFrame(_dragUpdateFrame);
}
}

function _onDragEnd(e) {
window.removeEventListener('pointermove', _onDragMove);
window.removeEventListener('pointercancel', _onDragCancel);

if (!_dragActive) return;
_dragActive = false;

const fromIdx = _dragFromIdx;
_dragFromIdx = null;

// Si ce n'était pas un glissement, laisser le click normal se faire
if (!_dragMoved) {
_dragPointerId = null;
_clearDragUI(fromIdx);
return;
}

_dragSuppressClick = true;
setTimeout(() => {
_dragSuppressClick = false;
}, 220);

// Drop
const raw = _cellIdxFromPoint(e.clientX, e.clientY);
const toIdx = (raw !== null && _dragTargets && _dragTargets.has(raw)) ? raw: null;

_dragPointerId = null;

_clearDragUI(fromIdx);

if (toIdx !== null && fromIdx !== null) {
// Utilise la logique existante (mill obligatoire, etc.)
moveHistory.push(deepCopy(state));
handleMove(toIdx);
} else {
// Dépôt invalide : garder la sélection (plus agréable)
state.selected = fromIdx;
renderBoard();
updateStatus();
}
}

function _onDragCancel() {
window.removeEventListener('pointermove', _onDragMove);
window.removeEventListener('pointerup', _onDragEnd);

if (!_dragActive) return;
_dragActive = false;

const fromIdx = _dragFromIdx;
_dragFromIdx = null;
_dragPointerId = null;

_clearDragUI(fromIdx);

// Restaure la sélection sur le pion source
state.selected = fromIdx;
renderBoard();
updateStatus();
}

// --- SAVE / LOAD GAME (localStorage) ---
const SAVE_KEY = 'tiddas_save_v2';
function saveGame() {
  // Online: broadcast snapshot after each local change
if (!state || gameMode === 'spectator') return;
try {
const save = {
state,
variant,
gameMode,
aiDifficulty,
humanPlayerId,
player1Name,
player2Name,
moveLog: moveLog.slice(-20)
};
localStorage.setItem(SAVE_KEY, JSON.stringify(save));
  // Sync online snapshot (polling mode)
  if (gameMode === 'online') { try { onlineSendState('autosave'); } catch(_) {} }
} catch (e) {}
}
function clearSave() {
try {
localStorage.removeItem(SAVE_KEY);
} catch(e) {}
}

function loadAndResume() {
try {
const raw = localStorage.getItem(SAVE_KEY);
if (!raw) return;
const save = JSON.parse(raw);

// Restore meta
variant = save.variant || variant;
// Validation : si la variante est inconnue, utiliser la valeur par défaut
if (!variant || !variantConfig[variant]) variant = 'TIDDEST-no-diag';
gameMode = save.gameMode || gameMode;
aiDifficulty = (save.aiDifficulty ?? aiDifficulty);
humanPlayerId = (save.humanPlayerId ?? humanPlayerId);
aiPlayerId = gameMode === 'ai' ? (3 - humanPlayerId): null;
player1Name = save.player1Name || player1Name;
player2Name = save.player2Name || player2Name;

// Restore state with forward-compatible defaults (prevents broken saves after updates)
const defaults = initState();
const s = save.state || {};
const merged = {
...defaults,
...s,
counts: {
...defaults.counts,
...(s.counts || {})
},
captured: {
...defaults.captured,
...(s.captured || {})
}
};

// Sanitize board size/content
if (!Array.isArray(merged.board)) merged.board = defaults.board.slice();
if (merged.board.length !== SIZE * SIZE) {
const fixed = Array(SIZE * SIZE).fill(null);
const src = merged.board;
for (let i = 0; i < Math.min(src.length, fixed.length); i++) fixed[i] = (src[i] === 1 || src[i] === 2) ? src[i]: null;
merged.board = fixed;
} else {
// normalize values
merged.board = merged.board.map(v => (v === 1 || v === 2) ? v: null);
}

// Sanitize primitive fields
merged.turn = (merged.turn === 1 || merged.turn === 2) ? merged.turn: defaults.turn;
merged.phase = (merged.phase === 'placement' || merged.phase === 'move') ? merged.phase: defaults.phase;
merged.captureMode = !!merged.captureMode;
merged.pendingCaptures = Number.isFinite(merged.pendingCaptures) ? merged.pendingCaptures: 0;
merged.turnForCapture = (merged.turnForCapture === 1 || merged.turnForCapture === 2) ? merged.turnForCapture: null;
merged.selected = Number.isInteger(merged.selected) ? merged.selected: null;
merged.highlightedMills = Array.isArray(merged.highlightedMills) ? merged.highlightedMills: [];
merged.winner = (merged.winner === 1 || merged.winner === 2) ? merged.winner: null;

state = merged;

moveLog = Array.isArray(save.moveLog) ? save.moveLog: [];
moveHistory = [];
boardPositionHistory = new Map();
forbiddenBoardPositions = new Set();
clearSave();
hideSaveNotification();
updateGameInfoDisplay();
showScreen('game-play-area');
renderAll();
renderMoveLog();
triggerNextAction();
} catch(e) {
clearSave();
}
}

function checkForSavedGame() {
try {
const raw = localStorage.getItem(SAVE_KEY);
if (raw) {
const save = JSON.parse(raw);
if (save && save.state && !save.state.winner) {
showSaveNotification();
} else {
clearSave();
}
}
} catch(e) {
clearSave();
}
}
function showSaveNotification() {
const notif = document.getElementById('save-notification');
document.getElementById('save-notification-text').textContent = t('savedGameFound', 'Partie sauvegardée. Reprendre ?');
const _br = document.getElementById('btn-resume');
if (_br) _br.textContent = translations[currentLanguage].btnResume || 'Reprendre';
const _bd = document.getElementById('btn-discard');
if (_bd) _bd.textContent = translations[currentLanguage].btnDiscard || 'Non';
notif.classList.add('visible');
}
function hideSaveNotification() {
document.getElementById('save-notification').classList.remove('visible');
}

// --- MOVE HISTORY LOG ---
function addMoveLog(entry) {
moveLog.push(entry);
if (moveLog.length > 60) moveLog.shift();
renderMoveLog();
}
function renderMoveLog() {
const list = document.getElementById('move-log-list');
if (!list) return;
list.innerHTML = '';
const recent = moveLog.slice(-12);
recent.forEach(entry => {
const el = document.createElement('div');
el.className = `move-log-entry${entry.mill ? ' mill-entry': ''}${entry.capture ? ' capture-entry': ''}`;
const dot = document.createElement('div');
dot.className = `log-stone p${entry.player}`;
el.appendChild(dot);
const txt = document.createElement('span');
txt.textContent = entry.text;
el.appendChild(txt);
list.appendChild(el);
});
list.scrollTop = list.scrollHeight;
}
function clearMoveLog() {
moveLog = []; renderMoveLog();
}

// --- SPECTATOR MODE ---
let spectatorIntervalId = null;
function startSpectatorGame() {
gameMode = 'spectator';
aiDifficulty = aiDifficulty || 3;
humanPlayerId = 0; // No human
aiPlayerId = 1; // Will alternate
player1Name = translations[currentLanguage].defaultComputerName + ' N';
player2Name = translations[currentLanguage].defaultComputerName + ' B';
moveLog = [];
state = initState();
moveHistory = [];
boardPositionHistory = new Map();
forbiddenBoardPositions = new Set();
updateGameInfoDisplay();
showScreen('game-play-area');
document.getElementById('spectator-badge').classList.add('visible');
document.getElementById('spectator-controls').classList.add('visible');
document.getElementById('undo-btn').disabled = true;
document.getElementById('surrender').disabled = true;
renderAll();
renderMoveLog();
triggerNextAction();
}
function stopSpectatorMode() {
document.getElementById('spectator-badge').classList.remove('visible');
document.getElementById('spectator-controls').classList.remove('visible');
}

// ==========================================


// --- ANIMATIONS ---
function animateStonePlacement(idx, player) {
playSound('place');
const row = Math.floor(idx/SIZE)+1,
col = idx%SIZE+1;
addMoveLog( {
player, text: `[${row},${col}]`
});
const cell = boardDiv.children[idx],
stone = document.createElement('div');
stone.className = `stone player${player} moving`;
cell.appendChild(stone);
stone.addEventListener('animationend', () => {
stone.classList.remove('moving');
}, {
once: true
});
}
function animateStoneMove(fromIdx, toIdx) {
playSound('move');
const row = Math.floor(fromIdx/SIZE)+1,
col = fromIdx%SIZE+1;
const toRow = Math.floor(toIdx/SIZE)+1,
toCol = toIdx%SIZE+1;
const mover = state.board[fromIdx];
addMoveLog( {
player: state.turn, text: `[${row},${col}] → [${toRow},${toCol}]`
});
const stone = boardDiv.children[fromIdx].querySelector('.stone');
if (stone) {
stone.classList.add('fade-out'); stone.addEventListener('animationend', () => {}, {
once: true
});
}
}
function animateStoneCapture(idx) {
const stone = boardDiv.children[idx].querySelector('.stone');
if (stone) {
stone.classList.add('captured'); stone.addEventListener('animationend', () => {}, {
once: true
});
}
}


// ============================================================
// === MODULES ADDITIONNELS (stats, replay, a11y, guided, install) ===
// ============================================================
// Helpers supplémentaires ($ et $$ déjà définis en haut du scope)

const clone = (obj) => {
try {
return (typeof deepCopy === 'function') ? deepCopy(obj): JSON.parse(JSON.stringify(obj));
}
catch(_) {
return obj;
}
};

// i18n helper
const t = (key, fallback) => {
try {
const lang = currentLanguage || 'fr';
return (translations && translations[lang] && translations[lang][key]) || fallback || key;
} catch(_) {
return fallback || key;
}
};

// Expose i18n helper globally (used by save/resume banner and other UI)
try {
if (!t) t = t;
} catch(_) {}


// ---------------------------------------------------------

// 2) Toast
// ---------------------------------------------------------
const toastEl = $('#toast');
let toastTimer = null;
function showToast(message, ms = 2200) {
if (!toastEl) return;
setSafeHTML(toastEl, String(message ?? ''));
toastEl.classList.add('show');
window.clearTimeout(toastTimer);
toastTimer = window.setTimeout(() => toastEl.classList.remove('show'), ms);
}

// ---------------------------------------------------------
// 3) Pack Produit – Stats
// ---------------------------------------------------------
const STATS_KEY_V2 = 'tiddas_stats_v2';
const STATS_KEY_V1 = 'tiddas_stats_v1';
const STATS_KEY = STATS_KEY_V2;
const REPLAY_KEY = 'tiddas_last_replay_v1';

function defaultStats() {
return {
v: 2,
createdAt: nowMs(),
updatedAt: nowMs(),
totals: {
games: 0,
timeMs: 0,
actions: 0,       // placements + moves (all turns)
placements: 0,
moves: 0,         // move phase only
captures: 0,
mills: 0
},
modes: {
ai: {
games: 0,
wins: 0,
losses: 0,
streak: 0,
bestStreak: 0,
timeMs: 0,
actions: 0,
placements: 0,
moves: 0,
captures: 0,
mills: 0,
byDifficulty: {
1: { games: 0, wins: 0, losses: 0 },
2: { games: 0, wins: 0, losses: 0 },
3: { games: 0, wins: 0, losses: 0 },
4: { games: 0, wins: 0, losses: 0 }
}
},
local: {
games: 0,
p1Wins: 0,
p2Wins: 0,
timeMs: 0,
actions: 0,
placements: 0,
moves: 0,
captures: 0,
mills: 0
},
online: {
games: 0,
wins: 0,
losses: 0,
draws: 0,
streak: 0,
bestStreak: 0,
timeMs: 0,
actions: 0,
captures: 0,
mills: 0,
opponentNames: []
}
},
variants: {},     // { [variant]: games }
history: [],      // latest first (max 25)
lastGame: null,   // { at, mode, variant, difficulty, durationMs, winnerId, humanId, p1Name, p2Name, actions, placements, moves, captures, mills }
xp: 0,
level: 1,
achievements: {}
};
}

function _migrateStatsV1ToV2(v1) {
const base = defaultStats();
try {
if (!v1 || typeof v1 !== 'object') return base;

base.createdAt = Number(v1.createdAt || base.createdAt);
base.updatedAt = Number(v1.updatedAt || base.updatedAt);

base.totals.games = Number(v1.games || 0);
base.totals.actions = Number(v1.moves || 0);
base.totals.placements = Number(v1.placements || 0);
base.totals.moves = Number(v1.movesPhase || 0);
base.totals.captures = Number(v1.captures || 0);
base.totals.mills = Number(v1.mills || 0);
base.totals.timeMs = Number(v1.timePlayedMs || 0);

const aiGames = Number((v1.winsHuman || 0) + (v1.lossesHuman || 0));
base.modes.ai.games = aiGames;
base.modes.ai.wins = Number(v1.winsHuman || 0);
base.modes.ai.losses = Number(v1.lossesHuman || 0);
base.modes.ai.streak = Number(v1.streak || 0);
base.modes.ai.bestStreak = Number(v1.bestStreak || 0);

const localGames = Number((v1.p1Wins || 0) + (v1.p2Wins || 0));
base.modes.local.games = localGames;
base.modes.local.p1Wins = Number(v1.p1Wins || 0);
base.modes.local.p2Wins = Number(v1.p2Wins || 0);

base.xp = Number(v1.xp || 0);
base.level = computeLevel(base.xp);
base.achievements = (v1.achievements && typeof v1.achievements === 'object') ? v1.achievements : {};

const lastMs = Number(v1.lastGameMs || 0);
if (lastMs > 0) {
base.lastGame = {
at: base.updatedAt || nowMs(),
mode: null,
variant: null,
difficulty: null,
durationMs: lastMs,
winnerId: null,
humanId: null,
p1Name: null,
p2Name: null,
actions: 0,
placements: 0,
moves: 0,
captures: 0,
mills: 0
};
}
} catch(_) {
return base;
}
return base;
}

let stats = defaultStats();

function loadStats() {
try {
// Prefer v2
const raw2 = localStorage.getItem(STATS_KEY);
const parsed2 = raw2 ? safeJSONParse(raw2, null) : null;
if (parsed2 && typeof parsed2 === 'object' && parsed2.v === 2) {
stats = Object.assign(defaultStats(), parsed2);
} else {
// Try v1 and migrate
const raw1 = localStorage.getItem(STATS_KEY_V1);
const parsed1 = raw1 ? safeJSONParse(raw1, null) : null;
if (parsed1 && typeof parsed1 === 'object' && parsed1.v === 1) {
stats = _migrateStatsV1ToV2(parsed1);
// Persist migrated copy
try { saveStats(); } catch(_) {}
} else {
stats = defaultStats();
}
}
} catch(_) {
stats = defaultStats();
}

// Normalize missing fields
stats.totals = stats.totals || defaultStats().totals;
stats.modes = stats.modes || defaultStats().modes;
// Migrate: add online bucket if missing (existing v2 data without it)
if (!stats.modes.online) stats.modes.online = defaultStats().modes.online;
stats.variants = stats.variants || {};
stats.history = Array.isArray(stats.history) ? stats.history : [];
stats.lastGame = stats.lastGame || null;
stats.achievements = stats.achievements || {};

stats.level = computeLevel(stats.xp);
}

function saveStats() {
try {
  stats.updatedAt = nowMs();
  localStorage.setItem(STATS_KEY, JSON.stringify(stats));
  try { markStatsDirty?.(); } catch(_) {}
} catch(_) {}
}

function computeLevel(xp) {
const x = Math.max(0, Number(xp) || 0);
return Math.max(1, Math.floor(x / 100) + 1);
}

function levelProgress(xp) {
const x = Math.max(0, Number(xp) || 0);
const level = computeLevel(x);
const base = (level - 1) * 100;
const into = x - base;
const pct = clamp((into / 100) * 100, 0, 100);
return {
level,
into,
pct,
nextAt: level * 100
};
}

// Session counters for current game (reset at startGame)
let session = {
active: false,
startAt: 0,
moves: 0,
placements: 0,
movesPhase: 0,
captures: 0,
mills: 0,
mode: null,
variant: null,
difficulty: null,
winner: null
};

function resetSession() {
session = {
active: true,
startAt: nowMs(),
moves: 0,
placements: 0,
movesPhase: 0,
captures: 0,
mills: 0,
mode: gameMode || null,
variant: variant || null,
difficulty: aiDifficulty || null,
winner: null
};
}

// ---------------------------------------------------------
// 4) Pack Gameplay – Replay timeline & last-move highlighting
// ---------------------------------------------------------
const replay = {
active: false,
frames: [],
sigs: [],
idx: 0,
timer: null,
backup: null,
data: null
};

let prevBoardForDelta = null;
let lastDelta = {
from: null,
to: null,
capture: null
};

function computeDelta(oldB, newB) {
const diff = [];
for (let i = 0; i < newB.length; i++) {
if (oldB[i] !== newB[i]) diff.push(i);
}
const d = {
from: null,
to: null,
capture: null
};
if (diff.length === 1) {
const i = diff[0];
if (oldB[i] != null && newB[i] == null) d.capture = i;
else if (oldB[i] == null && newB[i] != null) d.to = i;
} else if (diff.length === 2) {
const [a,
b] = diff;
if (oldB[a] != null && newB[a] == null && oldB[b] == null && newB[b] != null) {
d.from = a; d.to = b;
} else if (oldB[b] != null && newB[b] == null && oldB[a] == null && newB[a] != null) {
d.from = b; d.to = a;
}
}
return d;
}

function sigProgress(s) {
const b = Array.isArray(s?.board) ? s.board.map(v => v || 0).join(''): '';
const counts = s?.counts ? `${s.counts[1] ?? 0},${s.counts[2] ?? 0}`: '';
const captured = s?.captured ? `${s.captured[1] ?? 0},${s.captured[2] ?? 0}`: '';
return [
b,
s?.phase || '',
s?.turn || 0,
s?.captureMode ? 1: 0,
s?.turnForCapture || 0,
counts,
captured,
s?.pendingCaptures || 0,
s?.winner || 0
].join('|');
}

function minifyState(s) {
return {
board: Array.isArray(s.board) ? [...s.board]: [],
phase: s.phase,
turn: s.turn,
turnForCapture: s.turnForCapture,
counts: {
1: s.counts?.[1] ?? 0,
2: s.counts?.[2] ?? 0
},
captured: {
1: s.captured?.[1] ?? 0,
2: s.captured?.[2] ?? 0
},
selected: null,
captureMode: !!s.captureMode,
winner: s.winner ?? null,
highlightedMills: Array.isArray(s.highlightedMills) ? [...s.highlightedMills]: [],
pendingCaptures: s.pendingCaptures ?? 0,
consecutivePiece: s.consecutivePiece ? {
...s.consecutivePiece
}: {
1: null,
2: null
},
consecutiveCount: s.consecutiveCount ? {
...s.consecutiveCount
}: {
1: 0,
2: 0
}
};
}

function pushReplayFrame() {
if (replay.active) return;
const s = state;
if (!s || !Array.isArray(s.board)) return;
const sig = sigProgress(s);
if (replay.sigs.length === 0 || replay.sigs[replay.sigs.length - 1] !== sig) {
replay.frames.push(minifyState(s));
replay.sigs.push(sig);
if (replay.frames.length > 320) {
replay.frames.shift();
replay.sigs.shift();
}
}
}

// ---------------------------------------------------------
// 5) Pack UI/UX – A11y keyboard navigation (roving tabindex)
// ---------------------------------------------------------
let focusIdx = 0;

function applyA11y() {
const bd = boardDiv;
const s = state;
if (!bd || !s || !Array.isArray(s.board)) return;

bd.setAttribute('role', 'grid');
bd.setAttribute('aria-label', t('boardAria', 'Plateau de jeu'));

const cells = bd.children;
if (!cells || !cells.length) return;

// Clamp focus index
focusIdx = clamp(focusIdx, 0, cells.length - 1);

for (let i = 0; i < cells.length; i++) {
const cell = cells[i];
cell.setAttribute('role', 'gridcell');
cell.setAttribute('tabindex', i === focusIdx ? '0': '-1');

const r = Math.floor(i / 5) + 1;
const c = (i % 5) + 1;

let occ = t('cellEmpty', 'vide');
if (s.board[i] === 1) occ = (player1Name || 'J1');
else if (s.board[i] === 2) occ = (player2Name || 'J2');

cell.setAttribute('aria-label', `${t('cellLabel', 'Case')} ${r},${c} : ${occ}`);
}
}

function onBoardKeyDown(e) {
if (replay.active) return;

const k = e.key;
let next = focusIdx;

if (k === 'ArrowLeft') next = focusIdx - 1;
else if (k === 'ArrowRight') next = focusIdx + 1;
else if (k === 'ArrowUp') next = focusIdx - 5;
else if (k === 'ArrowDown') next = focusIdx + 5;
else if (k === 'Home') next = Math.floor(focusIdx / 5) * 5;
else if (k === 'End') next = Math.floor(focusIdx / 5) * 5 + 4;
else if (k === 'Enter' || k === ' ') {
e.preventDefault();
try {
onCellClick?.(focusIdx);
} catch(_) {}
return;
} else {
return;
}

e.preventDefault();
next = clamp(next, 0, 24);
focusIdx = next;
applyA11y();
try {
boardDiv.children[focusIdx]?.focus?.();
} catch(_) {}
}

function attachBoardA11yOnce() {
const bd = boardDiv;
if (!bd || bd.__tiddasA11yAttached) return;
bd.__tiddasA11yAttached = true;
bd.addEventListener('keydown', onBoardKeyDown);
}

// ---------------------------------------------------------
// 6) Apply highlights + guided hints (post-render)
// ---------------------------------------------------------
const guidedBtn = $('#guided-btn');
let guidedMode = true;
try {
const saved = localStorage.getItem('tiddas_guided');
if (saved !== null) guidedMode = saved === '1';
} catch(_) {}

function applyGuidedBtn() {
if (!guidedBtn) return;
guidedBtn.classList.toggle('active', guidedMode);
guidedBtn.setAttribute('aria-pressed', String(guidedMode));
guidedBtn.title = guidedMode ? t('guidedMode', 'Guidé'): t('guidedMode', 'Guidé');
guidedBtn.setAttribute('aria-label', t('guidedMode', 'Guidé'));
}

function setGuidedMode(on) {
guidedMode = !!on;
try {
localStorage.setItem('tiddas_guided', guidedMode ? '1': '0');
} catch(_) {}
applyGuidedBtn();
try {
renderAll?.();
} catch(_) {}
}

if (guidedBtn) {
guidedBtn.addEventListener('click', () => setGuidedMode(!guidedMode));
applyGuidedBtn();
}

function applyHighlightsAndHints() {
const bd = boardDiv;
if (!bd) return;
const cells = bd.children;
if (!cells || !cells.length) return;

// Clear previous
for (let i = 0; i < cells.length; i++) {
cells[i].classList.remove('last-move-from', 'last-move-to', 'last-capture');
const st = cells[i].querySelector('.stone');
if (st) st.classList.remove('hint-piece');
}

// Apply last action
if (lastDelta.from != null && cells[lastDelta.from]) cells[lastDelta.from].classList.add('last-move-from');
if (lastDelta.to != null && cells[lastDelta.to]) cells[lastDelta.to].classList.add('last-move-to');
if (lastDelta.capture != null && cells[lastDelta.capture]) cells[lastDelta.capture].classList.add('last-capture');

// Guided hints
if (!guidedMode || replay.active) return;
const s = state;
if (!s || s.winner) return;
if (gameMode === 'spectator') return;

const acting = s.captureMode ? s.turnForCapture: s.turn;
if (gameMode === 'ai' && acting !== humanPlayerId) return;

if (s.captureMode) {
// capturable already marked; pulse the stones in capturable cells
for (let i = 0; i < s.board.length; i++) {
if (!cells[i].classList.contains('capturable')) continue;
const st = cells[i].querySelector('.stone');
if (st) st.classList.add('hint-piece');
}
} else if (s.phase === 'move' && s.selected == null) {
// Pulse selectable pieces
for (let i = 0; i < s.board.length; i++) {
if (s.board[i] === acting) {
const st = cells[i].querySelector('.stone');
if (st) st.classList.add('hint-piece');
}
}
}
}

// ---------------------------------------------------------
// 7) Patch core functions (renderAll / onCellClick / undo / endGame / startGame)
// ---------------------------------------------------------
if (typeof renderAll === 'function') {
const __origRenderAll = renderAll;
renderAll = function(...args) {
try {
attachBoardA11yOnce();

// Delta tracking + session counters (skip during replay)
if (!replay.active && state && Array.isArray(state.board)) {
const newB = state.board;
if (prevBoardForDelta) {
lastDelta = computeDelta(prevBoardForDelta, newB);

if (session.active) {
const moved = (lastDelta.from != null || lastDelta.to != null);
if (moved) {
session.moves += 1; // total actions (placements + moves)
if (state.phase === 'placement') session.placements += 1;
else session.movesPhase += 1;
}
if (lastDelta.capture != null) session.captures += 1;
}
}
prevBoardForDelta = [...newB];
} else if (replay.active && state && Array.isArray(state.board)) {
// keep baseline coherent while replaying
prevBoardForDelta = [...state.board];
}
} catch(_) {}

const r = __origRenderAll.apply(this, args);

try {
applyA11y();
pushReplayFrame();
applyHighlightsAndHints();
} catch(_) {}

return r;
};
}

// Count mills via ephemeral messages
try {
if (typeof showEphemeralBubbleMessage === 'function') {
const __origEph = showEphemeralBubbleMessage;
showEphemeralBubbleMessage = function(messageKey, iconClass, playerId, duration) {
try {
if (!replay.active && session.active && messageKey === 'ephemeralMill') {
session.mills += 1;
}
} catch(_) {}
return __origEph.call(this, messageKey, iconClass, playerId, duration);
};
}
} catch(_) {}

// Prevent interaction while replaying
if (typeof onCellClick === 'function') {
const __origOnCellClick = onCellClick;
onCellClick = function(i) {
if (replay.active) return;
return __origOnCellClick.call(this, i);
};
}

// Undo should also rewind replay timeline if possible
if (typeof handleUndo === 'function') {
const __origUndo = handleUndo;
handleUndo = function(...args) {
const r = __origUndo.apply(this, args);
try {
const curSig = sigProgress(state);
const idx = replay.sigs.lastIndexOf(curSig);
if (idx >= 0) {
replay.frames = replay.frames.slice(0, idx + 1);
replay.sigs = replay.sigs.slice(0, idx + 1);
} else {
replay.frames = [minifyState(state)];
replay.sigs = [curSig];
}
showToast(t('toastReplayReady', '⏯️ Replay prêt.'), 1200);
} catch(_) {}
return r;
};
}

// Reset replay + session before starting any new game
if (typeof startGame === 'function') {
const __origStartGame = startGame;
startGame = function(...args) {
try {
replay.frames = [];
replay.sigs = [];
prevBoardForDelta = null;
lastDelta = {
from: null,
to: null,
capture: null
};
resetSession();
} catch(_) {}
return __origStartGame.apply(this, args);
};
}

// Spectator: do not track stats
if (typeof startSpectatorGame === 'function') {
const __origStartSpectator = startSpectatorGame;
startSpectatorGame = function(...args) {
try {
session.active = false;
replay.frames = [];
replay.sigs = [];
} catch(_) {}
return __origStartSpectator.apply(this, args);
};
}

// Persist stats + replay at game end
if (typeof endGame === 'function') {
const __origEndGame = endGame;
endGame = function(...args) {
try {
// Ensure final frame is captured (includes winner)
pushReplayFrame();
finalizeSessionAndStats();
persistLastReplay();
refreshReplayButtons();
} catch(e) {
}
return __origEndGame.apply(this, args);
};
}


// Persist stats + replay on surrender as well (surrender does not call endGame)
if (typeof handleSurrender === 'function') {
const __origHandleSurrender = handleSurrender;
handleSurrender = function(...args) {
const r = __origHandleSurrender.apply(this, args);
try {
pushReplayFrame();
finalizeSessionAndStats();
persistLastReplay();
refreshReplayButtons();
} catch(_) {}
return r;
};
}

// ---------------------------------------------------------
// 8) Finalize stats + replay persistence
// ---------------------------------------------------------
function finalizeSessionAndStats() {
if (!session.active) return;
if (gameMode === 'spectator') return;
if (!state) return;
if (!state.winner) return;

session.active = false;
session.winner = state.winner;

// Duration
let dur = 0;
try {
dur = Math.max(0, nowMs() - (session.startAt || 0));
} catch(_) { dur = 0; }

// Names (saved in-game variables)
const p1N = (typeof player1Name !== 'undefined' && player1Name) ? String(player1Name) : null;
const p2N = (typeof player2Name !== 'undefined' && player2Name) ? String(player2Name) : null;

const record = {
at: nowMs(),
mode: gameMode || null,
variant: variant || null,
difficulty: (gameMode === 'ai') ? (aiDifficulty || null) : null,
durationMs: dur,
winnerId: session.winner,
humanId: (gameMode === 'ai') ? (humanPlayerId || null) : null,
p1Name: p1N,
p2Name: p2N,
actions: Number(session.moves || 0),
placements: Number(session.placements || 0),
moves: Number(session.movesPhase || 0),
captures: Number(session.captures || 0),
mills: Number(session.mills || 0)
};

// Aggregate totals
stats.totals = stats.totals || defaultStats().totals;
stats.totals.games += 1;
stats.totals.timeMs = (stats.totals.timeMs || 0) + dur;
stats.totals.actions = (stats.totals.actions || 0) + record.actions;
stats.totals.placements = (stats.totals.placements || 0) + record.placements;
stats.totals.moves = (stats.totals.moves || 0) + record.moves;
stats.totals.captures = (stats.totals.captures || 0) + record.captures;
stats.totals.mills = (stats.totals.mills || 0) + record.mills;

// Variants
try {
const key = record.variant || 'unknown';
stats.variants = stats.variants || {};
stats.variants[key] = Number(stats.variants[key] || 0) + 1;
} catch(_) {}

// Mode buckets
stats.modes = stats.modes || defaultStats().modes;
if (gameMode === 'ai') {
const ai = stats.modes.ai;
ai.games += 1;
ai.timeMs = (ai.timeMs || 0) + dur;
ai.actions = (ai.actions || 0) + record.actions;
ai.placements = (ai.placements || 0) + record.placements;
ai.moves = (ai.moves || 0) + record.moves;
ai.captures = (ai.captures || 0) + record.captures;
ai.mills = (ai.mills || 0) + record.mills;

const human = humanPlayerId;
const isWin = (record.winnerId === human);
if (isWin) {
ai.wins += 1;
ai.streak = (ai.streak || 0) + 1;
ai.bestStreak = Math.max(ai.bestStreak || 0, ai.streak || 0);
stats.xp += 25 + Math.min(40, record.actions);
if (aiDifficulty === 4) stats.achievements.beatExpert = true;
} else {
ai.losses += 1;
ai.streak = 0;
stats.xp += 10 + Math.min(25, record.actions);
}

// Difficulty breakdown
try {
const d = String(aiDifficulty || '');
if (ai.byDifficulty && ai.byDifficulty[d]) {
ai.byDifficulty[d].games += 1;
if (isWin) ai.byDifficulty[d].wins += 1;
else ai.byDifficulty[d].losses += 1;
}
} catch(_) {}
} else if (gameMode === 'local') {
const lo = stats.modes.local;
lo.games += 1;
lo.timeMs = (lo.timeMs || 0) + dur;
lo.actions = (lo.actions || 0) + record.actions;
lo.placements = (lo.placements || 0) + record.placements;
lo.moves = (lo.moves || 0) + record.moves;
lo.captures = (lo.captures || 0) + record.captures;
lo.mills = (lo.mills || 0) + record.mills;

if (record.winnerId === 1) lo.p1Wins += 1;
if (record.winnerId === 2) lo.p2Wins += 1;

stats.xp += 12 + Math.min(30, record.actions);
} else if (gameMode === 'online') {
const onl = stats.modes.online || defaultStats().modes.online;
stats.modes.online = onl;
onl.games += 1;
onl.timeMs = (onl.timeMs || 0) + dur;
onl.actions = (onl.actions || 0) + record.actions;
onl.captures = (onl.captures || 0) + record.captures;
onl.mills = (onl.mills || 0) + record.mills;

// Determine win/loss from online.role vs winnerId
// online.role: slot (1 or 2), online.playerId: in-game player id (may differ after color swap)
const myPlayerId = (typeof online !== 'undefined' && online.playerId) ? online.playerId : null;
const isWin = myPlayerId ? (record.winnerId === myPlayerId) : false;
if (isWin) {
  onl.wins += 1;
  onl.streak = (onl.streak || 0) + 1;
  onl.bestStreak = Math.max(onl.bestStreak || 0, onl.streak);
  stats.xp += 30 + Math.min(40, record.actions);
} else {
  onl.losses += 1;
  onl.streak = 0;
  stats.xp += 15 + Math.min(20, record.actions);
}

// Record opponent name
try {
  const myRole = (typeof online !== 'undefined' && online.role) ? online.role : null;
  const oppName = myRole === 1 ? (record.p2Name || null) : (record.p1Name || null);
  if (oppName) {
    if (!Array.isArray(onl.opponentNames)) onl.opponentNames = [];
    onl.opponentNames = [oppName, ...onl.opponentNames.filter(n => n !== oppName)].slice(0, 10);
  }
  // Enrich recent room entry with result
  const roomCode = (typeof online !== 'undefined' && online.room) ? online.room : null;
  if (roomCode) {
    addRecentOnlineRoom({
      code: roomCode,
      opponentName: oppName,
      myName: record.p1Name || record.p2Name || null,
      variant: record.variant,
      winnerId: record.winnerId,
      didWin: isWin
    });
  }
} catch(_) {}
} else {
stats.xp += 8 + Math.min(20, record.actions);
}

// Achievements (simple)
try {
if ((stats.totals.games || 0) >= 1) stats.achievements.firstGame = true;
if ((stats.modes?.ai?.wins || 0) >= 1) stats.achievements.firstWin = true;
if ((stats.totals.games || 0) >= 10) stats.achievements.tenGames = true;
if ((stats.modes?.ai?.bestStreak || 0) >= 5) stats.achievements.streak5 = true;
} catch(_) {}

// Last game + history
stats.lastGame = record;
stats.history = Array.isArray(stats.history) ? stats.history : [];
stats.history.unshift(record);
stats.history = stats.history.slice(0, 25);

stats.level = computeLevel(stats.xp);
saveStats();
}

function persistLastReplay() {
// Only persist meaningful games (non-spectator)
if (gameMode === 'spectator') return;
if (replay.frames.length < 2) return;

const data = {
v: 1,
createdAt: nowMs(),
meta: {
variant: variant || null,
gameMode: gameMode || null,
aiDifficulty: aiDifficulty || null,
humanPlayerId: humanPlayerId || null,
player1Name: player1Name || null,
player2Name: player2Name || null
},
frames: replay.frames
};

try {
localStorage.setItem(REPLAY_KEY, JSON.stringify(data));
} catch(_) {}
}

function loadLastReplay() {
try {
const raw = localStorage.getItem(REPLAY_KEY);
const parsed = raw ? safeJSONParse(raw, null): null;
if (!parsed || typeof parsed !== 'object' || parsed.v !== 1) return null;
if (!Array.isArray(parsed.frames) || parsed.frames.length < 2) return null;
return parsed;
} catch(_) {
return null;
}
}

// ---------------------------------------------------------
// 9) Stats UI modal
// ---------------------------------------------------------
const statsBtn = $('#stats-btn');
const winnerStatsBtn = $('#winner-stats-btn');
const statsModal = $('#stats-modal');
const statsCloseBtn = $('#stats-close-btn');
const statsResetBtn = $('#stats-reset-btn');
const statsExportBtn = $('#stats-export-btn');
const statsContent = $('#stats-content');

function formatDuration(ms) {
const s = Math.max(0, Math.floor((Number(ms) || 0) / 1000));
const h = Math.floor(s / 3600);
const m = Math.floor((s % 3600) / 60);
const r = s % 60;
if (h > 0) return `${h}h ${m}m`;
if (m > 0) return `${m}m ${r}s`;
return `${r}s`;
}

function _escText(v) {
const s = String(v ?? '');
return s.replace(/[&<>"']/g, (c) => ( {
'&': '&amp;',
'<': '&lt;',
'>': '&gt;',
'"': '&quot;',
"'": '&#39;'
}[c] ));
}

function _modeLabel(mode) {
  if (mode === 'ai') return t('modeAI');
  if (mode === 'local') return t('modeLocal');
  if (mode === 'online') return t('statsOnlineMode');
  if (mode === 'spectator') return t('modeSpectator');
  return '—';
}
function _difficultyLabel(d) {
  const n = Number(d);
  if (n === 1) return t('difficultyEasy');
  if (n === 2) return t('difficultyMedium');
  if (n === 3) return t('difficultyHard');
  if (n === 4) return t('difficultyImpossible');
  return '—';
}

// ───────────────────────────────────────────────────────────────
// Stats: compute once, render once (no heavy recalculations in render)
// ───────────────────────────────────────────────────────────────
let _statsRevision = 0;
let _statsCache = null;
let _statsCacheRev = -1;

function markStatsDirty() {
  _statsRevision++;
  _statsCache = null;
}

function computeStatsForUI(raw) {
  const stats0 = raw || defaultStats();
  const num = (x) => Math.max(0, Number(x) || 0);
  const pct = (a, b) => (b > 0 ? Math.round((a / b) * 100) : null);
  const fmtName = (v) => _escText(v || '—');

  const def = defaultStats();
  const totals = stats0.totals || def.totals;
  const ai = (stats0.modes && stats0.modes.ai) ? stats0.modes.ai : def.modes.ai;
  const local = (stats0.modes && stats0.modes.local) ? stats0.modes.local : def.modes.local;
  const onl = (stats0.modes && stats0.modes.online) ? stats0.modes.online : def.modes.online;

  const hist = Array.isArray(stats0.history) ? stats0.history : [];
  const last = stats0.lastGame || null;
  const pref = loadNamePrefs();

  // Derived: best win time (from history)
  let bestWinMs = 0;
  let tmp = Infinity;
  for (const g of hist) {
    if (g && g.winnerId && num(g.durationMs) > 0) tmp = Math.min(tmp, num(g.durationMs));
  }
  if (tmp < Infinity) bestWinMs = tmp;

  // Opponent highlight
  const opponents = Array.isArray(onl.opponentNames) ? onl.opponentNames.filter(Boolean) : [];
  const oppTop = (() => {
    const map = new Map();
    for (const n of opponents) map.set(n, (map.get(n) || 0) + 1);
    let best = null;
    let bestN = 0;
    map.forEach((v, k) => { if (v > bestN) { bestN = v; best = k; } });
    return best ? { name: best, games: bestN } : null;
  })();

  // AI by difficulty (only keep played)
  const byDiff = [1,2,3,4].map((lvl) => {
    const obj = ai.byDifficulty && ai.byDifficulty[lvl] ? ai.byDifficulty[lvl] : { games: 0, wins: 0, losses: 0 };
    const g = num(obj.games);
    const w = num(obj.wins);
    return { level: lvl, games: g, wins: w, losses: num(obj.losses), rate: pct(w, g) };
  }).filter(x => x.games > 0);

  // Global derived
  const games = num(totals.games);
  const timeMs = num(totals.timeMs);
  const actions = num(totals.actions);
  const placements = num(totals.placements);
  const moves = num(totals.moves);
  const captures = num(totals.captures);
  const mills = num(totals.mills);

  return {
    games,
    timeMs,
    actions,
    placements,
    moves,
    captures,
    mills,
    avgDurMs: games > 0 ? (timeMs / games) : 0,
    actsPerGame: games > 0 ? (actions / games) : 0,
    placementsPerGame: games > 0 ? (placements / games) : 0,
    movesPerGame: games > 0 ? (moves / games) : 0,
    captPerGame: games > 0 ? (captures / games) : 0,
    millsPerGame: games > 0 ? (mills / games) : 0,
    bestWinMs,
    xp: num(stats0.xp),
    level: computeLevel(num(stats0.xp)),
    levelPct: (() => { try { return levelProgress(num(stats0.xp)).pct || 0; } catch(_) { return 0; } })(),
    xpToNext: (() => { try { return (levelProgress(num(stats0.xp)).nextAt || 0) - num(stats0.xp); } catch(_) { return 0; } })(),

    players: {
      p1Color: (translations[currentLanguage]?.player1Color || '').split(' ')[0] || t('player1ColorShort'),
      p2Color: (translations[currentLanguage]?.player2Color || '').split(' ')[0] || t('player2ColorShort'),
      p1Name: pref.p1 || t('defaultPlayer1'),
      p2Name: pref.p2 || t('defaultPlayer2'),
      onlineName: (() => { try { return localStorage.getItem('tiddas_online_name_v1') || ''; } catch(_) { return ''; } })(),
    },

    ai: {
      games: num(ai.games),
      wins: num(ai.wins),
      losses: num(ai.losses),
      winRate: pct(num(ai.wins), num(ai.games)),
      streak: num(ai.streak),
      bestStreak: num(ai.bestStreak),
      avgDurMs: num(ai.games) > 0 ? (num(ai.timeMs) / num(ai.games)) : 0,
      actionsPerGame: num(ai.games) > 0 ? (num(ai.actions) / num(ai.games)) : 0,
      byDiff,
    },

    local: {
      games: num(local.games),
      p1Wins: num(local.p1Wins),
      p2Wins: num(local.p2Wins),
      p1Rate: pct(num(local.p1Wins), num(local.games)),
      p2Rate: pct(num(local.p2Wins), num(local.games)),
      avgDurMs: num(local.games) > 0 ? (num(local.timeMs) / num(local.games)) : 0,
    },

    online: {
      games: num(onl.games),
      wins: num(onl.wins),
      losses: num(onl.losses),
      draws: num(onl.draws),
      winRate: pct(num(onl.wins), num(onl.games)),
      streak: num(onl.streak),
      bestStreak: num(onl.bestStreak),
      avgDurMs: num(onl.games) > 0 ? (num(onl.timeMs) / num(onl.games)) : 0,
      actionsPerGame: num(onl.games) > 0 ? (num(onl.actions) / num(onl.games)) : 0,
      oppTop,
    },

    last: last ? {
      mode: last.mode || '—',
      variant: last.variant || '—',
      difficulty: last.difficulty || null,
      winnerId: last.winnerId || null,
      p1Name: fmtName(last.p1Name),
      p2Name: fmtName(last.p2Name),
      durationMs: num(last.durationMs),
      actions: num(last.actions),
      placements: num(last.placements),
      moves: num(last.moves),
      captures: num(last.captures),
      mills: num(last.mills),
      at: last.at ? new Date(last.at) : null,
    } : null
  };
}

function getComputedStats() {
  if (_statsCache && _statsCacheRev === _statsRevision) return _statsCache;
  _statsCache = computeStatsForUI(stats);
  _statsCacheRev = _statsRevision;
  return _statsCache;
}

function renderStats(cs) {
  if (!statsContent) return;
  const fmtP = (v) => (v === null ? '—' : (v + '%'));
  const fmtD = (ms) => (ms > 0 ? formatDuration(ms) : '—');
  const fmtN = (v, dec=0) => {
    const n = Number(v) || 0;
    return dec ? n.toFixed(dec) : String(Math.round(n));
  };
  const esc = (s) => _escText(s);

  let html = `
    <div class="stats-chips">
      <div class="stats-chip"><span class="dot" style="background:rgba(20,20,20,0.9)"></span>
        <span><strong>${esc(cs.players.p1Color)}</strong> — ${esc(cs.players.p1Name)}</span></div>
      <div class="stats-chip"><span class="dot" style="background:rgba(235,235,235,0.95)"></span>
        <span><strong>${esc(cs.players.p2Color)}</strong> — ${esc(cs.players.p2Name)}</span></div>
      ${cs.players.onlineName ? `<div class="stats-chip"><span class="dot" style="background:rgba(0,200,255,0.6)"></span>
        <span>🌐 ${esc(cs.players.onlineName)}</span></div>` : ''}
    </div>`;

  if (cs.games === 0) {
    statsContent.innerHTML = html + `<div class="stats-simple-note">${t('noStatsYet')}</div>`;
    return;
  }

  const sectionTitle = (label, icon) => `<div class="stats-section-title">${icon ? icon + ' ' : ''}${label}</div>`;
  const miniRow = (label, value) => `<div class="stats-mini"><span class="label">${label}</span><span class="value">${value}</span></div>`;

  // Global
  html += sectionTitle(t('statsSectionGlobal'), '📊');
  html += `<div class="stats-grid">
    <div class="stat-card"><div class="k">${t('gamesPlayedLabel')}</div><div class="v">${cs.games}</div></div>
    <div class="stat-card"><div class="k">${t('durationLabel')}</div><div class="v">${fmtD(cs.timeMs)}</div></div>
    <div class="stat-card"><div class="k">${t('avgDuration')}</div><div class="v">${fmtD(cs.avgDurMs)}</div></div>
    <div class="stat-card"><div class="k">${t('statsBestWinTime')}</div><div class="v">${fmtD(cs.bestWinMs)}</div></div>
  </div>`;

  // Activity
  html += sectionTitle(t('statsSectionActivity'), '⚔️');
  html += `<div class="stats-grid">
    <div class="stat-card"><div class="k">${t('actionsPerGameLabel')}</div><div class="v">${fmtN(cs.actsPerGame, 1)}</div></div>
    <div class="stat-card"><div class="k">${t('statsPlacementsPerGame')}</div><div class="v">${fmtN(cs.placementsPerGame, 1)}</div></div>
    <div class="stat-card"><div class="k">${t('statsMovesPerGame')}</div><div class="v">${fmtN(cs.movesPerGame, 1)}</div></div>
    <div class="stat-card"><div class="k">${t('statsCaptPerGame')}</div><div class="v">${fmtN(cs.captPerGame, 1)}</div></div>
    <div class="stat-card"><div class="k">${t('statsMillsPerGame')}</div><div class="v">${fmtN(cs.millsPerGame, 1)}</div></div>
    <div class="stat-card"><div class="k">${t('capturesLabel')}</div><div class="v">${cs.captures}</div></div>
  </div>`;

  // Level
  html += sectionTitle(t('levelLabel'), '⭐');
  html += `<div class="stat-card" style="margin-bottom:10px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <span class="k" style="font-size:1rem;">${t('levelLabel')} <strong style="color:var(--text-gold);font-size:1.2rem;">${cs.level}</strong></span>
      <span class="v" style="font-size:0.9rem;">${cs.xp} XP</span>
    </div>
    <div class="progress-bar"><div style="width:${cs.levelPct}%"></div></div>
    <div style="margin-top:5px;font-size:0.8rem;opacity:0.7;">${t('statsLevelProgress')} : ${Math.max(0, cs.xpToNext)} XP</div>
  </div>`;

  // By mode
  html += sectionTitle(t('statsSectionByMode'), '🎮');
  html += `<div class="stats-rowline">`;

  if (cs.ai.games > 0) {
    html += `<div class="stat-card">
      <div class="k" style="margin-bottom:6px;">🤖 ${t('modeAI')} — ${cs.ai.games} ${t('gamesPlayedLabel')}</div>
      ${miniRow(t('winRateLabel'), fmtP(cs.ai.winRate))}
      ${miniRow(t('winsLabel'), String(cs.ai.wins))}
      ${miniRow(t('lossesLabel'), String(cs.ai.losses))}
      ${miniRow(t('statsStreakCurrent'), String(cs.ai.streak))}
      ${miniRow(t('statsStreakBest'), String(cs.ai.bestStreak))}
      ${miniRow(t('statsAvgDurPerMode'), fmtD(cs.ai.avgDurMs))}
      ${miniRow(t('statsActionsPerGame'), fmtN(cs.ai.actionsPerGame, 1))}
      ${cs.ai.byDiff.length ? `
        <div class="k" style="margin-top:8px;margin-bottom:4px;">${t('statsByDifficulty')}</div>
        ${cs.ai.byDiff.map(d => miniRow(`${_difficultyLabel(d.level)}`, `${d.wins}/${d.games} (${fmtP(d.rate)})`)).join('')}
      ` : ''}
    </div>`;
  }

  if (cs.local.games > 0) {
    html += `<div class="stat-card">
      <div class="k" style="margin-bottom:6px;">👥 ${t('modeLocal')} — ${cs.local.games} ${t('gamesPlayedLabel')}</div>
      ${miniRow(`${esc(cs.players.p1Color)} (${esc(cs.players.p1Name)})`, `${cs.local.p1Wins} ${t('winsLabel')} (${fmtP(cs.local.p1Rate)})`)}
      ${miniRow(`${esc(cs.players.p2Color)} (${esc(cs.players.p2Name)})`, `${cs.local.p2Wins} ${t('winsLabel')} (${fmtP(cs.local.p2Rate)})`)}
      ${miniRow(t('statsAvgDurPerMode'), fmtD(cs.local.avgDurMs))}
    </div>`;
  }

  if (cs.online.games > 0) {
    html += `<div class="stat-card">
      <div class="k" style="margin-bottom:6px;">🌐 ${t('statsOnlineMode')} — ${cs.online.games} ${t('gamesPlayedLabel')}</div>
      ${miniRow(t('winRateLabel'), fmtP(cs.online.winRate))}
      ${miniRow(t('winsLabel'), String(cs.online.wins))}
      ${miniRow(t('lossesLabel'), String(cs.online.losses))}
      ${cs.online.draws ? miniRow(t('drawsLabel'), String(cs.online.draws)) : ''}
      ${miniRow(t('statsStreakCurrent'), String(cs.online.streak))}
      ${miniRow(t('statsStreakBest'), String(cs.online.bestStreak))}
      ${miniRow(t('statsAvgDurPerMode'), fmtD(cs.online.avgDurMs))}
      ${miniRow(t('statsActionsPerGame'), fmtN(cs.online.actionsPerGame, 1))}
      ${cs.online.oppTop ? miniRow(t('statsOnlineTopOpponent'), `${esc(cs.online.oppTop.name)} (${cs.online.oppTop.games})`) : ''}
    </div>`;
  }

  html += `</div>`;

  // Last game
  if (cs.last) {
    html += sectionTitle(t('statsSectionLastGame'), '🕐');
    html += `<div class="stat-card">
      ${miniRow(t('modeLabel'), _modeLabel(cs.last.mode))}
      ${miniRow(t('statsVariantLabel'), esc(cs.last.variant))}
      ${miniRow(t('winnerLabel'), cs.last.winnerId === 1 ? esc(cs.last.p1Name) : cs.last.winnerId === 2 ? esc(cs.last.p2Name) : '—')}
      ${miniRow(t('durationLabel'), fmtD(cs.last.durationMs))}
      ${miniRow(t('statsActionsCount'), String(cs.last.actions))}
      ${miniRow(t('statsPlacementsCount'), String(cs.last.placements))}
      ${miniRow(t('statsMovesCount'), String(cs.last.moves))}
      ${miniRow(t('capturesLabel'), String(cs.last.captures))}
      ${miniRow(t('millsLabel'), String(cs.last.mills))}
      <div class="stat-detail" style="margin-top:6px;font-size:0.8rem;opacity:0.7;">
        ${cs.last.at ? cs.last.at.toLocaleString() : '—'} — ${esc(cs.last.p1Name)} vs ${esc(cs.last.p2Name)}
      </div>
    </div>`;
  }

  statsContent.innerHTML = html;
}

function refreshStatsUI() {
  renderStats(getComputedStats());
}
function openStats() {
if (!statsModal) return;
refreshStatsUI();
statsModal.classList.add('active');
statsModal.setAttribute('aria-hidden', 'false');
}
function closeStats() {
if (!statsModal) return;
statsModal.classList.remove('active');
statsModal.setAttribute('aria-hidden', 'true');
}

if (statsBtn) statsBtn.addEventListener('click', openStats);
if (winnerStatsBtn) winnerStatsBtn.addEventListener('click', openStats);
if (statsCloseBtn) statsCloseBtn.addEventListener('click', closeStats);
if (statsModal) statsModal.addEventListener('click', (e) => {
if (e.target === statsModal) closeStats();
});

if (statsResetBtn) {
statsResetBtn.addEventListener('click', () => {
const ok = window.confirm(t('resetStatsConfirm'));
if (!ok) return;
stats = defaultStats();
saveStats();
markStatsDirty();
refreshStatsUI();
showToast(t('toastStatsReset'), 1800);
});
}

if (statsExportBtn) {
statsExportBtn.addEventListener('click', () => {
try {
const payload = JSON.stringify(stats, null, 2);
const blob = new Blob([payload], { type: 'application/json' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = 'tiddas_stats.json';
document.body.appendChild(a);
a.click();
a.remove();
URL.revokeObjectURL(url);
showToast(t('toastExported'), 1600);
} catch(_) {}
});
}


// ---------------------------------------------------------
// 10) Replay UI modal
// ---------------------------------------------------------
const replayBtn = $('#replay-btn');
const winnerReplayLastBtn = $('#winner-replay-last-btn');

const replayModal = $('#replay-modal');
const replayMetaEl = $('#replay-meta');
const replayRange = $('#replay-range');
const replaySpeed = $('#replay-speed');
const replayPlayBtn = $('#replay-play-btn');
const replayPrevBtn = $('#replay-prev-btn');
const replayNextBtn = $('#replay-next-btn');
const replayFirstBtn = $('#replay-first-btn');
const replayLastBtn = $('#replay-last-btn');
const replayExitBtn = $('#replay-exit-btn');
const replayInfoBtn = $('#replay-info-btn');

function refreshReplayButtons() {
const last = loadLastReplay();
const has = !!last;
if (replayBtn) replayBtn.disabled = !has;
if (winnerReplayLastBtn) winnerReplayLastBtn.disabled = !has;
}

const replayStepEl = $('#replay-step-indicator');

let replayMetaOpen = false;
function toggleReplayMeta(force) {
  if (typeof force === 'boolean') replayMetaOpen = force;
  else replayMetaOpen = !replayMetaOpen;
  if (replayMetaEl) replayMetaEl.hidden = !replayMetaOpen;
  if (replayInfoBtn) replayInfoBtn.classList.toggle('active', replayMetaOpen);
}


function updateReplayMeta() {
  if (!replayMetaEl) return;
  if (!replay.data) {
    replayMetaEl.textContent = '';
    replayMetaEl.hidden = true;
    if (replayStepEl) replayStepEl.textContent = '— / —';
    return;
  }

  const meta = replay.data.meta || {};
  const vName = (variantConfig && meta.variant && variantConfig[meta.variant]?.name)
    ? variantConfig[meta.variant].name
    : (meta.variant || '—');

  const mode = _modeLabel(meta.gameMode || '');
  const diff = meta.aiDifficulty ? (' · ' + _difficultyLabel(meta.aiDifficulty)) : '';
  const p1 = meta.player1Name || 'J1';
  const p2 = meta.player2Name || 'J2';

  // Meta text (shown when the user toggles info)
  replayMetaEl.textContent = `${vName} · ${mode}${diff} · ${p1} vs ${p2}`;

  // Step indicator (always visible)
  if (replayStepEl) {
    replayStepEl.textContent = `${t('replayMoveLabel','Coup')} ${replay.idx + 1}/${replay.frames.length}`;
  }
}

function setReplayIndex(i) {
if (!replay.frames.length) return;
replay.idx = clamp(i, 0, replay.frames.length - 1);
if (replayRange) replayRange.value = String(replay.idx);
updateReplayMeta();

// Compute delta between frames for highlight
try {
const cur = replay.frames[replay.idx];
const prev = replay.idx > 0 ? replay.frames[replay.idx - 1]: null;
if (prev && Array.isArray(prev.board) && Array.isArray(cur.board)) {
lastDelta = computeDelta(prev.board, cur.board);
} else {
lastDelta = {
from: null,
to: null,
capture: null
};
}
} catch(_) {}

// Show frame (render only)
try {
state = clone(replay.frames[replay.idx]);
state.selected = null;
// Les frames minifiées ne contiennent pas ces champs requis par renderBoard()
// en phase de déplacement. Sans eux, state.consecutivePiece[p] lève une TypeError
// silencieusement avalée, et le plateau n'est jamais dessiné.
if (!state.consecutivePiece) state.consecutivePiece = {
1: null,
2: null
};
if (!state.consecutiveCount) state.consecutiveCount = {
1: 0,
2: 0
};
renderAll?.();
} catch(e) {
}
}

function stopReplayTimer() {
if (replay.timer) {
window.clearTimeout(replay.timer);
replay.timer = null;
}
if (replayPlayBtn) replayPlayBtn.textContent = '▶️';
}

function stepReplay(delta) {
stopReplayTimer();
setReplayIndex(replay.idx + delta);
}

function playReplay() {
if (!replay.frames.length) return;
const speed = Number(replaySpeed?.value || '1') || 1;
const delay = Math.max(180, Math.floor(700 / speed));

const tick = () => {
if (!replay.active) return;
if (replay.idx >= replay.frames.length - 1) {
stopReplayTimer();
return;
}
setReplayIndex(replay.idx + 1);
replay.timer = window.setTimeout(tick, delay);
};

if (replay.timer) {
// pause
stopReplayTimer();
} else {
if (replayPlayBtn) replayPlayBtn.textContent = '⏸️';
replay.timer = window.setTimeout(tick, delay);
}
}

function disableGameControls(disabled) {
const ids = ['new-game',
'undo-btn',
'restart',
'surrender'];
ids.forEach(id => {
const el = document.getElementById(id);
if (el) el.disabled = !!disabled;
});
}

function openReplay() {
const data = loadLastReplay();
if (!data) {
showToast(t('toastNoReplay', 'Aucune partie à rejouer.'), 1800);
return;
}

replay.data = data;
replay.frames = data.frames || [];
replay.sigs = [];
replay.idx = 0;

// Backup current context to restore after replay
replay.backup = {
state: clone(state),
moveHistory: clone(moveHistory),
moveLog: clone(moveLog),
gameMode: gameMode,
variant: variant,
aiDifficulty: aiDifficulty,
humanPlayerId: humanPlayerId,
aiPlayerId: aiPlayerId,
player1Name: player1Name,
player2Name: player2Name
};

// Rétablir les valeurs du replay pour que renderAll affiche correctement
try {
if (data.meta) {
if (data.meta.variant) variant = data.meta.variant;
if (data.meta.gameMode) gameMode = data.meta.gameMode;
if (data.meta.aiDifficulty) aiDifficulty = data.meta.aiDifficulty;
if (data.meta.humanPlayerId) humanPlayerId = data.meta.humanPlayerId;
if (data.meta.player1Name) player1Name = data.meta.player1Name;
if (data.meta.player2Name) player2Name = data.meta.player2Name;
}
} catch(_) {}

replay.active = true;
disableGameControls(true);
stopReplayTimer();
// Start dock compact (meta hidden)
replayMetaOpen = false;
try { if (replayMetaEl) replayMetaEl.hidden = true; if (replayInfoBtn) replayInfoBtn.classList.remove('active'); } catch(_) {}

// S'assurer que le plateau de jeu est visible (masquer winner overlay)
try {
const winnerOverlay = document.getElementById('winner-overlay');
if (winnerOverlay) winnerOverlay.classList.remove('active');
} catch(_) {}

// S'assurer que l'écran de jeu est actif
try {
const screens = document.querySelectorAll('.selection-area, .game-play-area');
screens.forEach(s => s.classList.remove('active'));
const gameArea = document.getElementById('game-play-area');
if (gameArea) gameArea.classList.add('active');
const header = document.getElementById('main-header');
if (header) header.classList.add('hidden');
} catch(_) {}

// Ajouter classe sur body pour CSS
document.body.classList.add('replay-active');

if (replayModal) {
replayModal.classList.add('active');
replayModal.setAttribute('aria-hidden', 'false');
}

if (replayRange) {
replayRange.min = '0';
replayRange.max = String(Math.max(0, replay.frames.length - 1));
replayRange.value = '0';
}

setReplayIndex(0);
}

function closeReplay() {
stopReplayTimer();

// Retirer classe body
document.body.classList.remove('replay-active');

if (replayModal) {
replayModal.classList.remove('active');
replayModal.setAttribute('aria-hidden', 'true');
}

// Restore previous context
try {
if (replay.backup) {
gameMode = replay.backup.gameMode;
variant = replay.backup.variant;
aiDifficulty = replay.backup.aiDifficulty;
humanPlayerId = replay.backup.humanPlayerId;
aiPlayerId = replay.backup.aiPlayerId;
player1Name = replay.backup.player1Name;
player2Name = replay.backup.player2Name;
moveHistory = replay.backup.moveHistory || [];
moveLog = replay.backup.moveLog || [];
state = replay.backup.state;
}
replay.active = false;
disableGameControls(false);

// Restaurer l'en-tête si nécessaire
try {
const header = document.getElementById('main-header');
if (header && state?.phase) header.classList.add('hidden');
} catch(_) {}

renderAll?.();
try {
renderMoveLog?.();
} catch(_) {}
} catch(_) {
replay.active = false;
disableGameControls(false);
}
}

if (replayBtn) replayBtn.addEventListener('click', openReplay);
if (winnerReplayLastBtn) winnerReplayLastBtn.addEventListener('click', openReplay);

if (replayExitBtn) replayExitBtn.addEventListener('click', closeReplay);
if (replayInfoBtn) replayInfoBtn.addEventListener('click', () => toggleReplayMeta());
if (replayModal) replayModal.addEventListener('click', (e) => {
if (e.target === replayModal) closeReplay();
});

if (replayRange) replayRange.addEventListener('input', (e) => setReplayIndex(parseInt(e.target.value, 10) || 0));
if (replayPlayBtn) replayPlayBtn.addEventListener('click', playReplay);
if (replayPrevBtn) replayPrevBtn.addEventListener('click', () => stepReplay(-1));
if (replayNextBtn) replayNextBtn.addEventListener('click', () => stepReplay(1));
if (replayFirstBtn) replayFirstBtn.addEventListener('click', () => {
stopReplayTimer(); setReplayIndex(0);
});
if (replayLastBtn) replayLastBtn.addEventListener('click', () => {
stopReplayTimer(); setReplayIndex(replay.frames.length - 1);
});

// ---------------------------------------------------------
// 11) PWA install + Service Worker (best effort)
// ---------------------------------------------------------
const installBtn = $('#install-btn');
const installHelpModal = $('#install-help-modal');
const installHelpCloseBtn = $('#install-help-close-btn');

let deferredPrompt = null;

function openInstallHelp() {
if (!installHelpModal) return;
installHelpModal.classList.add('active');
installHelpModal.setAttribute('aria-hidden', 'false');
}

function closeInstallHelp() {
if (!installHelpModal) return;
installHelpModal.classList.remove('active');
installHelpModal.setAttribute('aria-hidden', 'true');
}

if (installHelpCloseBtn) installHelpCloseBtn.addEventListener('click', closeInstallHelp);
if (installHelpModal) installHelpModal.addEventListener('click', (e) => {
if (e.target === installHelpModal) closeInstallHelp();
});



window.addEventListener('beforeinstallprompt',
(e) => {
e.preventDefault();
deferredPrompt = e;
if (installBtn) installBtn.disabled = false;
});

window.addEventListener('appinstalled',
() => {
showToast(t('toastInstalled', '✅ App installée.'), 1800);
if (installBtn) installBtn.disabled = true;
});

if (installBtn) {
installBtn.addEventListener('click', async () => {
if (deferredPrompt) {
deferredPrompt.prompt();


try {
const choice = await deferredPrompt.userChoice;
if (choice && choice.outcome === 'accepted') {
showToast(t('toastInstalled', '✅ App installée.'), 1800);
} else {
showToast(t('toastInstallUnavailable', 'ℹ️ Installation non disponible.'), 1800);
}
} catch(_) {}
deferredPrompt = null;
} else {
openInstallHelp();
}
});
}

// Override manifest to ensure start_url points to the current file
try {
const manifest = {
name: "Tiddas - Jeu Ancestral Amazigh",
short_name: "Tiddas",
description: "Jeu ancestral Amazigh (Tiddas/Moulin) - Patrimoine Kabyle",
start_url: window.location.href,
scope: "./",
display: "standalone",
orientation: "portrait-primary",
background_color: "#fff3bf",
theme_color: "#1e88e5",
lang: document.documentElement.lang || "fr",
icons: [{
src: "data:image/svg+xml," + encodeURIComponent('<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 192 192\"><rect width=\"192\" height=\"192\" rx=\"32\" fill=\"#2c2722\"/><text x=\"96\" y=\"130\" font-size=\"110\" text-anchor=\"middle\" fill=\"#f0c850\">ⵣ</text></svg>'), sizes: "192x192", type: "image/svg+xml"
},
{
src: "data:image/svg+xml," + encodeURIComponent('<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><rect width=\"512\" height=\"512\" rx=\"96\" fill=\"#2c2722\"/><text x=\"256\" y=\"350\" font-size=\"320\" text-anchor=\"middle\" fill=\"#f0c850\">ⵣ</text></svg>'), sizes: "512x512", type: "image/svg+xml"
}]
};
const blob = new Blob([JSON.stringify(manifest)],
{
type: 'application/json'
});
const url = URL.createObjectURL(blob);
const link = document.getElementById('pwa-manifest');
if (link) link.href = url;
} catch(_) {}

// Service worker registration via Blob (single-file)
async function registerServiceWorker() {
if (!('serviceWorker' in navigator)) return;
if (!window.isSecureContext) return;

// Avoid file:// and other unsupported contexts
if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') return;

const swCode = `
const CACHE = 'tiddas-cache-v7';
const APP_SHELL = ${JSON.stringify(location.href)};
self.addEventListener('install', (event) => {
event.waitUntil((async () => {
const cache = await caches.open(CACHE);
try { await cache.addAll([APP_SHELL]); } catch(_) {}
self.skipWaiting();
})());
});
self.addEventListener('activate', (event) => {
event.waitUntil((async () => {
const keys = await caches.keys();
await Promise.all(keys.map(k => (k !== CACHE ? caches.delete(k) : Promise.resolve())));
await self.clients.claim();
})());
});
self.addEventListener('fetch', (event) => {
const req = event.request;
if (req.method !== 'GET') return;
const url = new URL(req.url);
if (url.origin !== location.origin) return;
if (req.mode === 'navigate') {
event.respondWith((async () => {
const cache = await caches.open(CACHE);
const cached = await cache.match(APP_SHELL) || await cache.match(req);
if (cached) return cached;
try {
const fresh = await fetch(req);
cache.put(req, fresh.clone());
return fresh;
} catch(e) {
return cached || Response.error();
}
})());
return;
}
event.respondWith((async () => {
const cache = await caches.open(CACHE);
const cached = await cache.match(req);
if (cached) return cached;
try {
const fresh = await fetch(req);
cache.put(req, fresh.clone());
return fresh;
} catch(e) {
return cached || Response.error();
}
})());
});
self.addEventListener('message', (event) => {
if (event.data === 'SKIP_WAITING') self.skipWaiting();
});
`;

try {
const blob = new Blob([swCode], {
type: 'text/javascript'
});
const swUrl = URL.createObjectURL(blob);
const reg = await navigator.serviceWorker.register(swUrl, {
scope: './'
});

// Update available
if (reg.waiting) {
showToast(t('toastSWUpdate', '🔄 Mise à jour dispo : rechargez l\'app.'), 2400);
} else {
showToast(t('toastSWReady', '✅ Mode hors-ligne prêt.'), 1800);
}

// Cleanup blob URL (registration keeps an internal copy)
try {
URL.revokeObjectURL(swUrl);
} catch(_) {}

reg.addEventListener('updatefound', () => {
showToast(t('toastSWUpdate', '🔄 Mise à jour dispo : rechargez l\'app.'), 2400);
});
} catch(_) {
// Silent: some browsers block blob SW registration
}
}

// Best-effort SW registration (enables offline + install eligibility when supported)
try {
registerServiceWorker();
} catch(_) {}

// ---------------------------------------------------------


// ---------------------------------------------------------
// 0) Language Splash Screen
// ---------------------------------------------------------


(function initLangSplash() {
const splash = document.getElementById('lang-splash');
if (!splash) return;

// Check if language was previously chosen
let savedLang = null;
try {
savedLang = localStorage.getItem('tiddas_lang');
} catch(_) {}

function chooseLang(lang) {
// Save preference
try {
localStorage.setItem('tiddas_lang', lang);
} catch(_) {}

// Apply language before hiding splash (always, including 'fr')
try {
const sel = document.getElementById('language-select');
if (sel) sel.value = lang;
if (typeof updateLanguage === 'function') updateLanguage(lang);
else currentLanguage = lang;
} catch(_) {}

// Animate out
splash.classList.add('hidden');
setTimeout(() => {
splash.style.display = 'none';
// Focus first interactive element
const firstBtn = document.querySelector('.version-card');
if (firstBtn) firstBtn.focus();
},
480);
}

// If already chosen, skip splash instantly
if (savedLang) {
splash.style.display = 'none';
// Apply saved language for all values (including 'fr')
try {
const sel = document.getElementById('language-select');
if (sel) sel.value = savedLang;
} catch(_) {}
// Queue language application via _pendingLang (applied after init chain)
if (savedLang !== 'fr') {
window._pendingLang = savedLang;
}
// else: 'fr' is the default — no pendingLang needed
return;
}

// Wire up splash buttons
splash.querySelectorAll('.splash-lang-btn').forEach(btn => {
btn.addEventListener('click', () => chooseLang(btn.dataset.lang));
btn.addEventListener('keydown', e => {
if (e.key === 'Enter' || e.key === ' ') {
e.preventDefault(); chooseLang(btn.dataset.lang);
}
});
});

// Keyboard trap inside splash
splash.addEventListener('keydown', e => {
if (e.key === 'Tab') {
const focusable = splash.querySelectorAll('.splash-lang-btn');
if (!focusable.length) return;
const first = focusable[0],
last = focusable[focusable.length - 1];
if (e.shiftKey && document.activeElement === first) {
e.preventDefault(); last.focus();
} else if (!e.shiftKey && document.activeElement === last) {
e.preventDefault(); first.focus();
}
}
});

// Auto-focus first button
setTimeout(() => splash.querySelector('.splash-lang-btn')?.focus(),
100);
})();

// ---------------------------------------------------------
// 13) i18n hook for new buttons (titles/aria) + initial refresh
// ---------------------------------------------------------
const applyNewI18nAttrs = () => {
const btns = [{
id: 'install-btn', key: 'installApp'
},
{
id: 'stats-btn', key: 'stats'
},
{
id: 'guided-btn', key: 'guidedMode'
},
{
id: 'replay-btn', key: 'replayLast'
},
{
id: 'theme-btn', key: 'btnTheme'
},
{
id: 'sound-btn', key: 'btnSound'
},
{
id: 'settings-fab', key: 'btnSettings'
}];
btns.forEach(b => {
const el = document.getElementById(b.id);
if (!el) return;
const label = t(b.key, b.key);
el.setAttribute('aria-label', label);
el.title = label;
});

const winnerReplay = document.getElementById('winner-replay-last-btn');
if (winnerReplay) {
winnerReplay.setAttribute('aria-label', t('replayLast', 'Replay'));
winnerReplay.title = t('replayLast', 'Replay');
}
const winnerStats = document.getElementById('winner-stats-btn');
if (winnerStats) {
winnerStats.setAttribute('aria-label', t('stats', 'Stats'));
winnerStats.title = t('stats', 'Stats');
}
};

if (typeof updateLanguage === 'function') {
const __origUpdateLang = updateLanguage;
updateLanguage = function(lang) {
const r = __origUpdateLang.call(this, lang);
try {
applyNewI18nAttrs(); renderStats(); updateReplayMeta();
} catch(_) {}
return r;
};
}

// Initial load
loadStats();
refreshReplayButtons();
applyNewI18nAttrs();

// Apply pending language from splash (if user previously chose kabyle)
if (window._pendingLang && window._pendingLang !== 'fr') {
try {
if (typeof updateLanguage === 'function') updateLanguage(window._pendingLang);
} catch(_) {}
delete window._pendingLang;
}

// Defer SW registration to idle-ish moment


// ============================================================
// === INITIALISATION (DOMContentLoaded unique) ===
// ============================================================
document.addEventListener('DOMContentLoaded', () => {

// Load saved preferences
try {
const savedTheme = localStorage.getItem('tiddas_theme');
if (savedTheme !== null) {
const idx = parseInt(savedTheme, 10);
currentTheme = Number.isFinite(idx) ? ((idx % THEMES.length) + THEMES.length) % THEMES.length: 0;
}
const savedSound = localStorage.getItem('tiddas_sound');
if (savedSound !== null) soundEnabled = savedSound === '1';
} catch(e) {}
applyTheme(currentTheme);
const soundBtn = document.getElementById('sound-btn');
if (soundBtn) {
const sndLabel = (typeof translations !== 'undefined' && translations[currentLanguage] && translations[currentLanguage].btnSound) || 'Son';
soundBtn.textContent = '';
soundBtn.appendChild(document.createTextNode(soundEnabled ? '🔊 ': '🔇 '));
const span = document.createElement('span');
span.className = 'btn-label';
span.setAttribute('data-i18n', 'btnSound');
span.textContent = sndLabel;
soundBtn.appendChild(span);
soundBtn.classList.toggle('sound-off', !soundEnabled);
soundBtn.addEventListener('click', toggleSound);
}
const themeBtn = document.getElementById('theme-btn');
if (themeBtn) {
themeBtn.addEventListener('click', cycleTheme);
}

// Settings FAB toggle
const settingsFab = document.getElementById('settings-fab');
const settingsTray = document.getElementById('settings-tray');
const strayCloseBtn = document.getElementById('stray-close-btn');
const closeSettingsTray = () => {
settingsTray.classList.remove('open');
settingsFab.classList.remove('open');
settingsFab.setAttribute('aria-expanded', 'false');
};
if (settingsFab && settingsTray) {
settingsFab.addEventListener('click', () => {
const isOpen = settingsTray.classList.toggle('open');
settingsFab.classList.toggle('open', isOpen);
settingsFab.setAttribute('aria-expanded', isOpen);
});
if (strayCloseBtn) strayCloseBtn.addEventListener('click', (e) => {
e.stopPropagation(); closeSettingsTray();
});
document.addEventListener('click', (e) => {
if (!settingsFab.contains(e.target) && !settingsTray.contains(e.target)) {
closeSettingsTray();
}
});
}

// Spectator mode button
const spectatorBtn = document.getElementById('play-spectator-btn');
if (spectatorBtn) {
spectatorBtn.addEventListener('click', () => {
gameMode = 'spectator';
aiDifficulty = aiDifficulty || 3;
showScreen('ai-difficulty-selection-area');
});
}

// Spectator speed change
const speedSelect = document.getElementById('spectator-speed');
if (speedSelect) {
speedSelect.addEventListener('change', e => {
spectatorDelay = parseInt(e.target.value);
});
}

// Save/Resume notification
const btnResume = document.getElementById('btn-resume');
const btnDiscard = document.getElementById('btn-discard');
if (btnResume) {
  const _resume = (e) => { try { e.preventDefault(); } catch(_) {} loadAndResume(); };
  btnResume.addEventListener('click', _resume);
  btnResume.addEventListener('pointerup', _resume, { passive: false });
  btnResume.addEventListener('touchend', _resume, { passive: false });
}
if (btnDiscard) {
  const _discard = (e) => { try { e.preventDefault(); } catch(_) {} clearSave(); hideSaveNotification(); };
  btnDiscard.addEventListener('click', _discard);
  btnDiscard.addEventListener('pointerup', _discard, { passive: false });
  btnDiscard.addEventListener('touchend', _discard, { passive: false });
}

// Check for saved game on startup
setTimeout(checkForSavedGame, 800);

// PWA Manifest creation
try {
const manifest = {
name: "Tiddas - Jeu Ancestral Amazigh",
short_name: "Tiddas",
description: "Jeu ancestral Amazigh (Tiddas/Moulin) - Patrimoine Kabyle",
start_url: "./",
display: "standalone",
orientation: "portrait-primary",
background_color: "#fff3bf",
theme_color: "#1e88e5",
lang: "fr",
icons: [{
src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj4KPGRlZnM+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJiZyIgeDE9IjAiIHkxPSIwIiB4Mj0iMSIgeTI9IjEiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2ZmZjNiZiIvPgogICAgPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjZDdmM2ZmIi8+CiAgPC9saW5lYXJHcmFkaWVudD4KICA8bGluZWFyR3JhZGllbnQgaWQ9ImJkIiB4MT0iMCIgeTE9IjAiIHgyPSIxIiB5Mj0iMSI+CiAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdG9wLWNvbG9yPSIjZThjOTdhIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNiODkwM2EiLz4KICA8L2xpbmVhckdyYWRpZW50PgogIDxsaW5lYXJHcmFkaWVudCBpZD0iY2wiIHgxPSIwIiB5MT0iMCIgeDI9IjEiIHkyPSIxIj4KICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiNmNWRmYTAiLz4KICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3RvcC1jb2xvcj0iI2Q0YTg1NSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJhZGlhbEdyYWRpZW50IGlkPSJzMSIgY3g9IjM1JSIgY3k9IjMwJSIgcj0iNjUlIj4KICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiM2NjYiLz4KICAgIDxzdG9wIG9mZnNldD0iNTUlIiBzdG9wLWNvbG9yPSIjMWExYTFhIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMDAiLz4KICA8L3JhZGlhbEdyYWRpZW50PgogIDxyYWRpYWxHcmFkaWVudCBpZD0iczIiIGN4PSIzNSUiIGN5PSIzMCUiIHI9IjY1JSI+CiAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdG9wLWNvbG9yPSIjZmZmIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjU1JSIgc3RvcC1jb2xvcj0iI2U4ZThlOCIvPgogICAgPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjYmJiIi8+CiAgPC9yYWRpYWxHcmFkaWVudD4KICA8ZmlsdGVyIGlkPSJmcyI+PGZlRHJvcFNoYWRvdyBkeD0iMCIgZHk9IjMiIHN0ZERldmlhdGlvbj0iNiIgZmxvb2Qtb3BhY2l0eT0iMC4zNSIvPjwvZmlsdGVyPgogIDxmaWx0ZXIgaWQ9ImZwIj48ZmVEcm9wU2hhZG93IGR4PSIwIiBkeT0iMiIgc3RkRGV2aWF0aW9uPSIzIiBmbG9vZC1vcGFjaXR5PSIwLjQiLz48L2ZpbHRlcj4KPC9kZWZzPgo8cmVjdCB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgcng9Ijk2IiBmaWxsPSJ1cmwoI2JnKSIvPgo8cmVjdCB4PSIxNCIgeT0iMTQiIHdpZHRoPSI0ODQiIGhlaWdodD0iNDg0IiByeD0iODIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzFlODhlNSIgc3Ryb2tlLXdpZHRoPSI2IiBvcGFjaXR5PSIwLjIiLz4KPHJlY3QgeD0iMjYiIHk9IjI2IiB3aWR0aD0iNDYwIiBoZWlnaHQ9IjQ2MCIgcng9IjcwIiBmaWxsPSJub25lIiBzdHJva2U9IiMyZTdkMzIiIHN0cm9rZS13aWR0aD0iMyIgb3BhY2l0eT0iMC4xMiIvPgo8ZyBmaWxsPSIjZDMyZjJmIiBvcGFjaXR5PSIwLjM1Ij4KICA8cG9seWdvbiBwb2ludHM9IjUyLDUyIDcyLDMyIDkyLDUyIDcyLDcyIi8+CiAgPHBvbHlnb24gcG9pbnRzPSI0MjAsNTIgNDQwLDMyIDQ2MCw1MiA0NDAsNzIiLz4KICA8cG9seWdvbiBwb2ludHM9IjUyLDQ2MCA3Miw0NDAgOTIsNDYwIDcyLDQ4MCIvPgogIDxwb2x5Z29uIHBvaW50cz0iNDIwLDQ2MCA0NDAsNDQwIDQ2MCw0NjAgNDQwLDQ4MCIvPgo8L2c+Cjx0ZXh0IHg9IjI1NiIgeT0iMTAwIiBmb250LWZhbWlseT0iQXJpYWwgQmxhY2ssQXJpYWwsc2Fucy1zZXJpZiIgZm9udC1zaXplPSI0NCIgZm9udC13ZWlnaHQ9IjkwMCIgbGV0dGVyLXNwYWNpbmc9IjciIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiNjNjI4MjgiIG9wYWNpdHk9IjAuOSI+VElEREFTPC90ZXh0Pgo8cmVjdCB4PSIxMDYiIHk9IjExNiIgd2lkdGg9IjMwMCIgaGVpZ2h0PSIzMDAiIHJ4PSIxNCIgZmlsbD0idXJsKCNiZCkiIGZpbHRlcj0idXJsKCNmcykiLz4KPGcgZmlsbD0idXJsKCNjbCkiPgogIDxyZWN0IHg9IjExMCIgeT0iMTIwIiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMTY4IiB5PSIxMjAiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIyMjYiIHk9IjEyMCIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjI4NCIgeT0iMTIwIiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMzQyIiB5PSIxMjAiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIxMTAiIHk9IjE3OCIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjE2OCIgeT0iMTc4IiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMjI2IiB5PSIxNzgiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIyODQiIHk9IjE3OCIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjM0MiIgeT0iMTc4IiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMTEwIiB5PSIyMzYiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIxNjgiIHk9IjIzNiIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjIyNiIgeT0iMjM2IiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMjg0IiB5PSIyMzYiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIzNDIiIHk9IjIzNiIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjExMCIgeT0iMjk0IiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMTY4IiB5PSIyOTQiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIyMjYiIHk9IjI5NCIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjI4NCIgeT0iMjk0IiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMzQyIiB5PSIyOTQiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIxMTAiIHk9IjM1MiIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjE2OCIgeT0iMzUyIiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMjI2IiB5PSIzNTIiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIyODQiIHk9IjM1MiIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjM0MiIgeT0iMzUyIiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CjwvZz4KPGcgZmlsdGVyPSJ1cmwoI2ZwKSI+CiAgPGNpcmNsZSBjeD0iMTM3IiBjeT0iMTQ3IiByPSIyMyIgZmlsbD0idXJsKCNzMSkiLz48Y2lyY2xlIGN4PSIxMzAiIGN5PSIxNDAiIHI9IjciIGZpbGw9IndoaXRlIiBvcGFjaXR5PSIwLjMiLz4KICA8Y2lyY2xlIGN4PSIyNTMiIGN5PSIxNDciIHI9IjIzIiBmaWxsPSJ1cmwoI3MxKSIvPjxjaXJjbGUgY3g9IjI0NiIgY3k9IjE0MCIgcj0iNyIgZmlsbD0id2hpdGUiIG9wYWNpdHk9IjAuMyIvPgogIDxjaXJjbGUgY3g9IjE5NSIgY3k9IjIwNSIgcj0iMjMiIGZpbGw9InVybCgjczEpIi8+PGNpcmNsZSBjeD0iMTg4IiBjeT0iMTk4IiByPSI3IiBmaWxsPSJ3aGl0ZSIgb3BhY2l0eT0iMC4zIi8+CiAgPGNpcmNsZSBjeD0iMzY5IiBjeT0iMjYzIiByPSIyMyIgZmlsbD0idXJsKCNzMSkiLz48Y2lyY2xlIGN4PSIzNjIiIGN5PSIyNTYiIHI9IjciIGZpbGw9IndoaXRlIiBvcGFjaXR5PSIwLjMiLz4KICA8Y2lyY2xlIGN4PSIzMTEiIGN5PSIzMjEiIHI9IjIzIiBmaWxsPSJ1cmwoI3MxKSIvPjxjaXJjbGUgY3g9IjMwNCIgY3k9IjMxNCIgcj0iNyIgZmlsbD0id2hpdGUiIG9wYWNpdHk9IjAuMyIvPgogIDxjaXJjbGUgY3g9IjM2OSIgY3k9IjE0NyIgcj0iMjMiIGZpbGw9InVybCgjczIpIi8+PGNpcmNsZSBjeD0iMzYyIiBjeT0iMTQwIiByPSI4IiBmaWxsPSJ3aGl0ZSIgb3BhY2l0eT0iMC42Ii8+CiAgPGNpcmNsZSBjeD0iMzExIiBjeT0iMjA1IiByPSIyMyIgZmlsbD0idXJsKCNzMikiLz48Y2lyY2xlIGN4PSIzMDQiIGN5PSIxOTgiIHI9IjgiIGZpbGw9IndoaXRlIiBvcGFjaXR5PSIwLjYiLz4KICA8Y2lyY2xlIGN4PSIyNTMiIGN5PSIyNjMiIHI9IjIzIiBmaWxsPSJ1cmwoI3MyKSIvPjxjaXJjbGUgY3g9IjI0NiIgY3k9IjI1NiIgcj0iOCIgZmlsbD0id2hpdGUiIG9wYWNpdHk9IjAuNiIvPgogIDxjaXJjbGUgY3g9IjEzNyIgY3k9IjMyMSIgcj0iMjMiIGZpbGw9InVybCgjczIpIi8+PGNpcmNsZSBjeD0iMTMwIiBjeT0iMzE0IiByPSI4IiBmaWxsPSJ3aGl0ZSIgb3BhY2l0eT0iMC42Ii8+CiAgPGNpcmNsZSBjeD0iMTk1IiBjeT0iMzc5IiByPSIyMyIgZmlsbD0idXJsKCNzMikiLz48Y2lyY2xlIGN4PSIxODgiIGN5PSIzNzIiIHI9IjgiIGZpbGw9IndoaXRlIiBvcGFjaXR5PSIwLjYiLz4KPC9nPgo8dGV4dCB4PSIyNTYiIHk9IjQ2NCIgZm9udC1mYW1pbHk9InNlcmlmIiBmb250LXNpemU9IjM4IiBmb250LXdlaWdodD0iYm9sZCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzE1NjVjMCIgb3BhY2l0eT0iMC44NSI+JiMxMDk3OTs8L3RleHQ+Cjwvc3ZnPg==",
sizes: "192x192 512x512 any",
type: "image/svg+xml",
purpose: "any maskable"
}]
};
const blob = new Blob([JSON.stringify(manifest)], {
type: 'application/json'
});
const url = URL.createObjectURL(blob);
const link = document.getElementById('pwa-manifest');
if (link) link.href = url;
} catch(e) {}

languageSelect.addEventListener('change', (e) => updateLanguage(e.target.value));

document.querySelectorAll('.version-card').forEach(card => card.addEventListener('click', () => {
versionCards.forEach(vc => vc.classList.remove('active'));
card.classList.add('active');
variant = card.dataset.variant;
showScreen('mode-selection-area');
}));

document.getElementById('play-ai-btn').addEventListener('click', () => {
gameMode = 'ai';
showScreen('ai-difficulty-selection-area');
});

document.getElementById('play-offline-btn').addEventListener('click', () => {
gameMode = 'local';
showScreen('player-setup-area');
});



// ═══════════════════════════════════════════════════════
//  ONLINE LOBBY — wiring v2 (guided steps + invite panel)
// ═══════════════════════════════════════════════════════

// Auto-join from URL param ?room=CODE&join=1 — runs once (300ms after DOM ready)
let _autoJoinDone = false;
function _tryAutoJoinFromUrl() {
  if (_autoJoinDone) return;
  _autoJoinDone = true;
  try {
    const params = new URLSearchParams(window.location.search);
    const roomParam = (params.get('room') || '').trim().toUpperCase().replace(/[^A-Z0-9]/g,'');
    const joinParam  = params.get('join');
    if (!roomParam) return;
    // Clean URL
    try { history.replaceState({}, '', window.location.pathname); } catch(_) {}
    // Navigate to online lobby
    gameMode = 'online';
    const onlineBtn2 = document.getElementById('play-online-btn');
    if (onlineBtn2) onlineBtn2.click();
    else if (typeof showScreen === 'function') showScreen('online-lobby-area');
    // Pre-fill code field
    setTimeout(() => {
      try {
        const inp = document.getElementById('online-room-code');
        if (inp) { inp.value = roomParam; inp.dispatchEvent(new Event('input')); }
        // Open join accordion
        const jp = document.getElementById('online-join-panel');
        if (jp) jp.classList.add('open');
        // Show toast
        const msg = t('onlineAutoJoinDetected','Salon détecté : {code}').replace('{code}', roomParam);
        if (typeof showToast === 'function') showToast(msg, 2500);
        // If name already known → connect; else focus name input
        const savedName = (() => { try { return localStorage.getItem('tiddas_online_name_v1') || ''; } catch(_) { return ''; } })();
        if (savedName) {
          setTimeout(() => { try { onlineConnectToRoom(roomParam, false); } catch(_) {} }, 400);
        } else {
          const glob = document.getElementById('online-status-global');
          if (glob) glob.textContent = t('onlineAutoJoinWaiting','Entrez votre nom pour rejoindre');
          const nameInp = document.getElementById('online-your-name');
          if (nameInp) nameInp.focus();
        }
      } catch(_) {}
    }, 350);
  } catch(_) {}
}
setTimeout(_tryAutoJoinFromUrl, 100);

const onlineBtn = document.getElementById('play-online-btn');
if (onlineBtn) {
  onlineBtn.addEventListener('click', () => {
    gameMode = 'online';
    showScreen('online-lobby-area');

    // Bind elements
    onlineEls.area        = document.getElementById('online-lobby-area');
    onlineEls.statusText  = document.getElementById('online-status-text');
    onlineEls.roomCodeRow = document.getElementById('online-roomcode-row');
    onlineEls.roomCode    = document.getElementById('online-roomcode');
    onlineEls.btnCreate   = document.getElementById('online-create-room');
    onlineEls.btnJoin     = document.getElementById('online-join-room');
    onlineEls.joinPanel   = document.getElementById('online-join-panel');
    onlineEls.inputCode   = document.getElementById('online-room-code');
    onlineEls.btnConnect  = document.getElementById('online-connect');
    onlineEls.btnStart    = document.getElementById('online-start');
    onlineEls.btnCopy     = document.getElementById('online-copy-code');
    onlineEls.btnCopyLink = null; // replaced by invite panel
    onlineEls.btnShareLink= null; // replaced by invite panel
    onlineEls.btnBack     = document.getElementById('back-to-modes-from-online-btn');
    onlineEls.inputName   = document.getElementById('online-your-name');
    onlineEls.p1Name      = document.getElementById('online-p1-name');
    onlineEls.p2Name      = document.getElementById('online-p2-name');
    onlineEls.recentWrap  = document.getElementById('online-recent-wrap');
    onlineEls.recentList  = document.getElementById('online-recent-list');
    onlineEls.btnRejoinLast = document.getElementById('online-rejoin-last');

    const rematchReadyBtn = document.getElementById('online-rematch-ready-btn');
    if (rematchReadyBtn) {
      rematchReadyBtn.addEventListener('click', async () => {
        // Toggle ready state for current slot
        try {
          const match = await _fetchMatchById(online.matchId);
          const rm1 = !!match.get('rm1');
          const rm2 = !!match.get('rm2');
          const current = (online.role === 1) ? rm1 : rm2;
          await onlineSetRematchReady(!current);
        } catch(_) {}
      });
    }

    // Status global text element
    const statusGlobal = document.getElementById('online-status-global');
    const _setGlobal = (msg) => { if (statusGlobal) statusGlobal.textContent = msg || ''; };

    _setGlobal(_isBack4AppConfigured()
      ? t('onlineChooseAction','Choisis : créer ou rejoindre un salon.')
      : t('onlineNotConfigured',"Back4App n'est pas configuré (clés manquantes)."));

    // Show/hide status card
    const statusCard = document.getElementById('online-status');
    const _showStatusCard = (yes) => { if (statusCard) statusCard.style.display = yes ? '' : 'none'; };

    // Helpers accordion
    const _openAccordion  = (id) => { const el = document.getElementById(id); if (el) el.classList.add('open'); };
    const _closeAccordion = (id) => { const el = document.getElementById(id); if (el) el.classList.remove('open'); };
    const _closeAllAccordions = () => {
      ['online-create-panel','online-join-panel','online-recent-wrap'].forEach(_closeAccordion);
    };

    // Code input validation
    const _validateCode = () => {
      const v = (onlineEls.inputCode?.value || '').trim();
      if (onlineEls.inputCode) {
        onlineEls.inputCode.classList.toggle('input-valid', v.length >= 4);
        onlineEls.inputCode.classList.toggle('input-error', v.length > 0 && v.length < 4);
      }
      if (onlineEls.btnConnect) onlineEls.btnConnect.disabled = v.length < 4;
    };
    if (onlineEls.inputCode) {
      onlineEls.inputCode.addEventListener('input', _validateCode);
      _validateCode();
    }

    // Back button
    if (onlineEls.btnBack) onlineEls.btnBack.onclick = () => { onlineDisconnect(); showScreen('mode-selection-area'); };

    // Disable actions if not configured
    const __onlineOk = _isBack4AppConfigured();
    if (onlineEls.btnCreate)  onlineEls.btnCreate.disabled  = !__onlineOk;
    if (onlineEls.btnConnect) onlineEls.btnConnect.disabled = true; // enabled by validation

    // ── Créer un salon (avec prévisualisation code) ──────────
    if (onlineEls.btnCreate) onlineEls.btnCreate.onclick = () => {
      _closeAllAccordions();
      const code = _randCode(4);
      const previewBox = document.getElementById('online-code-preview-box');
      const previewCode = document.getElementById('online-preview-code');
      const confirmBtn = document.getElementById('online-preview-confirm');
      if (previewBox && previewCode) {
        previewCode.textContent = code;
        previewBox.style.display = '';
        _openAccordion('online-create-panel');
        if (confirmBtn) {
          confirmBtn.onclick = () => {
            previewBox.style.display = 'none';
            _closeAccordion('online-create-panel');
            _showStatusCard(true);
            onlineConnectToRoom(code, true);
          };
        }
      } else {
        _showStatusCard(true);
        onlineConnectToRoom(code, true);
      }
    };

    // ── Rejoindre ────────────────────────────────────────────
    if (onlineEls.btnJoin) onlineEls.btnJoin.onclick = () => {
      _closeAllAccordions();
      _openAccordion('online-join-panel');
      onlineEls.inputCode?.focus();
    };

    // ── Bouton "Salons récents" ───────────────────────────────
    const recentToggleBtn = document.getElementById('online-recent-toggle');
    if (recentToggleBtn) {
      const rooms = loadRecentOnlineRooms();
      recentToggleBtn.style.display = rooms.length > 0 ? '' : 'none';
      recentToggleBtn.onclick = () => {
        const alreadyOpen = document.getElementById('online-recent-wrap')?.classList.contains('open');
        _closeAllAccordions();
        if (!alreadyOpen) _openAccordion('online-recent-wrap');
      };
    }

    // ── Bouton OK (connecter) ─────────────────────────────────
    if (onlineEls.btnConnect) onlineEls.btnConnect.onclick = () => {
      const code = (onlineEls.inputCode?.value || '').trim().toUpperCase();
      if (code.length < 4) {
        if (onlineEls.inputCode) onlineEls.inputCode.classList.add('input-error');
        return;
      }
      _closeAccordion('online-join-panel');
      _showStatusCard(true);
      onlineConnectToRoom(code, false);
    };

    // ── Rejoindre dernier salon ──────────────────────────────
    try {
      const lastRoom = loadLastOnlineRoom();
      if (onlineEls.btnRejoinLast) {
        _show(onlineEls.btnRejoinLast, !!(lastRoom && lastRoom.code));
        onlineEls.btnRejoinLast.onclick = () => {
          const c = String(lastRoom?.code || '').trim().toUpperCase();
          if (!c) return;
          _closeAllAccordions();
          _showStatusCard(true);
          onlineConnectToRoom(c, false);
        };
      }
    } catch(_) {}

    // ── Salons récents (bouton dans les actions) ─────────────
    // Triggered via a separate button that toggles the accordion
    const recentRooms = loadRecentOnlineRooms();
    if (recentRooms.length > 0) {
      // Add "recent" button dynamically if needed — or trigger on open
      _closeAllAccordions();
    }
    try { renderRecentOnlineRooms(); } catch(_) {}

    // ── Copier code ──────────────────────────────────────────
    if (onlineEls.btnCopy) onlineEls.btnCopy.onclick = async () => {
      const c = (online.room || onlineEls.roomCode?.textContent || '').trim();
      if (!c) return;
      try {
        await navigator.clipboard.writeText(c);
        if (typeof showToast === 'function') showToast(t('onlineCodeCopied','Code copié ✅'));
      } catch(_) {}
    };

    // ── Panneau Inviter un ami ───────────────────────────────
    const inviteToggle = document.getElementById('online-invite-toggle');
    const invitePanel  = document.getElementById('online-invite-panel');
    const invCodeVal   = document.getElementById('inv-code-val');
    const invLinkVal   = document.getElementById('inv-link-val');
    const invShareRow  = document.getElementById('inv-share-row');
    const invCopyCode  = document.getElementById('inv-copy-code-btn');
    const invCopyLink  = document.getElementById('inv-copy-link-btn');
    const invShareBtn  = document.getElementById('inv-share-btn');

    const _inviteLink = (code) => {
      const c = String(code||'').trim().toUpperCase();
      return `${window.location.origin}${window.location.pathname}?room=${encodeURIComponent(c)}&join=1`;
    };

    const _updateInvitePanel = () => {
      const c = (online.room || onlineEls.roomCode?.textContent || '').trim();
      if (invCodeVal) invCodeVal.textContent = c || '—';
      if (invLinkVal) {
        const link = _inviteLink(c);
        invLinkVal.textContent = link.replace(/^https?:\/\//, '').slice(0,28) + '…';
        invLinkVal.title = link;
      }
      if (invShareRow) {
        const canShare = !!(navigator && typeof navigator.share === 'function');
        invShareRow.style.display = canShare ? '' : 'none';
      }
    };

    const _makeCopyBtn = (btn, getTextFn, successKey) => {
      if (!btn) return;
      btn.onclick = async () => {
        const text = getTextFn();
        if (!text) return;
        try {
          await navigator.clipboard.writeText(text);
          const orig = btn.textContent;
          btn.textContent = '✅';
          btn.classList.add('copied');
          setTimeout(() => { btn.textContent = orig; btn.classList.remove('copied'); }, 1500);
          if (typeof showToast === 'function') showToast(t(successKey, 'Copié ✅'));
        } catch(e) {
          // Fallback: select an input
          try {
            const tmp = document.createElement('input');
            tmp.value = text; tmp.style.position='fixed'; tmp.style.opacity='0';
            document.body.appendChild(tmp); tmp.select(); document.execCommand('copy');
            document.body.removeChild(tmp);
            btn.textContent = '✅'; btn.classList.add('copied');
            setTimeout(() => { btn.textContent = 'Copier'; btn.classList.remove('copied'); }, 1500);
          } catch(_) {}
        }
      };
    };

    _makeCopyBtn(invCopyCode,
      () => (online.room || onlineEls.roomCode?.textContent || '').trim(),
      'onlineCodeCopied');
    _makeCopyBtn(invCopyLink,
      () => _inviteLink((online.room || onlineEls.roomCode?.textContent || '').trim()),
      'onlineLinkCopied');

    if (invShareBtn) {
      invShareBtn.onclick = async () => {
        const c = (online.room || onlineEls.roomCode?.textContent || '').trim();
        if (!c) return;
        const link = _inviteLink(c);
        try {
          await navigator.share({ title: document.title || 'Tiddas', text: t('onlineShareText','Rejoins mon salon Tiddas :'), url: link });
        } catch(_) {}
      };
    }

    if (inviteToggle && invitePanel) {
      inviteToggle.onclick = () => {
        const isOpen = invitePanel.classList.contains('open');
        if (!isOpen) _updateInvitePanel();
        invitePanel.classList.toggle('open');
        inviteToggle.setAttribute('aria-expanded', String(!isOpen));
      };
    }

    // Keep invite panel values fresh when room code is set (MutationObserver)
    if (onlineEls.roomCode) {
      const obs = new MutationObserver(() => { _updateInvitePanel(); });
      obs.observe(onlineEls.roomCode, { childList: true, characterData: true, subtree: true });
    }

    // ── Lancer la partie ─────────────────────────────────────
    if (onlineEls.btnStart) onlineEls.btnStart.onclick = () => { onlineStartMatch_Back4App(); };

    // ── Persist local nickname ────────────────────────────────
    try {
      const savedName = localStorage.getItem('tiddas_online_name_v1') || '';
      if (onlineEls.inputName && !onlineEls.inputName.value) onlineEls.inputName.value = savedName;
      if (onlineEls.inputName) {
        onlineEls.inputName.addEventListener('input', () => {
          const n = (onlineEls.inputName.value || '').trim();
          try { localStorage.setItem('tiddas_online_name_v1', n); } catch(_) {}
          // If there's a code in the join field and user just typed their name → auto-connect
          const code = (onlineEls.inputCode?.value || '').trim().toUpperCase();
          if (code.length >= 4 && n && !online.connected) {
            // Don't auto-connect on every keystroke — only if coming from URL auto-join
          }
        });
      }
    } catch(_) {}
  });
}

function onlineConnectToRoom(code, creating) {
  // Back4App (no LiveQuery) implementation — defined above
  return onlineConnectToRoom_Back4App(code, creating);
}
document.querySelectorAll('.difficulty-btn').forEach(btn => btn.addEventListener('click', () => {
aiDifficulty = parseInt(btn.dataset.level);
if (gameMode === 'spectator') {
variant = variant || 'TIDDEST-no-diag';
startSpectatorGame();
} else {
showScreen('player-setup-area');
}
}));

document.getElementById('start-game-from-setup').addEventListener('click', startGame);

document.getElementById('back-to-versions-btn').addEventListener('click', () => showScreen('version-selection-area'));

document.getElementById('back-to-modes-btn').addEventListener('click', () => showScreen('mode-selection-area'));

document.getElementById('back-to-modes-from-setup-btn').addEventListener('click', () => {
if (gameMode === 'ai') showScreen('ai-difficulty-selection-area');
else showScreen('mode-selection-area');
});

colorOptions.forEach(option => option.addEventListener('click', () => {
humanPlayerId = parseInt(option.dataset.player);
updateColorOptionSelection(humanPlayerId);
}));

// --- Player names: auto-save on each edit ---
applySavedSetupNames(false);
if (player1NameInput) {
  player1NameInput.addEventListener('input', scheduleSaveNamePrefs);
  player1NameInput.addEventListener('change', scheduleSaveNamePrefs);
}
if (player2NameInput) {
  player2NameInput.addEventListener('input', scheduleSaveNamePrefs);
  player2NameInput.addEventListener('change', scheduleSaveNamePrefs);
}

document.getElementById('new-game').addEventListener('click',
() => {
hideWinnerAnimation(); showScreen('version-selection-area');
});
document.getElementById('restart').addEventListener('click', handleReplayClick);

winnerReplayButton.addEventListener('click', handleReplayClick);
if (winnerMenuBtn) winnerMenuBtn.addEventListener('click', () => {
  hideWinnerAnimation();
  // Retour menu / modes selon le contexte
  try {
    if (gameMode === 'online') { onlineDisconnect?.(); }
  } catch(_) {}
  showScreen('mode-selection-area');
});
undoBtn.addEventListener('click',
handleUndo);

surrenderBtn.addEventListener('click',
() => {
showConfirmationModal('surrender', 'surrenderConfirm', handleSurrender);
});

modalConfirmBtn.addEventListener('click',
() => {
if (onConfirmCallback) onConfirmCallback();
hideConfirmationModal();
});

modalCancelBtn.addEventListener('click',
hideConfirmationModal);

confirmationModal.addEventListener('click',
(e) => {
if (e.target === confirmationModal) hideConfirmationModal();
});

showRulesBtn.addEventListener('click',
showRulesModal);
rulesCloseBtn.addEventListener('click',
hideRulesModal);
rulesModal.addEventListener('click',
(e) => {
if (e.target === rulesModal) hideRulesModal();
});

if (showAboutBtn) showAboutBtn.addEventListener('click', showAboutModal);
if (aboutCloseBtn) aboutCloseBtn.addEventListener('click', hideAboutModal);
if (aboutModal) aboutModal.addEventListener('click', (e) => {
if (e.target === aboutModal) hideAboutModal();
});
document.addEventListener('keydown',
(e) => {
if (e.key === 'Escape' && aboutModal && aboutModal.classList.contains('active')) hideAboutModal();
});

updateLanguage(languageSelect.value || 'fr');
showScreen('version-selection-area');


// Initialize replay button states
if (typeof refreshReplayButtons === 'function') refreshReplayButtons();

// A11y board
if (typeof attachBoardA11yOnce === 'function') attachBoardA11yOnce();

// Guided mode button
if (typeof applyGuidedBtn === 'function') applyGuidedBtn();

// Mode glisser-déposer
loadDragPref();
applyDragBtn();
const dragBtn = document.getElementById('drag-btn');
if (dragBtn) dragBtn.addEventListener('click', toggleDragMode);


// Service worker
setTimeout(registerServiceWorker, 1200);

}); // fin DOMContentLoaded

})(); // fin IIFE principale
</script>

  <!-- Added for robustness (referenced by JS/CSS) -->
  <canvas id="confetti-canvas" aria-hidden="true"></canvas>
  <div id="ephemeral-message-bubble" aria-live="polite" aria-atomic="true"></div>
</body>
</html>
